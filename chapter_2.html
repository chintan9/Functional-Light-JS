<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 2 - Functional-Light JavaScript</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="chapter_2.html" class="active"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="chapter-item expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="chapter-item expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="chapter-item expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="chapter-item expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Functional-Light JavaScript</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-2-the-nature-of-functions" id="chapter-2-the-nature-of-functions">Chapter 2: The Nature Of Functions</a></h1>
<p>Functional Programming is <strong>not just programming with the <code>function</code> keyword.</strong>
Oh, if only it was that easy -- I could end the book right here! Nevertheless,
functions really <em>are</em> at the center of FP. And it's how we use functions that
makes our code <em>functional</em>.</p>
<p>But how sure are you that you know what <em>function</em> really means?</p>
<p>In this chapter, we're going to lay the groundwork for the rest of the book by
exploring all the foundational aspects of functions. Actually, this is a review
of all the things even a non-FP programmer should know about functions. But
certainly if we want to get the most out of FP concepts, it's essential we
<em>know</em> functions inside and out.</p>
<p>Brace yourself, because there's a lot more to the function than you may have
realized.</p>
<h2><a class="header" href="#what-is-a-function" id="what-is-a-function">What Is a Function?</a></h2>
<p>The question &quot;What is a function?&quot; superficially seems to have an obvious
answer: a function is a collection of code that can be executed one or more
times.</p>
<p>While this definition is reasonable, it's missing some very important essence
that is the core of a <em>function</em> as it applies to FP. So let's dig below the
surface to understand functions more completely.</p>
<h3><a class="header" href="#brief-math-review" id="brief-math-review">Brief Math Review</a></h3>
<p>I know I've promised we'd stay away from math as much as possible, but bear with
me for a moment as we quickly observe some fundamental things about functions
and graphs from algebra before we proceed.</p>
<p>Do you remember learning anything about <code>f(x)</code> back in school? What about the
equation <code>y = f(x)</code>?</p>
<p>Let's say an equation is defined like this: <code>f(x) = 2x<sup>2</sup> +
3</code>. What does that mean? What does it mean to graph that equation? Here's
the graph:</p>
<p align="center">
    <img alt="figure" src="images/fig1.png" width="40%">
</p>
<p>What you can notice is that for any value of <code>x</code>, say <code>2</code>, if you plug it into
the equation, you get <code>11</code>. What is <code>11</code>, though? It's the <em>return value</em> of the
<code>f(x)</code> function, which earlier we said represents a <code>y</code> value.</p>
<p>In other words, we can choose to interpret the input and output values as a
point at <code>(2,11)</code> on that curve in the graph. And for every value of <code>x</code> we plug
in, we get another <code>y</code> value that pairs with it as a coordinate for a point.
Another is <code>(0,3)</code>, and another is <code>(-1,5)</code>. Put all those points together, and
you have the graph of that parabolic curve as shown here.</p>
<p>So what's any of this got to do with FP?</p>
<p>In math, a function always takes input(s), and always gives an output. A term
you'll often hear around FP is &quot;morphism&quot;; this is a fancy way of describing a
set of values that maps to another set of values, like the inputs of a function
related to the outputs of that function.</p>
<p>In algebraic math, those inputs and outputs are often interpreted as components
of coordinates to be graphed. In our programs, however, we can define functions
with all sorts of input(s) and output(s), even though they'll rarely be
interpreted as a visually plotted curve on a graph.</p>
<h3><a class="header" href="#function-vs-procedure" id="function-vs-procedure">Function vs Procedure</a></h3>
<p>So why all the talk of math and graphs? Because essentially Functional
Programming is about embracing using functions as <em>functions</em> in this
mathematical sense.</p>
<p>You may be more accustomed to thinking of functions as procedures. What's the
difference? A procedure is an arbitrary collection of functionality. It may have
inputs, it may not. It may have an output (<code>return</code> value), it may not.</p>
<p>A function takes input(s) and definitely always has a <code>return</code> value.</p>
<p>If you plan to do Functional Programming, <strong>you should be using functions as
much as possible</strong>, and trying to avoid procedures wherever possible. All your
<code>function</code>s should take input(s) and return output(s).</p>
<p>Why? The answer to that will have many levels of meaning that we'll uncover
throughout this book.</p>
<h2><a class="header" href="#function-input" id="function-input">Function Input</a></h2>
<p>So far, we can conclude that functions must expect input. But let's dig into how
function inputs work.</p>
<p>You sometimes hear people refer to these inputs as &quot;arguments&quot; and sometimes as
&quot;parameters&quot;. So what's that all about?</p>
<p><em>Arguments</em> are the values you pass in, and <em>parameters</em> are the named variables
inside the function that receive those passed-in values. Example:</p>
<pre><code class="language-js">function foo(x, y) {
  // ..
}

var a = 3;

foo(a, a * 2);
</code></pre>
<p><code>a</code> and <code>a * 2</code> (actually, the result of <code>a * 2</code>, which is <code>6</code>) are the
<em>arguments</em> to the <code>foo(..)</code> call. <code>x</code> and <code>y</code> are the <em>parameters</em> that receive
the argument values (<code>3</code> and <code>6</code>, respectively).</p>
<p><strong>Note:</strong> In JavaScript, there's no requirement that the number of <em>arguments</em>
matches the number of <em>parameters</em>. If you pass more <em>arguments</em> than you have
declared <em>parameters</em> to receive them, the values pass in just fine untouched.
These values can be accessed in a few different ways, including the old-school
<code>arguments</code> object you may have heard of before. If you pass fewer <em>arguments</em>
than the declared <em>parameters</em>, each unmatched parameter is treated as an
&quot;undefined&quot; variable, meaning it's present and available in the scope of the
function, but just starts out with the empty <code>undefined</code> value.</p>
<h3><a class="header" href="#defaulting-parameters" id="defaulting-parameters">Defaulting Parameters</a></h3>
<p>As of ES6, parameters can declare <em>default values</em>. In the case where the
argument for that parameter is not passed, or it's passed the value <code>undefined</code>,
the default assignment expression is substituted.</p>
<p>Consider:</p>
<pre><code class="language-js">function foo(x = 3) {
  console.log(x);
}

foo(); // 3
foo(undefined); // 3
foo(null); // null
foo(0); // 0
</code></pre>
<p>It's always a good practice to think about any default cases that can aid the
usability of your functions. However, defaulting parameters can lead to more
complexity in terms of reading and understanding the variations of how a
function is called. Be judicious in how much you rely on this feature.</p>
<h3><a class="header" href="#counting-inputs" id="counting-inputs">Counting Inputs</a></h3>
<p>The number of arguments a function &quot;expects&quot; -- how many arguments you'll likely
want to pass to it -- is determined by the number of parameters that are
declared:</p>
<pre><code class="language-js">function foo(x, y, z) {
  // ..
}
</code></pre>
<p><code>foo(..)</code> <em>expects</em> three arguments, because it has three declared parameters.
This count has a special term: arity. Arity is the number of parameters in a
function declaration. The arity of <code>foo(..)</code> is <code>3</code>.</p>
<p>Furthermore, a function with arity 1 is also called &quot;unary&quot;, a function with
arity 2 is also called &quot;binary&quot;, and a function with arity 3 or higher is called
&quot;n-ary&quot;.</p>
<p>You may wish to inspect a function reference during the runtime of a program to
determine its arity. This can be done with the <code>length</code> property of that
function reference:</p>
<pre><code class="language-js">function foo(x, y, z) {
  // ..
}

foo.length; // 3
</code></pre>
<p>One reason for determining the arity during execution would be if a piece of
code received a function reference from multiple sources, and sent different
values depending on the arity of each.</p>
<p>For example, imagine a case where an <code>fn</code> function reference could expect one,
two, or three arguments, but you always want to just pass a variable <code>x</code> in the
last position:</p>
<pre><code class="language-js">// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
  fn(x);
} else if (fn.length == 2) {
  fn(undefined, x);
} else if (fn.length == 3) {
  fn(undefined, undefined, x);
}
</code></pre>
<p><strong>Tip:</strong> The <code>length</code> property of a function is read-only and it's determined at
the time you declare the function. It should be thought of as essentially a
piece of metadata that describes something about the intended usage of the
function.</p>
<p>One gotcha to be aware of is that certain kinds of parameter list variations can
make the <code>length</code> property of the function report something different than you
might expect:</p>
<pre><code class="language-js">function foo(x, y = 2) {
  // ..
}

function bar(x, ...args) {
  // ..
}

function baz({ a, b }) {
  // ..
}

foo.length; // 1
bar.length; // 1
baz.length; // 1
</code></pre>
<p>What about counting the number of arguments the current function call received?
This was once trivial, but now the situation is slightly more complicated. Each
function has an <code>arguments</code> object (array-like) available that holds a reference
to each of the arguments passed in. You can then inspect the <code>length</code> property
of <code>arguments</code> to figure out how many were actually passed:</p>
<pre><code class="language-js">function foo(x, y, z) {
  console.log(arguments.length);
}

foo(3, 4); // 2
</code></pre>
<p>As of ES5 (and strict mode, specifically), <code>arguments</code> is considered by some to
be sort of deprecated; many avoid using it if possible. In JS, we &quot;never&quot; break
backward compatibility no matter how helpful that may be for future progress, so
<code>arguments</code> will never be removed. But it's now commonly suggested that you
avoid using it whenever possible.</p>
<p>However, I suggest that <code>arguments.length</code>, and only that, is OK to keep using
for those cases where you need to care about the passed number of arguments. A
future version of JS might possibly add a feature that offers the ability to
determine the number of arguments passed without consulting <code>arguments.length</code>;
if that happens, then we can fully drop usage of <code>arguments</code>!</p>
<p>Be careful: <strong>never</strong> access arguments positionally, like <code>arguments[1]</code>. Stick
to <code>arguments.length</code> only, and only if you must.</p>
<p>Except, how will you access an argument that was passed in a position beyond the
declared parameters? I'll answer that in a moment; but first, take a step back
and ask yourself, &quot;Why would I want to do that?&quot; Seriously. Think about that
closely for a minute.</p>
<p>It should be pretty rare that this occurs; it shouldn't be something you
regularly expect or rely on when writing your functions. If you find yourself in
such a scenario, spend an extra 20 minutes trying to design the interaction with
that function in a different way. Name that extra argument even if it's
exceptional.</p>
<p>A function signature that accepts an indeterminate amount of arguments is
referred to as a variadic function. Some people prefer this style of function
design, but I think you'll find that often the FPer wants to avoid these where
possible.</p>
<p>OK, enough harping on that point.</p>
<p>Say you do need to access the arguments in a positional array-like way, possibly
because you're accessing an argument that doesn't have a formal parameter at
that position. How do we do it?</p>
<p>ES6 to the rescue! Let's declare our function with the <code>...</code> operator --
variously referred to as &quot;spread&quot;, &quot;rest&quot;, or (my preference) &quot;gather&quot;:</p>
<pre><code class="language-js">function foo(x, y, z, ...args) {
  // ..
}
</code></pre>
<p>See the <code>...args</code> in the parameter list? That's an ES6 declarative form that
tells the engine to collect (ahem, &quot;gather&quot;) all remaining arguments (if any)
not assigned to named parameters, and put them in a real array named <code>args</code>.
<code>args</code> will always be an array, even if it's empty. But it <strong>will not</strong> include
values that are assigned to the <code>x</code>, <code>y</code>, and <code>z</code> parameters, only anything else
that's passed in beyond those first three values:</p>
<pre><code class="language-js">function foo(x, y, z, ...args) {
  console.log(x, y, z, args);
}

foo(); // undefined undefined undefined []
foo(1, 2, 3); // 1 2 3 []
foo(1, 2, 3, 4); // 1 2 3 [ 4 ]
foo(1, 2, 3, 4, 5); // 1 2 3 [ 4, 5 ]
</code></pre>
<p>So, if you <em>really</em> want to design a function that can account for an arbitrary
number of arguments to be passed in, use <code>...args</code> (or whatever name you like)
on the end. Now, you'll have a real, non-deprecated, non-yucky array to access
those argument values from.</p>
<p>Just pay attention to the fact that the value <code>4</code> is at position <code>0</code> of that
<code>args</code>, not position <code>3</code>. And its <code>length</code> value won't include those three <code>1</code>,
<code>2</code>, and <code>3</code> values. <code>...args</code> gathers everything else, not including the <code>x</code>,
<code>y</code>, and <code>z</code>.</p>
<p>You <em>can</em> use the <code>...</code> operator in the parameter list even if there's no other
formal parameters declared:</p>
<pre><code class="language-js">function foo(...args) {
  // ..
}
</code></pre>
<p>Now <code>args</code> will be the full array of arguments, whatever they are, and you can
use <code>args.length</code> to know exactly how many arguments have been passed in. And
you're safe to use <code>args[1]</code> or <code>args[317]</code> if you so choose. Please don't pass
in 318 arguments, though.</p>
<h3><a class="header" href="#arrays-of-arguments" id="arrays-of-arguments">Arrays of Arguments</a></h3>
<p>What if you wanted to pass along an array of values as the arguments to a
function call?</p>
<pre><code class="language-js">function foo(...args) {
  console.log(args[3]);
}

var arr = [1, 2, 3, 4, 5];

foo(...arr); // 4
</code></pre>
<p>Our new friend <code>...</code> is used, but now not just in the parameter list; it's also
used in the argument list at the call-site. It has the opposite behavior in this
context. In a parameter list, we said it <em>gathered</em> arguments together. In an
argument list, it <em>spreads</em> them out. So the contents of <code>arr</code> are actually
spread out as individual arguments to the <code>foo(..)</code> call. Do you see how that's
different from just passing in a reference to the whole <code>arr</code> array?</p>
<p>By the way, multiple values and <code>...</code> spreadings can be interleaved, as you see
fit:</p>
<pre><code class="language-js">var arr = [2];

foo(1, ...arr, 3, ...[4, 5]); // 4
</code></pre>
<p>Think of <code>...</code> in this symmetric sense: in a value-list position, it <em>spreads</em>.
In an assignment position -- like a parameter list, because arguments get
<em>assigned to</em> parameters -- it <em>gathers</em>.</p>
<p>Whichever behavior you invoke, <code>...</code> makes working with arrays of arguments much
easier. Gone are the days of <code>slice(..)</code>, <code>concat(..)</code>, and <code>apply(..)</code> to
wrangle our argument value arrays.</p>
<p><strong>Tip:</strong> Actually, these methods are not entirely useless. There will be a few
places we rely on them throughout the code in this book. But certainly in most
places, <code>...</code> will be much more declaratively readable, and preferable as a
result.</p>
<h3><a class="header" href="#parameter-destructuring" id="parameter-destructuring">Parameter Destructuring</a></h3>
<p>Consider the variadic <code>foo(..)</code> from the previous section:</p>
<pre><code class="language-js">function foo(...args) {
  // ..
}

foo(...[1, 2, 3]);
</code></pre>
<p>What if we wanted to change that interaction so the caller of our function
passes in an array of values instead of individual argument values? Just drop
the two <code>...</code> usages:</p>
<pre><code class="language-js">function foo(args) {
  // ..
}

foo([1, 2, 3]);
</code></pre>
<p>Simple enough. But what if now we wanted to give a parameter name to each of the
first two values in the passed-in array? We aren't declaring individual
parameters anymore, so it seems we lost that ability.</p>
<p>Thankfully, ES6 destructuring is the answer. Destructuring is a way to declare a
<em>pattern</em> for the kind of structure (object, array, etc.) that you expect to
see, and how decomposition (assignment) of its individual parts should be
processed.</p>
<p>Consider:</p>
<p><a name="funcparamdestr"></a></p>
<pre><code class="language-js">function foo([x, y, ...args] = []) {
  // ..
}

foo([1, 2, 3]);
</code></pre>
<p>Do you spot the <code>[ .. ]</code> brackets around the parameter list now? This is called
array parameter destructuring.</p>
<p>In this example, destructuring tells the engine that an array is expected in
this assignment position (aka parameter). The pattern says to take the first
value of that array and assign to a local parameter variable called <code>x</code>, the
second to <code>y</code>, and whatever is left is <em>gathered</em> into <code>args</code>.</p>
<h3><a class="header" href="#the-importance-of-declarative-style" id="the-importance-of-declarative-style">The Importance of Declarative Style</a></h3>
<p>Considering the destructured <code>foo(..)</code> we just looked at, we could instead have
processed the parameters manually:</p>
<pre><code class="language-js">function foo(params) {
  var x = params[0];
  var y = params[1];
  var args = params.slice(2);

  // ..
}
</code></pre>
<p>But here we highlight a principle we only briefly introduced in
<a href="chapter_1.html">Chapter 1</a>: declarative code communicates more
effectively than imperative code.</p>
<p>Declarative code (for example, the destructuring in the former <code>foo(..)</code>
snippet, or the <code>...</code> operator usages) focuses on what the outcome of a piece of
code should be.</p>
<p>Imperative code (such as the manual assignments in the latter snippet) focuses
more on how to get the outcome. If you later read such imperative code, you have
to mentally execute all of it to understand the desired outcome. The outcome is
<em>coded</em> there, but it's not as clear because it's clouded by the details of
<em>how</em> we get there.</p>
<p>The earlier <code>foo(..)</code> is regarded as more readable, because the destructuring
hides the unnecessary details of <em>how</em> to manage the parameter inputs; the
reader is free to focus only on <em>what</em> we will do with those parameters. That's
clearly the most important concern, so it's what the reader should be focused on
to understand the code most completely.</p>
<p>Wherever possible, and to whatever degrees our language and our
libraries/frameworks will let us, <strong>we should be striving for declarative,
self-explanatory code.</strong></p>
<h2><a class="header" href="#named-arguments" id="named-arguments">Named Arguments</a></h2>
<p>Just as we can destructure array parameters, we can destructure object
parameters:</p>
<pre><code class="language-js">function foo({ x, y } = {}) {
  console.log(x, y);
}

foo({
  y: 3
}); // undefined 3
</code></pre>
<p>We pass in an object as the single argument, and it's destructured into two
separate parameter variables <code>x</code> and <code>y</code>, which are assigned the values of those
corresponding property names from the object passed in. It didn't matter that
the <code>x</code> property wasn't on the object; it just ended up as a variable with
<code>undefined</code> like you'd expect.</p>
<p>But the part of parameter object destructuring I want you to pay attention to is
the object being passed into <code>foo(..)</code>.</p>
<p>With a normal call-site like <code>foo(undefined,3)</code>, position is used to map from
argument to parameter; we put the <code>3</code> in the second position to get it assigned
to a <code>y</code> parameter. But at this new kind of call-site where parameter
destructuring is involved, a simple object-property indicates which parameter
(<code>y</code>) the argument value <code>3</code> should be assigned to.</p>
<p>We didn't have to account for <code>x</code> in <em>that</em> call-site because in effect we
didn't care about <code>x</code>. We just omitted it, instead of having to do something
distracting like passing <code>undefined</code> as a positional placeholder.</p>
<p>Some languages have an explicit feature for this: named arguments. In other
words, at the call-site, labeling an input value to indicate which parameter it
maps to. JavaScript doesn't have named arguments, but parameter object
destructuring is the next best thing.</p>
<p>Another FP-related benefit of using an object destructuring to pass in
potentially multiple arguments is that a function that only takes one parameter
(the object) is much easier to compose with another function's single output.
Much more on that in <a href="chapter_4.html">Chapter 4</a>.</p>
<h3><a class="header" href="#unordered-parameters" id="unordered-parameters">Unordered Parameters</a></h3>
<p>Another key benefit is that named arguments, by virtue of being specified as
object properties, are not fundamentally ordered. That means we can specify
inputs in whatever order we want:</p>
<pre><code class="language-js">function foo({ x, y } = {}) {
  console.log(x, y);
}

foo({
  y: 3
}); // undefined 3
</code></pre>
<p>We're skipping the <code>x</code> parameter by simply omitting it. Or we could specify an
<code>x</code> argument if we cared to, even if we listed it after <code>y</code> in the object
literal. The call-site is no longer cluttered by ordered-placeholders like
<code>undefined</code> to skip a parameter.</p>
<p>Named arguments are much more flexible, and attractive from a readability
perspective, especially when the function in question can take three, four, or
more inputs.</p>
<p><strong>Tip:</strong> If this style of function arguments seems useful or interesting to you,
check out coverage of my <a href="apC.html">FPO library in Appendix C</a>.</p>
<h2><a class="header" href="#function-output" id="function-output">Function Output</a></h2>
<p>Let's shift our attention from a function's inputs to its output.</p>
<p>In JavaScript, functions always return a value. These three functions all have
identical <code>return</code> behavior:</p>
<pre><code class="language-js">function foo() {}

function bar() {
  return;
}

function baz() {
  return undefined;
}
</code></pre>
<p>The <code>undefined</code> value is implicitly <code>return</code>ed if you have no <code>return</code> or if you
just have an empty <code>return;</code>.</p>
<p>But keeping as much with the spirit of FP function definition as possible --
using functions and not procedures -- our functions should always have outputs,
which means they should explicitly <code>return</code> a value, and usually not
<code>undefined</code>.</p>
<p>A <code>return</code> statement can only return a single value. So if your function needs
to return multiple values, your only viable option is to collect them into a
compound value like an array or an object:</p>
<pre><code class="language-js">function foo() {
  var retValue1 = 11;
  var retValue2 = 31;
  return [retValue1, retValue2];
}
</code></pre>
<p>Then, we'll assign <code>x</code> and <code>y</code> from two respective items in the array that comes
back from <code>foo()</code>:</p>
<pre><code class="language-js">var [x, y] = foo();
console.log(x + y); // 42
</code></pre>
<p>Collecting multiple values into an array (or object) to return, and subsequently
destructuring those values back into distinct assignments, is a way to
transparently express multiple outputs for a function.</p>
<p><strong>Tip:</strong> I'd be remiss if I didn't suggest you take a moment to consider if a
function needing multiple outputs could be refactored to avoid that, perhaps
separated into two or more smaller single-purpose functions? Sometimes that will
be possible, sometimes not; but you should at least consider it.</p>
<h3><a class="header" href="#early-returns" id="early-returns">Early Returns</a></h3>
<p>The <code>return</code> statement doesn't just return a value from a function. It's also a
flow control structure; it ends the execution of the function at that point. A
function with multiple <code>return</code> statements thus has multiple possible exit
points, meaning that it may be harder to read a function to understand its
output behavior if there are many paths that could produce that output.</p>
<p>Consider:</p>
<pre><code class="language-js">function foo(x) {
  if (x &gt; 10) return x + 1;

  var y = x / 2;

  if (y &gt; 3) {
    if (x % 2 == 0) return x;
  }

  if (y &gt; 1) return y;

  return x;
}
</code></pre>
<p>Pop quiz: without cheating and running this code in your browser, what does
<code>foo(2)</code> return? What about <code>foo(4)</code>? And <code>foo(8)</code>? And <code>foo(12)</code>?</p>
<p>How confident are you in your answers? How much mental tax did you pay to get
those answers? I got it wrong the first two times I tried to think it through,
and I wrote it!</p>
<p>I think part of the readability problem here is that we're using <code>return</code> not
just to return different values, but also as a flow control construct to quit a
function's execution early in certain cases. There are obviously better ways to
write that flow control (the <code>if</code> logic, etc.), but I also think there are ways
to make the output paths more obvious.</p>
<p><strong>Note:</strong> The answers to the pop quiz are <code>2</code>, <code>2</code>, <code>8</code>, and <code>13</code>.</p>
<p>Consider this version of the code:</p>
<pre><code class="language-js">function foo(x) {
  var retValue;

  if (retValue == undefined &amp;&amp; x &gt; 10) {
    retValue = x + 1;
  }

  var y = x / 2;

  if (y &gt; 3) {
    if (retValue == undefined &amp;&amp; x % 2 == 0) {
      retValue = x;
    }
  }

  if (retValue == undefined &amp;&amp; y &gt; 1) {
    retValue = y;
  }

  if (retValue == undefined) {
    retValue = x;
  }

  return retValue;
}
</code></pre>
<p>This version is unquestionably more verbose. But I would argue it's slightly
simpler logic to follow, because every branch where <code>retValue</code> can get set is
<em>guarded</em> by the condition that checks if it's already been set.</p>
<p>Rather than <code>return</code>ing from the function early, we used normal flow control
(<code>if</code> logic) to determine the <code>retValue</code>'s assignment. At the end, we simply
<code>return retValue</code>.</p>
<p>I'm not unconditionally saying that you should always have a single <code>return</code>, or
that you should never do early <code>return</code>s, but I do think you should be careful
about the flow control part of <code>return</code> creating more implicitness in your
function definitions. Try to figure out the most explicit way to express the
logic; that will often be the best way.</p>
<h3><a class="header" href="#unreturned-outputs" id="unreturned-outputs">Un<code>return</code>ed Outputs</a></h3>
<p>One technique that you've probably used in most code you've written, and maybe
didn't even think about it much, is to have a function output some or all of its
values by simply changing variables outside itself.</p>
<p>Remember our <code>f(x) = 2x<sup>2</sup> + 3</code> function from earlier in the
chapter? We could have defined it like this in JS:</p>
<pre><code class="language-js">var y;

function f(x) {
  y = 2 * Math.pow(x, 2) + 3;
}

f(2);

y; // 11
</code></pre>
<p>I know this is a silly example; we could just as easily have <code>return</code>d the value
instead of setting it into <code>y</code> from within the function:</p>
<pre><code class="language-js">function f(x) {
  return 2 * Math.pow(x, 2) + 3;
}

var y = f(2);

y; // 11
</code></pre>
<p>Both functions accomplish the same task, so is there any reason we should pick
one version over the other? <strong>Yes, absolutely.</strong></p>
<p>One way to explain the difference is that the <code>return</code> in the latter version
signals an explicit output, whereas the <code>y</code> assignment in the former is an
implicit output. You may already have some intuition that guides you in such
cases; typically, developers prefer explicit patterns over implicit ones.</p>
<p>But changing a variable in an outer scope, as we did with the <code>y</code> assignment
inside of <code>foo(..)</code>, is just one way of achieving an implicit output. A more
subtle example is making changes to non-local values via reference.</p>
<p>Consider:</p>
<pre><code class="language-js">function sum(list) {
  var total = 0;
  for (let i = 0; i &lt; list.length; i++) {
    if (!list[i]) list[i] = 0;

    total = total + list[i];
  }

  return total;
}

var nums = [1, 3, 9, 27, , 84];

sum(nums); // 124
</code></pre>
<p>The most obvious output from this function is the sum <code>124</code>, which we explicitly
<code>return</code>ed. But do you spot the other output? Try that code and then inspect the
<code>nums</code> array. Now do you spot the difference?</p>
<p>Instead of an <code>undefined</code> empty slot value in position <code>4</code>, now there's a <code>0</code>.
The harmless looking <code>list[i] = 0</code> operation ended up affecting the array value
on the outside, even though we operated on a local <code>list</code> parameter variable.</p>
<p>Why? Because <code>list</code> holds a reference-copy of the <code>nums</code> reference, not a
value-copy of the <code>[1,3,9,..]</code> array value. JavaScript uses references and
reference-copies for arrays, objects, and functions, so we may create an
accidental output from our function all too easily.</p>
<p>This implicit function output has a special name in the FP world: side effects.
And a function that has <em>no side effects</em> also has a special name: pure
function. We'll talk a lot more about these in <a href="chapter_5.html">Chapter 5</a>, but
the punchline is that we'll want to prefer pure functions and avoid side effects
wherever possible.</p>
<h2><a class="header" href="#functions-of-functions" id="functions-of-functions">Functions of Functions</a></h2>
<p>Functions can receive and return values of any type. A function that receives or
returns one or more other function values has the special name: higher-order
function.</p>
<p>Consider:</p>
<pre><code class="language-js">function forEach(list, fn) {
  for (let v of list) {
    fn(v);
  }
}

forEach([1, 2, 3, 4, 5], function each(val) {
  console.log(val);
});
// 1 2 3 4 5
</code></pre>
<p><code>forEach(..)</code> is a higher-order function because it receives a function as an
argument.</p>
<p>A higher-order function can also output another function, like:</p>
<pre><code class="language-js">function foo() {
  return function inner(msg) {
    return msg.toUpperCase();
  };
}

var f = foo();

f(&quot;Hello!&quot;); // HELLO!
</code></pre>
<p><code>return</code> is not the only way to &quot;output&quot; an inner function:</p>
<pre><code class="language-js">function foo() {
  return bar(function inner(msg) {
    return msg.toUpperCase();
  });
}

function bar(func) {
  return func(&quot;Hello!&quot;);
}

foo(); // HELLO!
</code></pre>
<p>Functions that treat other functions as values are higher-order functions by
definition. FPers write these all the time!</p>
<h3><a class="header" href="#keeping-scope" id="keeping-scope">Keeping Scope</a></h3>
<p>One of the most powerful things in all of programming, and especially in FP, is
how a function behaves when it's inside another function's scope. When the inner
function makes reference to a variable from the outer function, this is called
closure.</p>
<p>Defined pragmatically:</p>
<blockquote>
<p>Closure is when a function remembers and accesses variables from outside of
its own scope, even when that function is executed in a different scope.</p>
</blockquote>
<p>Consider:</p>
<pre><code class="language-js">function foo(msg) {
  var fn = function inner() {
    return msg.toUpperCase();
  };

  return fn;
}

var helloFn = foo(&quot;Hello!&quot;);

helloFn(); // HELLO!
</code></pre>
<p>The <code>msg</code> parameter variable in the scope of <code>foo(..)</code> is referenced inside the
inner function. When <code>foo(..)</code> is executed and the inner function is created, it
captures the access to the <code>msg</code> variable, and retains that access even after
being <code>return</code>ed.</p>
<p>Once we have <code>helloFn</code>, a reference to the inner function, <code>foo(..)</code> has
finished and it would seem as if its scope should have gone away, meaning the
<code>msg</code> variable would no longer exist. But that doesn't happen, because the inner
function has a closure over <code>msg</code> that keeps it alive. The closed over <code>msg</code>
variable survives for as long as the inner function (now referenced by <code>helloFn</code>
in a different scope) stays around.</p>
<p>Let's look at a few more examples of closure in action:</p>
<pre><code class="language-js">function person(name) {
  return function identify() {
    console.log(`I am ${name}`);
  };
}

var fred = person(&quot;Fred&quot;);
var susan = person(&quot;Susan&quot;);

fred(); // I am Fred
susan(); // I am Susan
</code></pre>
<p>The inner function <code>identify()</code> has closure over the parameter <code>name</code>.</p>
<p>The access that closure enables is not restricted to merely reading the
variable's original value -- it's not just a snapshot but rather a live link.
You can update the value, and that new current state remains remembered until
the next access:</p>
<pre><code class="language-js">function runningCounter(start) {
  var val = start;

  return function current(increment = 1) {
    val = val + increment;
    return val;
  };
}

var score = runningCounter(0);

score(); // 1
score(); // 2
score(13); // 15
</code></pre>
<p><strong>Warning:</strong> For reasons that we'll explore in more depth later in the book,
this example of using closure to remember a state that changes (<code>val</code>) is
probably something you'll want to avoid where possible.</p>
<p>If you have an operation that needs two inputs, one of which you know now but
the other will be specified later, you can use closure to remember the first
input:</p>
<pre><code class="language-js">function makeAdder(x) {
  return function sum(y) {
    return x + y;
  };
}

// we already know `10` and `37` as first inputs, respectively
var addTo10 = makeAdder(10);
var addTo37 = makeAdder(37);

// later, we specify the second inputs
addTo10(3); // 13
addTo10(90); // 100

addTo37(13); // 50
</code></pre>
<p>Normally, a <code>sum(..)</code> function would take both an <code>x</code> and <code>y</code> input to add them
together. But in this example we receive and remember (via closure) the <code>x</code>
value(s) first, while the <code>y</code> value(s) are separately specified later.</p>
<p><strong>Note:</strong> This technique of specifying inputs in successive function calls is
very common in FP, and comes in two forms: partial application and currying.
We'll dive into them more thoroughly in
<a href="chapter_3.html">Chapter 3</a>.</p>
<p>Of course, since functions are just values in JS, we can remember function
values via closure:</p>
<pre><code class="language-js">function formatter(formatFn) {
  return function inner(str) {
    return formatFn(str);
  };
}

var lower = formatter(function formatting(v) {
  return v.toLowerCase();
});

var upperFirst = formatter(function formatting(v) {
  return v[0].toUpperCase() + v.substr(1).toLowerCase();
});

lower(&quot;WOW&quot;); // wow
upperFirst(&quot;hello&quot;); // Hello
</code></pre>
<p>Instead of distributing/repeating the <code>toUpperCase()</code> and <code>toLowerCase()</code> logic
all over our code, FP encourages us to create simple functions that encapsulate
-- a fancy way of saying wrapping up -- that behavior.</p>
<p>Specifically, we create two simple unary functions <code>lower(..)</code> and
<code>upperFirst(..)</code>, because those functions will be much easier to wire up to work
with other functions in the rest of our program.</p>
<p><strong>Tip:</strong> Did you spot how <code>upperFirst(..)</code> could have used <code>lower(..)</code>?</p>
<p>We'll use closure heavily throughout the rest of the text. It may just be the
most important foundational practice in all of FP, if not programming as a
whole. Make sure you're really comfortable with it!</p>
<h2><a class="header" href="#syntax" id="syntax">Syntax</a></h2>
<p>Before we move on from this primer on functions, let's take a moment to discuss
their syntax.</p>
<p>More than many other parts of this text, the discussions in this section are
mostly opinion and preference, whether you agree with the views presented here
or take opposite ones. These ideas are highly subjective, though many people
seem to feel rather absolutely about them.</p>
<p>Ultimately, you get to decide.</p>
<h3><a class="header" href="#whats-in-a-name" id="whats-in-a-name">What's in a Name?</a></h3>
<p>Syntactically speaking, function declarations require the inclusion of a name:</p>
<pre><code class="language-js">function helloMyNameIs() {
  // ..
}
</code></pre>
<p>But function expressions can come in both named and anonymous forms:</p>
<pre><code class="language-js">foo(function namedFunctionExpr() {
  // ..
});

bar(function() {
  // &lt;-- look, no name!
  // ..
});
</code></pre>
<p>What exactly do we mean by anonymous, by the way? Specifically, functions have a
<code>name</code> property that holds the string value of the name the function was given
syntactically, such as <code>&quot;helloMyNameIs&quot;</code> or <code>&quot;namedFunctionExpr&quot;</code>. This <code>name</code>
property is most notably used by the console/developer tools of your JS
environment to list the function when it participates in a stack trace (usually
from an exception).</p>
<p>Anonymous functions are generally displayed as <code>(anonymous function)</code>.</p>
<p>If you've ever had to debug a JS program from nothing but a stack trace of an
exception, you probably have felt the pain of seeing <code>(anonymous function)</code>
appear line after line. This listing doesn't give a developer any clue
whatsoever as to the path the exception came from. It's not doing the developer
any favors.</p>
<p>If you name your function expressions, the name is always used. So if you use a
good name like <code>handleProfileClicks</code> instead of <code>foo</code>, you'll get much more
helpful stack traces.</p>
<p>As of ES6, anonymous function expressions are in certain cases aided by <em>name
inferencing</em>. Consider:</p>
<pre><code class="language-js">var x = function() {};

x.name; // x
</code></pre>
<p>If the engine is able to guess what name you <em>probably</em> want the function to
take, it will go ahead and do so.</p>
<p>But beware, not all syntactic forms benefit from name inferencing. Probably the
most common place a function expression shows up is as an argument to a function
call:</p>
<pre><code class="language-js">function foo(fn) {
  console.log(fn.name);
}

var x = function() {};

foo(x); // x
foo(function() {}); //
</code></pre>
<p>When the name can't be inferred from the immediate surrounding syntax, it
remains an empty string. Such a function will be reported as
<code>(anonymous function)</code> in a stack trace should one occur.</p>
<p>There are other benefits to a function being named besides the debugging
question. First, the syntactic name (aka lexical name) is useful for internal
self-reference. Self-reference is necessary for recursion (both sync and async)
and also helpful with event handlers.</p>
<p>Consider these different scenarios:</p>
<pre><code class="language-js">// sync recursion:
function findPropIn(propName, obj) {
  if (obj == undefined || typeof obj != &quot;object&quot;) return;

  if (propName in obj) {
    return obj[propName];
  } else {
    for (let prop of Object.keys(obj)) {
      let ret = findPropIn(propName, obj[prop]);
      if (ret !== undefined) {
        return ret;
      }
    }
  }
}
</code></pre>
<pre><code class="language-js">// async recursion:
setTimeout(function waitForIt() {
  // does `it` exist yet?
  if (!o.it) {
    // try again later
    setTimeout(waitForIt, 100);
  }
}, 100);
</code></pre>
<pre><code class="language-js">// event handler unbinding
document.getElementById(&quot;onceBtn&quot;).addEventListener(
  &quot;click&quot;,
  function handleClick(evt) {
    // unbind event
    evt.target.removeEventListener(&quot;click&quot;, handleClick, false);

    // ..
  },
  false
);
</code></pre>
<p>In all these cases, the named function's lexical name was a useful and reliable
self-reference from inside itself.</p>
<p>Moreover, even in simple cases with one-liner functions, naming them tends to
make code more self-explanatory and thus easier to read for those who haven't
read it before:</p>
<pre><code class="language-js">people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});
// ..
</code></pre>
<p>The function name <code>getPreferredName(..)</code> tells the reader something about what
the mapping operation is intending to do that is not entirely obvious from just
its code. This name label helps the code be more readable.</p>
<p>Another place where anonymous function expressions are common is with
immediately invoked function expressions (IIFEs):</p>
<pre><code class="language-js">(function() {
  // look, I'm an IIFE!
})();
</code></pre>
<p>You virtually never see IIFEs using names for their function expressions, but
they should. Why? For all the same reasons we just went over: stack trace
debugging, reliable self-reference, and readability. If you can't come up with
any other name for your IIFE, at least use the word IIFE:</p>
<pre><code class="language-js">(function IIFE() {
  // You already knew I was an IIFE!
})();
</code></pre>
<p>What I'm getting at is there are multiple reasons why <strong>named functions are
always more preferable to anonymous functions.</strong> As a matter of fact, I'd go so
far as to say that there's basically never a case where an anonymous function is
more preferable. They just don't really have any advantage over their named
counterparts.</p>
<p>It's incredibly easy to write anonymous functions, because it's one less name we
have to devote our mental attention to figuring out.</p>
<p>I'll be honest; I'm as guilty of this as anyone. I don't like to struggle with
naming. The first few names I come up with for a function are usually bad. I
have to revisit the naming over and over. I'd much rather just punt with a good
ol' anonymous function expression.</p>
<p>But we're trading ease-of-writing for pain-of-reading. This is not a good
trade-off. Being lazy or uncreative enough to not want to figure out names for
your functions is an all too common, but poor, excuse for using anonymous
functions.</p>
<p><strong>Name every single function.</strong> And if you sit there stumped, unable to come up
with a good name for some function you've written, I'd strongly suggest you
don't fully understand that function's purpose yet -- or it's just too broad or
abstract. You need to go back and re-design the function until this is more
clear. And by that point, a name will become more apparent.</p>
<p>In my practice, if I don't have a good name to use for a function, I name it
<code>TODO</code> initially. I'm certain that I'll at least catch that later when I search
for &quot;TODO&quot; comments before committing code.</p>
<p>I can testify from my own experience that in the struggle to name something
well, I usually have come to understand it better, later, and often even
refactor its design for improved readability and maintainability.</p>
<p>This time investment is well worth it.</p>
<h3><a class="header" href="#functions-without-function" id="functions-without-function">Functions Without <code>function</code></a></h3>
<p>So far we've been using the full canonical syntax for functions. But you've no
doubt also heard all the buzz around the ES6 <code>=&gt;</code> arrow function syntax.</p>
<p>Compare:</p>
<pre><code class="language-js">people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});

// vs.

people.map(person =&gt; person.nicknames[0] || person.firstName);
</code></pre>
<p>Whoa.</p>
<p>The keyword <code>function</code> is gone, so is <code>return</code>, the parentheses (<code>( )</code>), the
curly braces (<code>{ }</code>), and the innermost semicolon (<code>;</code>). In place of all that,
we used a so-called fat arrow symbol (<code>=&gt;</code>).</p>
<p>But there's another thing we omitted. Did you spot it? The <code>getPreferredName</code>
function name.</p>
<p>That's right; <code>=&gt;</code> arrow functions are lexically anonymous; there's no way to
syntactically provide it a name. Their names can be inferred like regular
functions, but again, the most common case of function expression values passed
as arguments won't get any assistance in that way. Bummer.</p>
<p>If <code>person.nicknames</code> isn't defined for some reason, an exception will be
thrown, meaning this <code>(anonymous function)</code> will be at the top of the stack
trace. Ugh.</p>
<p>Honestly, the anonymity of <code>=&gt;</code> arrow functions is a <code>=&gt;</code> dagger to the heart,
for me. I cannot abide by the loss of naming. It's harder to read, harder to
debug, and impossible to self-reference.</p>
<p>But if that wasn't bad enough, the other slap in the face is that there's a
whole bunch of subtle syntactic variations that you must wade through if you
have different scenarios for your function definition. I'm not going to cover
all of them in detail here, but briefly:</p>
<pre><code class="language-js">people.map(person =&gt; person.nicknames[0] || person.firstName);

// multiple parameters? need ( )
people.map((person, idx) =&gt; person.nicknames[0] || person.firstName);

// parameter destructuring? need ( )
people.map(({ person }) =&gt; person.nicknames[0] || person.firstName);

// parameter default? need ( )
people.map((person = {}) =&gt; person.nicknames[0] || person.firstName);

// returning an object? need ( )
people.map(person =&gt; ({
  preferredName: person.nicknames[0] || person.firstName
}));
</code></pre>
<p>The case for excitement over <code>=&gt;</code> in the FP world is primarily that it follows
almost exactly from the mathematical notation for functions, especially in FP
languages like Haskell. The shape of <code>=&gt;</code> arrow function syntax communicates
mathematically.</p>
<p>Digging even further, I'd suggest that the argument in favor of <code>=&gt;</code> is that by
using much lighter-weight syntax, we reduce the visual boundaries between
functions which lets us use simple function expressions much like we'd use lazy
expressions -- another favorite of the FPer.</p>
<p>I think most FPers are going to wave off the concerns I'm sharing. They love
anonymous functions and they love saving on syntax. But like I said before: you
decide.</p>
<p><strong>Note:</strong> Though I do not prefer to use <code>=&gt;</code> in practice in my production code,
they are useful in quick code explorations. Moreover, we will use arrow
functions in many places throughout the rest of this book -- especially when we
present typical FP utilities -- where conciseness is preferred to optimize for
the limited physical space in code snippets. Make your own determinations
whether this approach will make your own production-ready code more or less
readable.</p>
<h2><a class="header" href="#whats-this" id="whats-this">What's This?</a></h2>
<p>If you're not familiar with the <code>this</code> binding rules in JavaScript, I recommend
checking out my book <em>You Don't Know JS: this &amp; Object Prototypes</em>. For the
purposes of this section, I'll assume you know how <code>this</code> gets determined for a
function call (one of the four rules). But even if you're still fuzzy on <em>this</em>,
the good news is we're going to conclude that you shouldn't be using <code>this</code> if
you're trying to do FP.</p>
<p><strong>Note:</strong> We're tackling a topic that we'll ultimately conclude we shouldn't
use. Why!? Because the topic of <code>this</code> has implications for other topics covered
later in this book. For example, our notions of function purity are impacted by
<code>this</code> being essentially an implicit input to a function (see
<a href="chapter_5.html">Chapter 5</a>). Additionally, our perspective on <code>this</code> affects
whether we choose array methods (<code>arr.map(..)</code>) versus standalone utilities
(<code>map(..,arr)</code>) (see <a href="chapter_9.html">Chapter 9</a>). Understanding <code>this</code> is
essential to understanding why <code>this</code> really should <em>not</em> be part of your FP!</p>
<p>JavaScript <code>function</code>s have a <code>this</code> keyword that's automatically bound per
function call. The <code>this</code> keyword can be described in many different ways, but I
prefer to say it provides an object context for the function to run against.</p>
<p><code>this</code> is an implicit parameter input for your function.</p>
<p>Consider:</p>
<pre><code class="language-js">function sum() {
  return this.x + this.y;
}

var context = {
  x: 1,
  y: 2
};

sum.call(context); // 3

context.sum = sum;
context.sum(); // 3

var s = sum.bind(context);
s(); // 3
</code></pre>
<p>Of course, if <code>this</code> can be input into a function implicitly, the same object
context could be sent in as an explicit argument:</p>
<pre><code class="language-js">function sum(ctx) {
  return ctx.x + ctx.y;
}

var context = {
  x: 1,
  y: 2
};

sum(context);
</code></pre>
<p>Simpler. And this kind of code will be a lot easier to deal with in FP. It's
much easier to wire multiple functions together, or use any of the other input
wrangling techniques we will get into in the next chapter, when inputs are
always explicit. Doing them with implicit inputs like <code>this</code> ranges from awkward
to nearly impossible depending on the scenario.</p>
<p>There are other tricks we can leverage in a <code>this</code>-based system, including
prototype-delegation (also covered in detail in <em>You Don't Know JS: this &amp;
Object Prototypes</em>):</p>
<pre><code class="language-js">var Auth = {
  authorize() {
    var credentials = `${this.username}:${this.password}`;
    this.send(credentials, resp =&gt; {
      if (resp.error) this.displayError(resp.error);
      else this.displaySuccess();
    });
  },
  send(/* .. */) {
    // ..
  }
};

var Login = Object.assign(Object.create(Auth), {
  doLogin(user, pw) {
    this.username = user;
    this.password = pw;
    this.authorize();
  },
  displayError(err) {
    // ..
  },
  displaySuccess() {
    // ..
  }
});

Login.doLogin(&quot;fred&quot;, &quot;123456&quot;);
</code></pre>
<p><strong>Note:</strong> <code>Object.assign(..)</code> is an ES6+ utility for doing a shallow assignment
copy of properties from one or more source objects to a single target object:
<code>Object.assign( target, source1, ... )</code>.</p>
<p>In case you're having trouble parsing what this code does: we have two separate
objects <code>Login</code> and <code>Auth</code>, where <code>Login</code> performs prototype-delegation to
<code>Auth</code>. Through delegation and the implicit <code>this</code> context sharing, these two
objects virtually compose during the <code>this.authorize()</code> function call, so that
properties/methods on <code>this</code> are dynamically shared with the
<code>Auth.authorize(..)</code> function.</p>
<p><em>This</em> code doesn't fit with various principles of FP for a variety of reasons,
but one of the obvious hitches is the implicit <code>this</code> sharing. We could be more
explicit about it and keep code closer to FP-friendly style:</p>
<pre><code class="language-js">// ..

authorize(ctx) {
    var credentials = `${ctx.username}:${ctx.password}`;
    Auth.send( credentials, function onResp(resp){
        if (resp.error) ctx.displayError( resp.error );
        else ctx.displaySuccess();
    } );
}

// ..

doLogin(user,pw) {
    Auth.authorize( {
        username: user,
        password: pw
    } );
}

// ..
</code></pre>
<p>From my perspective, the problem is not with using objects to organize behavior.
It's that we're trying to use implicit input instead of being explicit about it.
When I'm wearing my FP hat, I want to leave <code>this</code> stuff on the shelf.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Functions are powerful.</p>
<p>But let's be clear what a function is. It's not just a collection of
statements/operations. Specifically, a function needs one or more inputs
(ideally, just one!) and an output.</p>
<p>Functions inside of functions can have closure over outer variables and remember
them for later. This is one of the most important concepts in all of
programming, and a fundamental foundation of FP.</p>
<p>Be careful of anonymous functions, especially <code>=&gt;</code> arrow functions. They're
convenient to write, but they shift the cost from author to reader. The whole
reason we're studying FP here is to write more readable code, so don't be so
quick to jump on that bandwagon.</p>
<p>Don't use <code>this</code>-aware functions. Just don't.</p>
<p>You should now be developing a clear and colorful perspective in your mind of
what <em>function</em> means in Functional Programming. It's time to start wrangling
functions to get them to interoperate, and the next chapter teaches you a
variety of critical techniques you'll need along the way.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_1.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_3.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter_1.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter_3.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
