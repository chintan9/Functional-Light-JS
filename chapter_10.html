<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 10 - Functional-Light JavaScript</title>
        
        


        <!-- Custom HTML head -->
        


        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        
        <link rel="icon" href="favicon.svg">
        
        
        <link rel="shortcut icon" href="favicon.png">
        
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        
        <link rel="stylesheet" href="css/print.css" media="print">
        

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        
        <link rel="stylesheet" href="fonts/fonts.css">
        

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="chapter-item expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="chapter-item expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="chapter-item expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="chapter-item expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="chapter-item expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="chapter-item expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="chapter-item expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="chapter-item expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="chapter-item expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="chapter-item expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="chapter-item expanded "><a href="chapter_10.html" class="active"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="chapter-item expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="chapter-item expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="chapter-item expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="chapter-item expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                        
                    </div>

                    <h1 class="menu-title">Functional-Light JavaScript</h1>

                    <div class="right-buttons">
                        
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        
                        
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-10-functional-async" id="chapter-10-functional-async">Chapter 10: Functional Async</a></h1>
<p>At this point of the book, you now have all the raw concepts in place for the
foundations of FP that I call &quot;Functional-Light Programming&quot;. In this chapter,
we're going to apply these concepts to a different context, but we won't really
present particularly new ideas.</p>
<p>So far, almost everything we've done is synchronous, meaning that we call
functions with immediate inputs and immediately get back output values. A lot of
work can be done this way, but it's not nearly sufficient for the entirety of a
modern JS application. To be truly ready for FP in the real world of JS, we need
to understand async FP.</p>
<p>Our goal in this chapter is to expand our thinking about managing values with
FP, to spread out such operations over time. We'll see that Observables (and
Promises!) are one great way to do that.</p>
<h2><a class="header" href="#time-as-state" id="time-as-state">Time as State</a></h2>
<p>The most complicated state in your entire application is time. That is, it's far
easier to manage state when the transition from one state to another is
immediate and affirmatively in your control. When the state of your application
changes implicitly in response to events spread out over time, management
becomes exponentially more difficult.</p>
<p>Every part of how we've presented FP in this text has been about making code
easier to read by making it more trustable and more predictable. When you
introduce asynchrony to your program, those efforts take a big hit.</p>
<p>But let's be more explicit: it's not the mere fact that some operations don't
finish synchronously that is concerning; firing off asynchronous behavior is
easy. It's the coordination of the responses to these actions, each of which has
the potential to change the state of your application, that requires so much
extra effort.</p>
<p>So, is it better for you the author to take that effort, or should you just
leave it to the reader of your code to figure out what the state of the program
will be if A finishes before B, or vice versa? That's a rhetorical question but
one with a pretty concrete answer from my perspective: to have any hope of
making such complex code more readable, the author has to take a lot more care
than they normally would.</p>
<h3><a class="header" href="#reducing-time" id="reducing-time">Reducing Time</a></h3>
<p>One of the most important outcomes of async programming patterns is simplifying
state change management by abstracting out time from our sphere of concern. To
illustrate, let's first look at a scenario where a race condition (aka, time
complexity) exists, and must be manually managed:</p>
<pre><code class="language-js">var customerId = 42;
var customer;

lookupCustomer(customerId, function onCustomer(customerRecord) {
  var orders = customer ? customer.orders : null;
  customer = customerRecord;
  if (orders) {
    customer.orders = orders;
  }
});

lookupOrders(customerId, function onOrders(customerOrders) {
  if (!customer) {
    customer = {};
  }
  customer.orders = customerOrders;
});
</code></pre>
<p>The <code>onCustomer(..)</code> and <code>onOrders(..)</code> callbacks are in a binary race
condition. Assuming they both run, it's possible that either might run first,
and it's impossible to predict which will happen.</p>
<p>If we could embed the call to <code>lookupOrders(..)</code> inside of <code>onCustomer(..)</code>,
we'd be sure that <code>onOrders(..)</code> was running after <code>onCustomer(..)</code>. But we
can't do that, because we need the two lookups to occur concurrently.</p>
<p>So to normalize this time-based state complexity, we use a pairing of
<code>if</code>-statement checks in the respective callbacks, along with an outer lexically
closed over variable <code>customer</code>. When each callback runs, it checks the state of
<code>customer</code>, and thus determines its own relative ordering; if <code>customer</code> is
unset for a callback, it's the first to run, otherwise it's the second.</p>
<p>This code works, but it's far from ideal in terms of readability. The time
complexity makes this code harder to read. Let's instead use a JS Promise to
factor time out of the picture:</p>
<pre><code class="language-js">var customerId = 42;

var customerPromise = lookupCustomer(customerId);
var ordersPromise = lookupOrders(customerId);

customerPromise.then(function onCustomer(customer) {
  ordersPromise.then(function onOrders(orders) {
    customer.orders = orders;
  });
});
</code></pre>
<p>The <code>onOrders(..)</code> callback is now inside of the <code>onCustomer(..)</code> callback, so
their relative ordering is guaranteed. The concurrency of the lookups is
accomplished by making the <code>lookupCustomer(..)</code> and <code>lookupOrders(..)</code> calls
separately before specifying the <code>then(..)</code> response handling.</p>
<p>It may not be obvious, but there would otherwise inherently be a race condition
in this snippet, were it not for how Promises are defined to behave. If the
lookup of the <code>orders</code> finishes before the <code>ordersPromise.then(..)</code> is called to
provide an <code>onOrders(..)</code> callback, <em>something</em> needs to be smart enough to keep
that <code>orders</code> list around until <code>onOrders(..)</code> can be called. In fact, the same
concern could apply to <code>customer</code> being present before <code>onCustomer(..)</code> is
specified to receive it.</p>
<p>That <em>something</em> is the same kind of time complexity logic we discussed with the
previous snippet. But we don't have to worry about any of that complexity,
either in the writing of this code or -- more importantly -- in the reading of
it, because the promises take care of that time normalization for us.</p>
<p>A Promise represents a single (future) value in a time-independent manner.
Moreover, extracting the value from a promise is the asynchronous form of the
synchronous assignment (via <code>=</code>) of an immediate value. In other words, a
promise spreads an <code>=</code> assignment operation out over time, but in a trustable
(time-independent) fashion.</p>
<p>We'll now explore how we similarly can spread various synchronous FP operations
from earlier in this book asynchronously over time.</p>
<h2><a class="header" href="#eager-vs-lazy" id="eager-vs-lazy">Eager vs. Lazy</a></h2>
<p>Eager and lazy in the realm of computer science aren't compliments or insults,
but rather ways to describe whether an operation will finish right away or
progress over time.</p>
<p>The FP operations that we've seen in this text can be characterized as eager
because they operate synchronously (right now) on a discrete immediate value or
list/structure of values.</p>
<p>Recall:</p>
<pre><code class="language-js">var a = [1, 2, 3];

var b = a.map(v =&gt; v * 2);

b; // [2,4,6]
</code></pre>
<p>This mapping from <code>a</code> to <code>b</code> is eager because it operates on all the values in
the <code>a</code> array at that moment, and produces a new <code>b</code> array. If you later modify
<code>a</code> (for example, by adding a new value to the end of it) nothing will change
about the contents of <code>b</code>. That's eager FP.</p>
<p>But what would it look like to have a lazy FP operation? Consider something like
this:</p>
<pre><code class="language-js">var a = [];

var b = mapLazy(a, v =&gt; v * 2);

a.push(1);

a[0]; // 1
b[0]; // 2

a.push(2);

a[1]; // 2
b[1]; // 4
</code></pre>
<p>The <code>mapLazy(..)</code> we've imagined here essentially &quot;listens&quot; to the <code>a</code> array,
and every time a new value is added to the end of it (with <code>push(..)</code>), it runs
the <code>v =&gt; v * 2</code> mapping function and pushes the transformed value to the <code>b</code>
array.</p>
<p><strong>Note:</strong> The implementation of <code>mapLazy(..)</code> has not been shown because this is
a fictional illustration, not a real operation. To accomplish this kind of lazy
operation pairing between <code>a</code> and <code>b</code>, we'll need something smarter than basic
arrays.</p>
<p>Consider the benefits of being able to pair an <code>a</code> and <code>b</code> together, where any
time (even asynchronously!) you put a value into <code>a</code>, it's transformed and
projected to <code>b</code>. That's the same kind of declarative FP power from of a
<code>map(..)</code> operation, but now it can be stretched over time; you don't have to
know all the values of <code>a</code> <em>right now</em> to set up the mapping from <code>a</code> to <code>b</code>.</p>
<h2><a class="header" href="#reactive-fp" id="reactive-fp">Reactive FP</a></h2>
<p>To understand how we could create and use a lazy mapping between two sets of
values, we need to abstract our idea of list (array) a bit. Let's imagine a
smarter kind of array, not one which simply holds values but one which lazily
receives and responds (aka &quot;reacts&quot;) to values. Consider:</p>
<pre><code class="language-js">var a = new LazyArray();

var b = a.map(function double(v) {
  return v * 2;
});

setInterval(function everySecond() {
  a.push(Math.random());
}, 1000);
</code></pre>
<p>So far, this snippet doesn't look any different than a normal array. The only
unusual thing is that we're used to the <code>map(..)</code> running eagerly and
immediately producing a <code>b</code> array with all the currently mapped values from <code>a</code>.
The timer pushing random values into <code>a</code> is strange, since all those values are
coming <em>after</em> the <code>map(..)</code> call.</p>
<p>But this fictional <code>LazyArray</code> is different; it assumes that values will come
one at a time, over time; just <code>push(..)</code> values in whenever you want. <code>b</code> will
be a lazy mapping of whatever values eventually end up in <code>a</code>.</p>
<p>Also, we don't really need to keep values in <code>a</code> or <code>b</code> once they've been
handled; this special kind of array only holds a value as long as it's needed.
So these arrays don't strictly grow in memory usage over time, an important
characteristic of lazy data structures and operations. In fact, it's less like
an array and more like a buffer.</p>
<p>A normal array is eager in that it holds all of its values right now. A &quot;lazy
array&quot; is an array where the values will come in over time.</p>
<p>Since we won't necessarily know when a new value has arrived in <code>a</code>, another key
thing we need is to be able to listen to <code>b</code> to be notified when new values are
made available. We could imagine a listener like this:</p>
<pre><code class="language-js">b.listen(function onValue(v) {
  console.log(v);
});
</code></pre>
<p><code>b</code> is <em>reactive</em> in that it's set up to <em>react</em> to values as they come into
<code>a</code>. There's an FP operation <code>map(..)</code> that describes how each value transfers
from the origin <code>a</code> to the target <code>b</code>. Each discrete mapping operation is
exactly how we modeled single-value operations with normal synchronous FP, but
here we're spreading out the sourcing of values over time.</p>
<p><strong>Note:</strong> The term most commonly applied to these concepts is Functional
Reactive Programming (FRP). I'm deliberately avoiding that term because there's
some debate as to whether FP + Reactive genuinely constitutes FRP. We're not
going to fully dive into all the implications of FRP here, so I'll just keep
calling it reactive FP. Alternatively, you could call it evented-FP if that
feels less confusing.</p>
<p>We can think of <code>a</code> as producing values and <code>b</code> as consuming them. So for
readability, let's reorganize this snippet to separate the concerns into
<em>producer</em> and <em>consumer</em> roles:</p>
<pre><code class="language-js">// producer:

var a = new LazyArray();

setInterval(function everySecond() {
  a.push(Math.random());
}, 1000);

// **************************
// consumer:

var b = a.map(function double(v) {
  return v * 2;
});

b.listen(function onValue(v) {
  console.log(v);
});
</code></pre>
<p><code>a</code> is the producer, which acts essentially like a stream of values. We can
think of each value arriving in <code>a</code> as an <em>event</em>. The <code>map(..)</code> operation then
triggers a corresponding event on <code>b</code>, which we <code>listen(..)</code> to so we can
consume the new value.</p>
<p>The reason we separate the <em>producer</em> and <em>consumer</em> concerns is so that
different parts of our application can be responsible for each concern. This
code organization can drastically improve both code readability and maintenance.</p>
<h3><a class="header" href="#declarative-time" id="declarative-time">Declarative Time</a></h3>
<p>We're being very careful about how we introduce time into the discussion.
Specifically, just as promises abstract time away from our concern for a single
asynchronous operation, reactive FP abstracts (separates) time away from a
series of values/operations.</p>
<p>From the perspective of <code>a</code> (the producer), the only evident time concern is our
manual <code>setInterval(..)</code> loop. But that's only for demonstration purposes.</p>
<p>Imagine <code>a</code> could actually be attached to some other event source, like the
user's mouse clicks or keystrokes, websocket messages from a server, etc. In
that scenario, <code>a</code> doesn't actually have to concern itself with time. It's
merely a time-independent conduit for values, whenever they are ready.</p>
<p>From the perspective of <code>b</code> (the consumer), we do not know or care when/where
the values in <code>a</code> come from. As a matter of fact, all the values could already
be present. All we care about is that we want those values, whenever they are
ready. Again, this is a time-independent (aka lazy) modeling of the <code>map(..)</code>
transformation operation.</p>
<p>The <em>time</em> relationship between <code>a</code> and <code>b</code> is declarative (and implicit!), not
imperative (or explicit).</p>
<p>The value of organizing such operations-over-time this way may not feel
particularly effective yet. Let's compare to how this same sort of functionality
could have been expressed imperatively:</p>
<pre><code class="language-js">// producer:

var a = {
  onValue(v) {
    b.onValue(v);
  }
};

setInterval(function everySecond() {
  a.onValue(Math.random());
}, 1000);

// **************************
// consumer:

var b = {
  map(v) {
    return v * 2;
  },
  onValue(v) {
    v = this.map(v);
    console.log(v);
  }
};
</code></pre>
<p>It may seem rather subtle, but there's an important difference between this
more-imperative version of the code and the previous more-declarative version,
aside from just <code>b.onValue(..)</code> needing to call <code>this.map(..)</code> itself. In the
former snippet, <code>b</code> pulls from <code>a</code>, but in the latter snippet, <code>a</code> pushes to
<code>b</code>. In other words, compare <code>b = a.map(..)</code> to <code>b.onValue(v)</code>.</p>
<p>In the latter imperative snippet, it's not clear (readability wise) from the
consumer's perspective where the <code>v</code> values are coming from. Moreover, the
imperative hard coding of <code>b.onValue(..)</code> in the middle of producer <code>a</code>'s logic
is a violation of separation-of-concerns. That can make it harder to reason
about producer and consumer independently.</p>
<p>By contrast, in the former snippet, <code>b = a.map(..)</code> declares that <code>b</code>'s values
are sourced from <code>a</code>, and treats <code>a</code> as an abstract event stream data source
that we don't have to concern ourselves with at that moment. We <em>declare</em> that
any value that comes from <code>a</code> into <code>b</code> will go through the <code>map(..)</code> operation
as specified.</p>
<h3><a class="header" href="#more-than-map" id="more-than-map">More Than Map</a></h3>
<p>For convenience, we've illustrated this notion of pairing <code>a</code> and <code>b</code> together
over time via a one-to-one <code>map(..)</code>ing. But many of our other FP operations
could be modeled over time as well.</p>
<p>Consider:</p>
<pre><code class="language-js">var b = a.filter(function isOdd(v) {
  return v % 2 == 1;
});

b.listen(function onlyOdds(v) {
  console.log(&quot;Odd:&quot;, v);
});
</code></pre>
<p>Here, a value from <code>a</code> only comes into <code>b</code> if it passes the <code>isOdd(..)</code>
predicate.</p>
<p>Even <code>reduce(..)</code> can be modeled over time:</p>
<pre><code class="language-js">var b = a.reduce(function sum(total, v) {
  return total + v;
});

b.listen(function runningTotal(v) {
  console.log(&quot;New current total:&quot;, v);
});
</code></pre>
<p>Since we don't specify an <code>initialValue</code> to the <code>reduce(..)</code> call, neither the
<code>sum(..)</code> reducer nor the <code>runningTotal(..)</code> event callback will be invoked
until at least two values have come through from <code>a</code>.</p>
<p>This snippet implies that the reduction has a <em>memory</em> of sorts, in that each
time a future value comes in, the <code>sum(..)</code> reducer will be invoked with
whatever the previous <code>total</code> was as well as the new next value <code>v</code>.</p>
<p>Other FP operations extended over time could even involve an internal buffer,
like for example <code>unique(..)</code> keeping track of every value it's seen so far.</p>
<h3><a class="header" href="#observables" id="observables">Observables</a></h3>
<p>Hopefully by now you can see the importance of a reactive, evented, array-like
data structure like the fictional <code>LazyArray</code> we've conjured. The good news is,
this kind of data structure already exists, and it's called an Observable.</p>
<p><strong>Note:</strong> Just to set some expectation: the following discussion is only a brief
intro to the world of Observables. This is a far more in-depth topic than we
have space to fully explore. But if you've understood Functional-Light
Programming in this text, and now grasped how asynchronous-time can be modeled
via FP principles, Observables should follow very naturally for your continued
learning.</p>
<p>Observables have been implemented by a variety of userland libraries, most
notably <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a> and
<a href="https://github.com/cujojs/most">Most</a>. At the time of this writing, there's an
in-progress proposal to add Observables natively to JS, just like Promises were
added in ES6. For the sake of demonstration, we'll use RxJS-flavored Observables
for these next examples.</p>
<p>Here's our earlier reactive example, expressed with observables instead of
<code>LazyArray</code>:</p>
<pre><code class="language-js">// producer:

var a = new Rx.Subject();

setInterval(function everySecond() {
  a.next(Math.random());
}, 1000);

// **************************
// consumer:

var b = a.map(function double(v) {
  return v * 2;
});

b.subscribe(function onValue(v) {
  console.log(v);
});
</code></pre>
<p>In the RxJS universe, an Observer subscribes to an Observable. If you combine
the functionality of an Observer and an Observable, you get a Subject. So, to
keep our snippet simpler, we construct <code>a</code> as a Subject, so that we can call
<code>next(..)</code> on it to push values (events) into its stream.</p>
<p>If we want to keep the Observer and Observable separate:</p>
<pre><code class="language-js">// producer:

var a = Rx.Observable.create(function onObserve(observer) {
  setInterval(function everySecond() {
    observer.next(Math.random());
  }, 1000);
});
</code></pre>
<p>In this snippet, <code>a</code> is the observable, and unsurprisingly, the separate
observer is called <code>observer</code>; it's able to &quot;observe&quot; some events (like our
<code>setInterval(..)</code> loop); we use its <code>next(..)</code> method to feed events into the
<code>a</code> observable stream.</p>
<p>In addition to <code>map(..)</code>, RxJS defines well over a hundred operators that are
invoked lazily as each new value comes in. Just like with arrays, each operator
on an Observable returns a new Observable, meaning they are chainable. If an
invocation of operator function determines a value should be passed along from
the input Observable, it will be fired on the output Observable; otherwise it's
discarded.</p>
<p>Example of a declarative observable chain:</p>
<pre><code class="language-js">var b = a
  .filter(v =&gt; v % 2 == 1) // only odd numbers
  .distinctUntilChanged() // only consecutive-distinct
  .throttle(100) // slow it down a bit
  .map((v = v * 2)); // double them

b.subscribe(function onValue(v) {
  console.log(&quot;Next:&quot;, v);
});
</code></pre>
<p><strong>Note:</strong> It's not necessary to assign the observable to <code>b</code> and then call
<code>b.subscribe(..)</code> separately from the chain; that's done here to reinforce that
each operator returns a new observable from the previous one. In many coding
examples you'll find, the <code>subscribe(..)</code> call is just the final method in the
chain. Because <code>subscribe(..)</code> is technically mutating the internal state of the
observable, FPers generally prefer these two steps separated, to mark the side
effect more obviously.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>This book has detailed a wide variety of FP operations that take a single value
(or an immediate list of values) and transform them into another value/values.</p>
<p>For operations that will be proceed over time, all of these foundational FP
principles can be applied time-independently. Exactly like promises model single
future values, we can model eager lists of values instead as lazy Observable
(event) streams of values that may come in one-at-a-time.</p>
<p>A <code>map(..)</code> on an array runs its mapping function once for each value currently
in the array, putting all the mapped values in the outcome array. A <code>map(..)</code> on
an Observable runs its mapping function once for each value, whenever it comes
in, and pushes all the mapped values to the output Observable.</p>
<p>In other words, if an array is an eager data structure for FP operations, an
Observable is its lazy-over-time counterpart.</p>
<p><strong>Note:</strong> For a different twist on asynchronous FP, check out a library called
<a href="apC.html"><strong>fasy</strong>, which is discussed in Appendix C</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_9.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_11.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a rel="prev" href="chapter_9.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a rel="next" href="chapter_11.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
