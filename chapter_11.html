<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 11 - Functional-Light JavaScript</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="expanded "><a href="chapter_11.html" class="active"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Functional-Light JavaScript</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-11-putting-it-all-together" id="chapter-11-putting-it-all-together">Chapter 11: Putting It All Together</a></h1>
<p>By now, you have everything you need to understand Functional-Light JavaScript.
There's no more new concepts to introduce.</p>
<p>In this final chapter, our main goal is conceptual cohesiveness. We'll look at
code that brings many of the major themes from this book together -- application
of what we've learned. Above all, this example code is intended to illustrate
the &quot;Functional Light&quot; approach to JavaScript -- that is, balance and pragmatism
over dogma.</p>
<p>You'll want to practice these techniques yourself, extensively. Digesting this
chapter is critical to helping you apply FP principles to your real-world code.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>Let's build a simple stock ticker widget.</p>
<p><strong>Note:</strong> For reference, the entirety of the code for this example resides in
the <code>ch11-code/</code> sub-directory -- see the
<a href="https://github.com/getify/Functional-Light-JS">GitHub repository for this book</a>.
Also, selected FP helpers we've discussed throughout this book that we need for
this example are included in <code>ch11-code/fp-helpers.js</code>. In this chapter we will
only focus on the relevant parts of the code for our discussion.</p>
<p>First, let's talk about the markup for this widget, so we have somewhere to
display our information. We start out with an empty <code>&lt;ul ..&gt;</code> element in our
<code>ch11-code/index.html</code> file, but while running, the DOM will be populated to
look like:</p>
<pre><code class="language-html">&lt;ul id=&quot;stock-ticker&quot;&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;AAPL&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;AAPL&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$121.95&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;+0.01&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;MSFT&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;MSFT&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$65.78&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;+1.51&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;GOOG&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;GOOG&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$821.31&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;-8.84&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Before we go any further, let me remind you: interacting with the DOM is I/O,
and that means side effects. We can't eliminate these side effects, but we can
limit and control them. We'll want to be really intentional about minimizing the
surface area of our application that deals with the DOM. We learned all about
these techniques in <a href="chapter_5.html">Chapter 5</a>.</p>
<p>Summarizing our widget's functionality: the code will add the <code>&lt;li ..&gt;</code> elements
each time a new-stock event is &quot;received&quot;, and will update the price and change
as stock-update events come through.</p>
<p>In the Chapter 11 example code, in <code>ch11-code/mock-server.js</code>, we set up some
timers to push out randomly generated fake stock data to a simple event emitter,
to simulate as if we were getting messages of stock information from a server.
We expose a <code>connectToServer()</code> function which pretends to do so, but really
just returns the faked event emitter instance.</p>
<p><strong>Note:</strong> This file is all fake/mock behavior, so I didn't spend much effort
trying to make it very FP-adherent. I wouldn't suggest spending too much time
concerned with the code in this file. If you wrote a real server -- a very
interesting extra credit exercise for the ambitious reader! -- you'd clearly
want to give that code the FP attention it deserves.</p>
<p>In <code>ch11-code/stock-ticker-events.js</code>, we create some observables (via RxJS)
hooked up to an event emitter object. We call the <code>connectToServer()</code> to get
this event emitter, then listen to the event names <code>&quot;stock&quot;</code> (adding a new stock
to our ticker) and <code>&quot;stock-update&quot;</code> (updating the stock's listed price and
change amount). Finally, we define transformations on the incoming data of these
observables, formatting the data as needed.</p>
<p>In <code>ch11-code/stock-ticker.js</code>, we define our UI (DOM side effect) behavior as
methods on the <code>stockTickerUI</code> object. We also define a variety of helpers,
including <code>getElemAttr(..)</code>, <code>stripPrefix(..)</code>, and others. Finally, we
<code>subscribe(..)</code> to the two observables that provide us formatted data to render
to the DOM.</p>
<h2><a class="header" href="#stock-events" id="stock-events">Stock Events</a></h2>
<p>Let's look at the code in <code>ch11-code/stock-ticker-events.js</code>. We'll start with
some basic helpers:</p>
<pre><code class="language-js">function addStockName(stock) {
  return setProp(&quot;name&quot;, stock, stock.id);
}
function formatSign(val) {
  if (Number(val) &gt; 0) {
    return `+${val}`;
  }
  return val;
}
function formatCurrency(val) {
  return `$${val}`;
}
</code></pre>
<p>These pure functions should be pretty straightforward to interpret. Recall
<a href="chapter_4.html"><code>setProp(..)</code> from Chapter 4</a> actually
clones the object before setting the new property. That exercises the principle
we saw in Chapter 6: avoiding side effects by treating values as immutable even
if they're not.</p>
<p><code>addStockName(..)</code> is used to add a <code>name</code> property to a stock message object
that's equal to its <code>id</code>. The <code>name</code> value is later used as the visible stock
name in the widget.</p>
<p>When a stock message is received from the &quot;server&quot;, it'll look like:</p>
<pre><code class="language-js">{ id: &quot;AAPL&quot;, price: 121.7, change: 0.01 }
</code></pre>
<p>Prior to display in the DOM, the <code>price</code> needs to be formatted with
<code>formatCurrency(..)</code> (to look like <code>&quot;$121.70&quot;</code>), and the <code>change</code> needs to be
formatted with <code>formatChange(..)</code> (to look like <code>&quot;+0.01&quot;</code>). But we don't want to
mutate the message object, so we need a helper that formats both the numbers and
gives us a new stock object:</p>
<pre><code class="language-js">function formatStockNumbers(stock) {
  var stockDataUpdates = [
    [&quot;price&quot;, formatPrice(stock.price)],
    [&quot;change&quot;, formatChange(stock.change)]
  ];

  return reduce(function formatter(stock, [propName, val]) {
    return setProp(propName, stock, val);
  })(stock)(stockDataUpdates);
}
</code></pre>
<p>We create the <code>stockDataUpdates</code> array to hold tuples (just arrays) of the
property name and the new formatted value, for <code>price</code> and <code>change</code>
respectively. We <code>reduce(..)</code> (see <a href="chapter_9.html">Chapter 9</a>) over that
array, with the <code>stock</code> object as the <code>initialValue</code>. We destructure the tuple
into <code>propName</code> and <code>val</code>, and then return the <code>setProp(..)</code> call, which returns
a new cloned object with the property having been set.</p>
<p>Now let's define some more helpers:</p>
<pre><code class="language-js">var formatDecimal = unboundMethod(&quot;toFixed&quot;)(2);
var formatPrice = pipe(formatDecimal, formatCurrency);
var formatChange = pipe(formatDecimal, formatSign);
var processNewStock = pipe(addStockName, formatStockNumbers);
</code></pre>
<p>The <code>formatDecimal(..)</code> function takes a number (like <code>2.1</code>) and calls its
<code>toFixed( 2 )</code> method call. We use
<a href="chapter_9.html">Chapter 9's <code>unboundMethod(..)</code></a>
to create a standalone late-bound method.</p>
<p><code>formatPrice(..)</code>, <code>formatChange(..)</code>, and <code>processNewStock(..)</code> are all
compositions with <code>pipe(..)</code>, each composing a couple of operations
left-to-right (see <a href="chapter_4.html">Chapter 4</a>).</p>
<p>For creating our observables (see <a href="chapter_10.html">Chapter 10</a>) from
our event emitter, we're going to want a helper that's a curried (see
<a href="chapter_3.html">Chapter 3</a>) standalone of RxJS's
<code>Rx.Observable.fromEvent(..)</code>:</p>
<pre><code class="language-js">var makeObservableFromEvent = curry(Rx.Observable.fromEvent, 2)(server);
</code></pre>
<p>This function is specified to listen to the <code>server</code> (event emitter), and is
just waiting for an event name string to produce its observable. We have all the
pieces in place now to create observers for our two events, and to map-transform
those observers to format the incoming data:</p>
<pre><code class="language-js">var observableMapperFns = [processNewStock, formatStockNumbers];

var stockEventNames = [&quot;stock&quot;, &quot;stock-update&quot;];

var [newStocks, stockUpdates] = pipe(
  map(makeObservableFromEvent),
  curry(zip)(observableMapperFns),
  map(spreadArgs(mapObservable))
)(stockEventNames);
</code></pre>
<p>We start with <code>stockEventNames</code>, an array of event names
(<code>[&quot;stock&quot;,&quot;stock-update&quot;]</code>), then <code>map(..)</code> (see
<a href="chapter_9.html">Chapter 9</a>) that to a list of two observables, and <code>zip(..)</code>
(see <a href="chapter_9.html">Chapter 9</a>) that to a list of observable-mapper
functions, producing a list of tuples like <code>[ observable, mapperFn ]</code>. Finally,
we <code>map(..)</code> those tuples with <code>mapObservable(..)</code>, spreading out each tuple as
individual arguments using <code>spreadArgs(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>).</p>
<p>The final result is a list of two mapped observables, which we array-destructure
into the assignments for <code>newStocks</code> and <code>stockUpdates</code>, respectively.</p>
<p>That's it; that's our FP-Light approach to setting up our stock ticker event
observables! We'll subscribe to these two observables in
<code>ch11-code/stock-ticker.js</code>.</p>
<p>Take a step back and reflect on our usage of FP principles here. Did it make
sense? Can you see how we applied various concepts covered across the previous
chapters from this book? Can you think of other ways to accomplish these tasks?</p>
<p>More importantly, how would you have done it imperatively, and how do you think
those two approaches would have compared, broadly? Try that exercise. Write the
equivalent using well-established imperative approaches. If you're like me, the
imperative form will still feel more natural.</p>
<p>What you need to <em>get</em> before moving on is that you can <em>also</em> understand and
reason about the FP-style we just presented. Think about the shape (the inputs
and output) of each function and piece. Do you see how they fit together?</p>
<p>Keep practicing until this stuff clicks for you.</p>
<h2><a class="header" href="#stock-ticker-ui" id="stock-ticker-ui">Stock Ticker UI</a></h2>
<p>If you felt pretty comfortable with the FP of the last section, you're ready to
dig into <code>ch11-code/stock-ticker.js</code>. It's considerably more involved, so we'll
take our time to look at each piece in its entirety.</p>
<p>Let's start by defining some helpers that will assist in our DOM tasks:</p>
<pre><code class="language-js">function isTextNode(node) {
  return node &amp;&amp; node.nodeType == 3;
}
function getElemAttr(prop, elem) {
  return elem.getAttribute(prop);
}
function setElemAttr(elem, prop, val) {
  // !!SIDE EFFECTS!!
  return elem.setAttribute(prop, val);
}
function matchingStockId(id, node) {
  return getStockId(node) == id;
}
function isStockInfoChildElem(elem) {
  return /\bstock-/i.test(getClassName(elem));
}
function appendDOMChild(parentNode, childNode) {
  // !!SIDE EFFECTS!!
  parentNode.appendChild(childNode);
  return parentNode;
}
function setDOMContent(elem, html) {
  // !!SIDE EFFECTS!!
  elem.innerHTML = html;
  return elem;
}

var createElement = document.createElement.bind(document);

var getElemAttrByName = curry(getElemAttr, 2);
var getStockId = getElemAttrByName(&quot;data-stock-id&quot;);
var getClassName = getElemAttrByName(&quot;class&quot;);
var isMatchingStock = curry(matchingStockId, 2);
</code></pre>
<p>These should be mostly self-explanatory.</p>
<p>Notice that I called out the side effects of mutating a DOM element's state. We
can't as easily clone a DOM object and replace it, so we settle here for a side
effect of changing an existing one. At least if we have a bug in our DOM
rendering, we can easily search for those code comments to narrow in on likely
suspects.</p>
<p>Here are some other miscellaneous helpers:</p>
<pre><code class="language-js">function stripPrefix(prefixRegex, val) {
  return val.replace(prefixRegex, &quot;&quot;);
}

function listify(listOrItem) {
  if (!Array.isArray(listOrItem)) {
    return [listOrItem];
  }
  return listOrItem;
}
</code></pre>
<p>Let's define a helper to get the child nodes of a DOM element:</p>
<pre><code class="language-js">var getDOMChildren = pipe(
  listify,
  flatMap(pipe(curry(prop)(&quot;childNodes&quot;), Array.from))
);
</code></pre>
<p>First, we use <code>listify(..)</code> to ensure we have a list of elements (even if it's
only a single item in length). Recall
<a href="chapter_9.html"><code>flatMap(..)</code> from Chapter 9</a>, which maps a
list and then flattens a list-of-lists into a shallower list.</p>
<p>Our mapping function here maps from an element to its <code>childNodes</code> list, which
we make into a real array (instead of a live NodeList) with <code>Array.from(..)</code>.
These two functions are composed (via <code>pipe(..)</code>) into a single mapper function,
which is fusion (see <a href="chapter_9.html">Chapter 9</a>).</p>
<p>Now, let's use this <code>getDOMChildren(..)</code> helper to define utilities for
retrieving specific DOM elements in our widget:</p>
<pre><code class="language-js">function getStockElem(tickerElem, stockId) {
  return pipe(
    getDOMChildren,
    filterOut(isTextNode),
    filterIn(isMatchingStock(stockId))
  )(tickerElem);
}
function getStockInfoChildElems(stockElem) {
  return pipe(
    getDOMChildren,
    filterOut(isTextNode),
    filterIn(isStockInfoChildElem)
  )(stockElem);
}
</code></pre>
<p><code>getStockElem(..)</code> starts with the <code>tickerElem</code> DOM element for our widget,
retrieves its child elements, then filters to make sure we have the element
matching the specified stock identifier. <code>getStockInfoChildElems(..)</code> does
almost the same thing, except it starts with a stock element, and narrows with
different filters.</p>
<p>Both utilities filter out text nodes (since they don't work the same as real DOM
nodes), and both utilities return an array of DOM elements, even if it's just a
single element.</p>
<h3><a class="header" href="#main-api" id="main-api">Main API</a></h3>
<p>We'll use a <code>stockTickerUI</code> object to organize our three main UI manipulation
methods, like this:</p>
<pre><code class="language-js">var stockTickerUI = {
  updateStockElems(stockInfoChildElemList, data) {
    // ..
  },

  updateStock(tickerElem, data) {
    // ..
  },

  addStock(tickerElem, data) {
    // ..
  }
};
</code></pre>
<p>Let's first examine <code>updateStock(..)</code>, as it's the simplest of the three:</p>
<pre><code class="language-js">updateStock(tickerElem,data) {
    var getStockElemFromId = curry( getStockElem )( tickerElem );
    var stockInfoChildElemList = pipe(
        getStockElemFromId,
        getStockInfoChildElems
    )
    ( data.id );

    return stockTickerUI.updateStockElems(
        stockInfoChildElemList,
        data
    );
},
</code></pre>
<p>Currying the earlier helper <code>getStockElem(..)</code> with <code>tickerElem</code> gives us
<code>getStockElemFromId(..)</code>, which will receive <code>data.id</code>.</p>
<p>Via <code>pipe(..)</code>, the return value <code>getStockElemFromId(data.id)</code> is an <code>&lt;li&gt;</code>
element (actually, a list containing only that element), which is passed to
<code>getStockInfoChildElems(..)</code>.</p>
<p>The result is a list (<code>stockInfoChildElemList</code>) with the three child <code>&lt;span&gt;</code>
elements for the stock display info. We pass that list and the stock's <code>data</code>
message object along to <code>stockTickerUI.updateStockElems(..)</code> for actually
updating those three <code>&lt;span&gt;</code> elements with the new data.</p>
<p>Now let's look at how <code>stockTickerUI.updateStockElems(..)</code> is defined:</p>
<pre><code class="language-js">updateStockElems(stockInfoChildElemList,data) {
    var getDataVal = curry( reverseArgs( prop ), 2 )( data );
    var extractInfoChildElemVal = pipe(
        getClassName,
        curry( stripPrefix )( /\bstock-/i ),
        getDataVal
    );
    var orderedDataVals =
        map( extractInfoChildElemVal )( stockInfoChildElemList );
    var elemsValsTuples =
        filterOut( function updateValueMissing([infoChildElem,val]){
            return val === undefined;
        } )
        ( zip( stockInfoChildElemList, orderedDataVals ) );

    // !!SIDE EFFECTS!!
    compose( each, spreadArgs )
    ( setDOMContent )
    ( elemsValsTuples );
},
</code></pre>
<p>That's a fair bit to take in, I know. But we'll break it down statement by
statement.</p>
<p><code>getDataVal(..)</code> is bound to the <code>data</code> message object, having been curried
after argument-reversing, so it's now waiting for a property name to extract
from <code>data</code>.</p>
<p>Next, let's look at how <code>extractInfoChildElemVal(..)</code> is defined:</p>
<pre><code class="language-js">var extractInfoChildElemVal = pipe(
  getClassName,
  curry(stripPrefix)(/\bstock-/i),
  getDataVal
);
</code></pre>
<p>This function takes a DOM element, retrieves it DOM class, strips the <code>&quot;stock-&quot;</code>
prefix from that value, then uses that resulting value (<code>&quot;name&quot;</code>, <code>&quot;price&quot;</code>, or
<code>&quot;change&quot;</code>) as a property name to extract from the <code>data</code> object via
<code>getDataVal(..)</code>.</p>
<p>This may seem like a convoluted way to retrieve values from the <code>data</code> object.
But the purpose is to be able to extract those values from <code>data</code> in the same
order as the <code>&lt;span&gt;</code> elements appear in the <code>stockInfoChildElemList</code> list; we
accomplish this by using <code>extractInfoChildElem(..)</code> as the mapping function over
that list of DOM elements, calling the resulting list <code>orderedDataVals</code>.</p>
<p>Next, we're going to zip the list of <code>&lt;span&gt;</code>s back with the ordered data
values, producing tuples where the DOM element and the value to update it with
are paired up:</p>
<pre><code class="language-js">zip(stockInfoChildElemList, orderedDataVals);
</code></pre>
<p>An interesting wrinkle that wasn't at all obvious up to this point is that
because of how we defined the observable's transforms, new-stock message objects
will have a <code>name</code> property in <code>data</code> to match up with the
<code>&lt;span class=&quot;stock-name&quot;&gt;</code> element, but <code>name</code> will be absent on stock-update
message objects.</p>
<p>If the data message object doesn't have a property, we shouldn't update that
corresponding DOM element. So, we need to <code>filterOut(..)</code> any tuples where the
second position (the data value, in this case) is <code>undefined</code>:</p>
<pre><code class="language-js">var elemsValsTuples = filterOut(function updateValueMissing([
  infoChildElem,
  val
]) {
  return val === undefined;
})(zip(stockInfoChildElemList, orderedDataVals));
</code></pre>
<p>The result after this filtering is a list of tuples (like <code>[ &lt;span&gt;, &quot;..&quot; ]</code>)
ready for DOM content updating, which we assign to <code>elemsValsTuples</code>.</p>
<p><strong>Note:</strong> Since the <code>updateValueMissing(..)</code> predicate is specified inline here,
we're in control of its signature. Instead of using <code>spreadArgs(..)</code> to adapt it
to spread out a single array argument as two individual named parameters, we use
parameter array-destructuring in the function declaration
(<code>function updateValueMissing([infoChildElem,val]){ ..</code>); see
<a href="chapter_2.html">Chapter 2</a> for more information.</p>
<p>Finally, we need to update the DOM content of our <code>&lt;span&gt;</code> elements:</p>
<pre><code class="language-js">// !!SIDE EFFECTS!!
compose(each, spreadArgs)(setDOMContent)(elemsValsTuples);
</code></pre>
<p>We iterate this <code>elemsValsTuples</code> list with <code>each(..)</code> (see
<a href="chapter_9.html"><code>forEach(..)</code> discussion in Chapter 9</a>).</p>
<p>Instead of using <code>pipe(..)</code> as elsewhere, this composition uses <code>compose(..)</code>
(see <a href="chapter_4.html">Chapter 4</a>) to pass
<code>setDomContent(..)</code> into <code>spreadArgs(..)</code>, and then that is passed as the
iterator-function to <code>each(..)</code>. Each tuple is spread out as the arguments to
<code>setDOMContent(..)</code>, which then updates the DOM element accordingly.</p>
<p>That's two of the main UI methods down, one to go: <code>addStock(..)</code>. Let's define
it in its entirety, then we'll examine it step by step as before:</p>
<pre><code class="language-js">addStock(tickerElem,data) {
    var [stockElem, ...infoChildElems] = map(
        createElement
    )
    ( [ &quot;li&quot;, &quot;span&quot;, &quot;span&quot;, &quot;span&quot; ] );
    var attrValTuples = [
        [ [&quot;class&quot;,&quot;stock&quot;], [&quot;data-stock-id&quot;,data.id] ],
        [ [&quot;class&quot;,&quot;stock-name&quot;] ],
        [ [&quot;class&quot;,&quot;stock-price&quot;] ],
        [ [&quot;class&quot;,&quot;stock-change&quot;] ]
    ];
    var elemsAttrsTuples =
        zip( [stockElem, ...infoChildElems], attrValTuples );

    // !!SIDE EFFECTS!!
    each( function setElemAttrs([elem,attrValTupleList]){
        each(
            spreadArgs( partial( setElemAttr, elem ) )
        )
        ( attrValTupleList );
    } )
    ( elemsAttrsTuples );

    // !!SIDE EFFECTS!!
    stockTickerUI.updateStockElems( infoChildElems, data );
    reduce( appendDOMChild )( stockElem )( infoChildElems );
    appendDOMChild( tickerElem, stockElem );
}
</code></pre>
<p>This UI method needs to create the bare DOM structure for a new stock element,
and then use <code>stockTickerUI.updateStockElems(..)</code> to update its content. First:</p>
<pre><code class="language-js">var [stockElem, ...infoChildElems] = map(createElement)([
  &quot;li&quot;,
  &quot;span&quot;,
  &quot;span&quot;,
  &quot;span&quot;
]);
</code></pre>
<p>We create the parent <code>&lt;li&gt;</code> and the three children <code>&lt;span&gt;</code> elements, assigning
them respectively to <code>stockElem</code> and the <code>infoChildElems</code> list.</p>
<p>To initialize these elements with the appropriate DOM attributes, we create a
list of lists-of-tuples. Each item in the main list corresponds to the four DOM
elements, in order. Each sub-list contains tuples that represent attribute-value
pairs to be set on each corresponding DOM element, respectively:</p>
<pre><code class="language-js">var attrValTuples = [
  [
    [&quot;class&quot;, &quot;stock&quot;],
    [&quot;data-stock-id&quot;, data.id]
  ],
  [[&quot;class&quot;, &quot;stock-name&quot;]],
  [[&quot;class&quot;, &quot;stock-price&quot;]],
  [[&quot;class&quot;, &quot;stock-change&quot;]]
];
</code></pre>
<p>We now want to <code>zip(..)</code> a list of the four DOM elements with this
<code>attrValTuples</code> list:</p>
<pre><code class="language-js">var elemsAttrsTuples = zip([stockElem, ...infoChildElems], attrValTuples);
</code></pre>
<p>The structure of this list would now look like:</p>
<pre><code class="language-txt">[
    [ &lt;li&gt;, [ [&quot;class&quot;,&quot;stock&quot;], [&quot;data-stock-id&quot;,data.id] ] ],
    [ &lt;span&gt;, [ [&quot;class&quot;,&quot;stock-name&quot;] ] ],
    ..
]
</code></pre>
<p>If we wanted to imperatively process this kind of data structure to assign the
attribute-value tuples into each DOM element, we'd probably use nested
<code>for</code>-loops. Our FP approach will be similar, but with nested <code>each(..)</code>
iterations:</p>
<pre><code class="language-js">// !!SIDE EFFECTS!!
each(function setElemAttrs([elem, attrValTupleList]) {
  each(spreadArgs(partial(setElemAttr, elem)))(attrValTupleList);
})(elemsAttrsTuples);
</code></pre>
<p>The outer <code>each(..)</code> iterates the list of tuples, with each <code>elem</code> and its
associated <code>attrValTupleList</code> spread out as named parameters to
<code>setElemAttrs(..)</code> via parameter array-destructuring as explained earlier.</p>
<p>Inside this outer iteration &quot;loop&quot;, the sub-list of attribute-value tuples is
iterated with an inner <code>each(..)</code>. The inner iterator-function is an
arguments-spread (of each attribute-value tuple) for the partial-application of
<code>setElemAttr(..)</code> with <code>elem</code> as its first argument.</p>
<p>At this point, we have a list of <code>&lt;span&gt;</code> elements, each filled out with
attributes, but no <code>innerHTML</code> content. We set the <code>data</code> in the <code>&lt;span&gt;</code>
elements with <code>stockTickerUI.updateStockElems(..)</code>, the same as for a
stock-update event.</p>
<p>Now, we need to append these <code>&lt;span&gt;</code>s to the parent <code>&lt;li&gt;</code>, and we do that with
a <code>reduce(..)</code> (see <a href="chapter_9.html">Chapter 9</a>):</p>
<pre><code class="language-js">reduce(appendDOMChild)(stockElem)(infoChildElems);
</code></pre>
<p>Finally, a plain ol' DOM mutation side effect to append the new stock element to
the widget's DOM:</p>
<pre><code class="language-js">appendDOMChild(tickerElem, stockElem);
</code></pre>
<p>Phew! Did you follow all that? I recommend re-reading that discussion a few
times, and practicing with the code, before you move on.</p>
<h3><a class="header" href="#subscribing-to-observables" id="subscribing-to-observables">Subscribing to Observables</a></h3>
<p>Our last major task is to subscribe to the observables defined in
<code>ch11-code/stock-ticker-events.js</code>, attaching these subscriptions to the
appropriate main UI methods (<code>addStock(..)</code> and <code>updateStock(..)</code>).</p>
<p>First, we notice that those methods each expect <code>tickerElem</code> as first parameter.
Let's make a list (<code>stockTickerUIMethodsWithDOMContext</code>) that encapsulates the
ticker widget's DOM element with each of these two methods, via partial
application (aka, <a href="chapter_2.html">closure; see Chapter 2</a>):</p>
<pre><code class="language-js">var ticker = document.getElementById(&quot;stock-ticker&quot;);

var stockTickerUIMethodsWithDOMContext = map(
  pipe(partialRight, unary)(partial, ticker)
)([stockTickerUI.addStock, stockTickerUI.updateStock]);
</code></pre>
<p>First, we use <code>partialRight(..)</code> (right-partial application) on the
<code>partial(..)</code> utility, presetting its right-most argument to be <code>ticker</code>. Then
we pass this right-partially-applied <code>partial(..)</code> function through <code>unary(..)</code>
to protect it from receiving undesired extra arguments from <code>map(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>), via <code>pipe(..)</code>. The result is
a mapper function which is expecting a function to partially-apply (with one
argument: <code>ticker</code>). We use that mapper function to <code>map(..)</code> the
<code>stockTickerUI.addStock(..)</code> and <code>stockTickerUI.updateStock(..)</code> functions,
respectively.</p>
<p>The result of <code>map(..)</code> is the array <code>stockTickerUIMethodsWithDOMContext</code>, which
holds the two partially applied functions; these two functions are now suitable
as observable-subscription handlers.</p>
<p>Though we're using closure to preserve the <code>ticker</code> state with these two
functions, in <a href="chapter_7.html">Chapter 7</a> we saw that we could have &quot;kept&quot; this
<code>ticker</code> value as a property on an object, perhaps via <code>this</code>-binding each
function to <code>stockTickerUI</code>. Because <code>this</code> is an implicit input (see
<a href="chapter_2.html">Chapter 2</a>) and that's generally not as preferable, I
chose the closure form over the object form.</p>
<p>To subscribe to the observables, let's make an unbound-method helper:</p>
<pre><code class="language-js">var subscribeToObservable = pipe(unboundMethod, uncurry)(&quot;subscribe&quot;);
</code></pre>
<p><code>unboundMethod(&quot;subscribe&quot;)</code> is curried so we <code>uncurry(..)</code> it (see
<a href="chapter_3.html">Chapter 3</a>).</p>
<p>Now, we just need a list of the observables, so we can <code>zip(..)</code> that with the
list of DOM-bound UI methods; the resulting tuples will then include both the
observable and the listener function to subscribe to it. We process each tuple
with <code>each(..)</code> and use <code>spreadArgs(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>) to spread the tuple's
contents out as the two arguments to <code>subscribeToObservable(..)</code>:</p>
<pre><code class="language-js">var stockTickerObservables = [newStocks, stockUpdates];

// !!SIDE EFFECTS!!
each(spreadArgs(subscribeToObservable))(
  zip(stockTickerUIMethodsWithDOMContext, stockTickerObservables)
);
</code></pre>
<p>We're technically mutating the state of those observables to subscribe to them,
and moreover, we're using <code>each(..)</code> -- pretty much always associated with side
effects! -- so we call that out with our code comment.</p>
<p>That's it! Spend the same time reviewing and comparing this code to its
imperative alternatives as we did with the stock ticker events discussion
earlier. Really, take your time. I know it's been a lot to read, but your whole
journey through this book comes down to being able to digest and understand this
kind of code.</p>
<p>How do you feel now about using FP in a balanced way in your JavaScript? Keep
practicing just like we did here!</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>The example code we discussed in this chapter should be viewed in its entirety,
not just in the broken-out snippets as presented in this chapter. Stop right now
and go read through the full files. Make sure you understand them in full
context.</p>
<p>This example code is not meant to be prescriptive of exactly how you should
write your code. It's meant to be more descriptive of how to think about and
begin approaching such tasks with FP-Light techniques. It's meant to draw as
many correlations between the different concepts of this book as possible. It's
meant to explore FP in the context of more &quot;real&quot; code than we typically afford
for a single snippet.</p>
<p>I am quite sure that as I learn FP better on my own journey, I will continue to
improve how I would write this example code. What you see now is just a snapshot
on my curve. I hope it will just be such for you, as well.</p>
<p>As we draw the main text of this book to a close, I want to remind you of that
readability curve that I <a href="chapter_1.html">shared back in Chapter 1</a>:</p>
<p align="center">
    <img alt="figure" src="images/fig17.png" width="50%">
</p>
<p>It's so important that you internalize the truth of that graph and set realistic
expectations for yourself on this journey to learn and apply FP principles to
your JavaScript. You've made it this far, and that's quite an accomplishment.</p>
<p>But don't stop when you dip toward that trough of despair and disenchantment.
What's waiting on the other side is a way of thinking about and communicating
with your code that's more readable, understandable, verifiable, and ultimately,
more reliable.</p>
<p>I can't think of any more noble goal for us as developers to strive toward.
Thanks for sharing in my journey to learn FP principles in JavaScript. I hope
your experience is as rich and hopeful as mine!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_10.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="apA.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="chapter_10.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="apA.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
