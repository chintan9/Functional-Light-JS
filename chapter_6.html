<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 6 - Functional-Light JavaScript</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="expanded "><a href="chapter_6.html" class="active"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Functional-Light JavaScript</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-6-value-immutability" id="chapter-6-value-immutability">Chapter 6: Value Immutability</a></h1>
<p>In <a href="chapter_5.html">Chapter 5</a>, we talked about the importance of reducing side
causes/effects: the ways that your application's state can change unexpectedly
and cause surprises (bugs). The fewer places we have with such landmines, the
more confidence we have over our code, and the more readable it will be. Our
topic for this chapter follows directly from that same effort.</p>
<p>If programming-style idempotence is about defining a value change operation so
that it can only affect state once, we now turn our attention to the goal of
reducing the number of change occurrences from one to zero.</p>
<p>Let's now explore value immutability, the notion that in our programs we use
only values that cannot be changed.</p>
<h2><a class="header" href="#primitive-immutability" id="primitive-immutability">Primitive Immutability</a></h2>
<p>Values of the primitive types (<code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, and
<code>undefined</code>) are already immutable; there's nothing you can do to change them:</p>
<pre><code class="language-js">// invalid, and also makes no sense
2 = 2.5;
</code></pre>
<p>However, JS does have a peculiar behavior which seems like it allows mutating
such primitive type values: &quot;boxing&quot;. When you access a property on certain
primitive type values -- specifically <code>number</code>, <code>string</code>, and <code>boolean</code> -- under
the covers JS automatically wraps (aka &quot;boxes&quot;) the value in its object
counterpart (<code>Number</code>, <code>String</code>, and <code>Boolean</code>, respectively).</p>
<p>Consider:</p>
<pre><code class="language-js">var x = 2;

x.length = 4;

x; // 2
x.length; // undefined
</code></pre>
<p>Numbers do not normally have a <code>length</code> property available, so the
<code>x.length = 4</code> setting is trying to add a new property, and it silently fails
(or is ignored/discarded, depending on your point-of-view); <code>x</code> continues to
hold the simple primitive <code>2</code> number.</p>
<p>But the fact that JS allows the <code>x.length = 4</code> statement to run at all can seem
troubling, if for no other reason than its potential confusion to readers. The
good news is, if you use strict mode (<code>&quot;use strict&quot;;</code>), such a statement will
throw an error.</p>
<p>What if you try to mutate the explicitly boxed object representation of such a
value?</p>
<pre><code class="language-js">var x = new Number(2);

// works fine
x.length = 4;
</code></pre>
<p><code>x</code> in this snippet is holding a reference to an object, so custom properties
can be added and changed without issue.</p>
<p>The immutability of simple primitives like <code>number</code>s probably seems fairly
obvious. But what about <code>string</code> values? JS developers have a very common
misconception that strings are like arrays and can thus be changed. JS syntax
even hints at them being &quot;array like&quot; with the <code>[ ]</code> access operator. However,
strings are also immutable:</p>
<pre><code class="language-js">var s = &quot;hello&quot;;

s[1]; // &quot;e&quot;

s[1] = &quot;E&quot;;
s.length = 10;

s; // &quot;hello&quot;
</code></pre>
<p>Despite being able to access <code>s[1]</code> like it's an array, JS strings are not real
arrays. Setting <code>s[1] = &quot;E&quot;</code> and <code>s.length = 10</code> both silently fail, just as
<code>x.length = 4</code> did before. In strict mode, these assignments will fail, because
both the <code>1</code> property and the <code>length</code> property are read-only on this primitive
<code>string</code> value.</p>
<p>Interestingly, even the boxed <code>String</code> object value will act (mostly) immutable
as it will throw errors in strict mode if you change existing properties:</p>
<pre><code class="language-js">&quot;use strict&quot;;

var s = new String(&quot;hello&quot;);

s[1] = &quot;E&quot;; // error
s.length = 10; // error

s[42] = &quot;?&quot;; // OK

s; // &quot;hello&quot;
</code></pre>
<h2><a class="header" href="#value-to-value" id="value-to-value">Value to Value</a></h2>
<p>We'll unpack this idea more throughout the chapter, but just to start with a
clear understanding in mind: value immutability does not mean we can't have
values change over the course of our program. A program without changing state
is not a very interesting one! It also doesn't mean that our variables can't
hold different values. These are all common misconceptions about value
immutability.</p>
<p>Value immutability means that <em>when</em> we need to change the state in our program,
we must create and track a new value rather than mutate an existing value.</p>
<p>For example:</p>
<pre><code class="language-js">function addValue(arr) {
  var newArr = [...arr, 4];
  return newArr;
}

addValue([1, 2, 3]); // [1,2,3,4]
</code></pre>
<p>Notice that we did not change the array that <code>arr</code> references, but rather
created a new array (<code>newArr</code>) that contains the existing values plus the new
<code>4</code> value.</p>
<p>Analyze <code>addValue(..)</code> based on what we discussed in <a href="chapter_5.html">Chapter 5</a>
about side causes/effects. Is it pure? Does it have referential transparency?
Given the same array, will it always produce the same output? Is it free of both
side causes and side effects? <strong>Yes.</strong></p>
<p>Imagine the <code>[1,2,3]</code> array represents a sequence of data from some previous
operations and we stored in some variable. It is our current state. If we want
to compute what the next state of our application is, we call <code>addValue(..)</code>.
But we want that act of next-state computation to be direct and explicit. So the
<code>addValue(..)</code> operation takes a direct input, returns a direct output, and
avoids the side effect of mutating the original array that <code>arr</code> references.</p>
<p>This means we can calculate the new state of <code>[1,2,3,4]</code> and be fully in control
of that transition of states. No other part of our program can unexpectedly
transition us to that state early, or to another state entirely, like
<code>[1,2,3,5]</code>. By being disciplined about our values and treating them as
immutable, we drastically reduce the surface area of surprise, making our
programs easier to read, reason about, and ultimately trust.</p>
<p>The array that <code>arr</code> references is actually mutable. We just chose not to mutate
it, so we practiced the spirit of value immutability.</p>
<p>We can use the copy-instead-of-mutate strategy for objects, too. Consider:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  var newUserRecord = Object.assign({}, user);
  newUserRecord.lastLogin = Date.now();
  return newUserRecord;
}

var user = {
  // ..
};

user = updateLastLogin(user);
</code></pre>
<h3><a class="header" href="#non-local" id="non-local">Non-Local</a></h3>
<p>Non-primitive values are held by reference, and when passed as arguments, it's
the reference that's copied, not the value itself.</p>
<p>If you have an object or array in one part of the program, and pass it to a
function that resides in another part of the program, that function can now
affect the value via this reference copy, mutating it in possibly unexpected
ways.</p>
<p>In other words, if passed as arguments, non-primitive values become non-local.
Potentially the entire program has to be considered to understand whether such a
value will be changed or not.</p>
<p>Consider:</p>
<pre><code class="language-js">var arr = [1, 2, 3];

foo(arr);

console.log(arr[0]);
</code></pre>
<p>Ostensibly, you're expecting <code>arr[0]</code> to still be the value <code>1</code>. But is it? You
don't know, because <code>foo(..)</code> <em>might</em> mutate the array using the reference copy
you pass to it.</p>
<p>We already saw a trick in the previous chapter to avoid such a surprise:</p>
<pre><code class="language-js">var arr = [1, 2, 3];

foo([...arr]); // ha! a copy!

console.log(arr[0]); // 1
</code></pre>
<p>In a little bit, we'll see another strategy for protecting ourselves from a
value being mutated out from underneath us unexpectedly.</p>
<h2><a class="header" href="#reassignment" id="reassignment">Reassignment</a></h2>
<p>How would you describe what a &quot;constant&quot; is? Think about that for a moment
before you move on to the next paragraph.</p>
<p align="center">
    * * * *
</p>
<p>Some of you may have conjured descriptions like, &quot;a value that can't change&quot;, &quot;a
variable that can't be changed&quot;, or something similar. These are all
approximately in the neighborhood, but not quite at the right house. The precise
definition we should use for a constant is: a variable that cannot be
reassigned.</p>
<p>This nitpicking is really important, because it clarifies that a constant
actually has nothing to do with the value, except to say that whatever value a
constant holds, that variable cannot be reassigned any other value. But it says
nothing about the nature of the value itself.</p>
<p>Consider:</p>
<pre><code class="language-js">var x = 2;
</code></pre>
<p>Like we discussed earlier, the value <code>2</code> is an unchangeable (immutable)
primitive. If I change that code to:</p>
<pre><code class="language-js">const x = 2;
</code></pre>
<p>The presence of the <code>const</code> keyword, known familiarly as a &quot;constant
declaration&quot;, actually does nothing at all to change the nature of <code>2</code>; it's
already unchangeable, and it always will be.</p>
<p>It's true that this later line will fail with an error:</p>
<pre><code class="language-js">// try to change `x`, fingers crossed!
x = 3; // Error!
</code></pre>
<p>But again, we're not changing anything about the value. We're attempting to
reassign the variable <code>x</code>. The values involved are almost incidental.</p>
<p>To prove that <code>const</code> has nothing to do with the nature of the value, consider:</p>
<pre><code class="language-js">const x = [2];
</code></pre>
<p>Is the array a constant? <strong>No.</strong> <code>x</code> is a constant because it cannot be
reassigned. But this later line is totally OK:</p>
<pre><code class="language-js">x[0] = 3;
</code></pre>
<p>Why? Because the array is still totally mutable, even though <code>x</code> is a constant.</p>
<p>The confusion around <code>const</code> and &quot;constant&quot; only dealing with assignments and
not value semantics is a long and dirty story. It seems a high degree of
developers in just about every language that has a <code>const</code> stumble over the same
sorts of confusions. Java in fact deprecated <code>const</code> and introduced a new
keyword <code>final</code> at least in part to separate itself from the confusion over
&quot;constant&quot; semantics.</p>
<p>Setting aside the confusion detractions, what importance does <code>const</code> hold for
the FPer, if not to have anything to do with creating an immutable value?</p>
<h3><a class="header" href="#intent" id="intent">Intent</a></h3>
<p>The use of <code>const</code> tells the reader of your code that <em>that</em> variable will not
be reassigned. As a signal of intent, <code>const</code> is often highly lauded as a
welcome addition to JavaScript and a universal improvement in code readability.</p>
<p>In my opinion, this is mostly hype; there's not much substance to these claims.
I see only the mildest of faint benefit in signaling your intent in this way.
And when you match that up against decades of precedent around confusion about
it implying value immutability, I don't think <code>const</code> comes close to carrying
its own weight.</p>
<p>To back up my assertion, let's consider scope. <code>const</code> creates a block scoped
variable, meaning that variable only exists in that one localized block:</p>
<pre><code class="language-js">// lots of code

{
  const x = 2;

  // a few lines of code
}

// lots of code
</code></pre>
<p>Typically, blocks are considered best designed to be only a few lines long. If
you have blocks of more than say 10 lines, most developers will advise you to
refactor. So <code>const x = 2</code> only applies to those next nine lines of code at
most.</p>
<p>No other part of the program can ever affect the assignment of <code>x</code>. <strong>Period.</strong></p>
<p>My claim is that program has basically the same magnitude of readability as this
one:</p>
<pre><code class="language-js">// lots of code

{
  let x = 2;

  // a few lines of code
}

// lots of code
</code></pre>
<p>If you look at the next few lines of code after <code>let x = 2;</code>, you'll be able to
easily tell that <code>x</code> is in fact <em>not</em> reassigned. That to me is a <strong>much
stronger signal</strong> -- actually not reassigning it! -- than the use of some
confusable <code>const</code> declaration to say &quot;won't reassign it&quot;.</p>
<p>Moreover, let's consider what this code is likely to communicate to a reader at
first glance:</p>
<pre><code class="language-js">const magicNums = [1, 2, 3, 4];
</code></pre>
<p>Isn't it at least possible (probable?) that the reader of your code will assume
(wrongly) that your intent is to never mutate the array? That seems like a
reasonable inference to me. Imagine their confusion if later you do in fact
allow the array value referenced by <code>magicNums</code> to be mutated. Might that
surprise them?</p>
<p>Worse, what if you intentionally mutate <code>magicNums</code> in some way that turns out
to not be obvious to the reader? Subsequently in the code, they see a usage of
<code>magicNums</code> and assume (again, wrongly) that it's still <code>[1,2,3,4]</code> because they
read your intent as, &quot;not gonna change this&quot;.</p>
<p>I think you should use <code>var</code> or <code>let</code> for declaring variables to hold values
that you intend to mutate. I think that actually is a <strong>much clearer signal</strong> of
your intent than using <code>const</code>.</p>
<p>But the troubles with <code>const</code> don't stop there. Remember we asserted at the top
of the chapter that to treat values as immutable means that when our state needs
to change, we have to create a new value instead of mutating it? What are you
going to do with that new array once you've created it? If you declared your
reference to it using <code>const</code>, you can't reassign it.</p>
<pre><code class="language-js">const magicNums = [1, 2, 3, 4];

// later:
magicNums = magicNums.concat(42); // oops, can't reassign!
</code></pre>
<p>So... what next?</p>
<p>In this light, I see <code>const</code> as actually making our efforts to adhere to FP
harder, not easier. My conclusion: <code>const</code> is not all that useful. It creates
unnecessary confusion and restricts us in inconvenient ways. I only use <code>const</code>
for simple constants like:</p>
<pre><code class="language-js">const PI = 3.141592;
</code></pre>
<p>The value <code>3.141592</code> is already immutable, and I'm clearly signaling, &quot;this <code>PI</code>
will always be used as stand-in placeholder for this literal value.&quot; To me,
that's what <code>const</code> is good for. And to be frank, I don't use many of those
kinds of declarations in my typical coding.</p>
<p>I've written and seen a lot of JavaScript, and I just think it's an imagined
problem that very many of our bugs come from accidental reassignment.</p>
<p>One of the reasons FPers so highly favor <code>const</code> and avoid reassignment is
because of equational reasoning. Though this topic is more related to other
languages than JS and goes beyond what we'll get into here, it is a valid point.
However, I prefer the pragmatic view over the more academic one.</p>
<p>For example, I've found measured use of variable reassignment can be useful in
simplifying the description of intermediate states of computation. When a value
goes through multiple type coercions or other transformations, I don't generally
want to come up with new variable names for each representation:</p>
<pre><code class="language-js">var a = &quot;420&quot;;

// later

a = Number(a);

// later

a = [a];
</code></pre>
<p>If after changing from <code>&quot;420&quot;</code> to <code>420</code>, the original <code>&quot;420&quot;</code> value is no longer
needed, then I think it's more readable to reassign <code>a</code> rather than come up with
a new variable name like <code>aNum</code>.</p>
<p>The thing we really should worry more about is not whether our variables get
reassigned, but <strong>whether our values get mutated</strong>. Why? Because values are
portable; lexical assignments are not. You can pass an array to a function, and
it can be changed without you realizing it. But a reassignment will never be
unexpectedly caused by some other part of your program.</p>
<h3><a class="header" href="#its-freezing-in-here" id="its-freezing-in-here">It's Freezing in Here</a></h3>
<p>There's a cheap and simple way to turn a mutable object/array/function into an
&quot;immutable value&quot; (of sorts):</p>
<pre><code class="language-js">var x = Object.freeze([2]);
</code></pre>
<p>The <code>Object.freeze(..)</code> utility goes through all the properties/indices of an
object/array and marks them as read-only, so they cannot be reassigned. It's
sorta like declaring properties with a <code>const</code>, actually! <code>Object.freeze(..)</code>
also marks the properties as non-reconfigurable, and it marks the object/array
itself as non-extensible (no new properties can be added). In effect, it makes
the top level of the object immutable.</p>
<p>Top level only, though. Be careful!</p>
<pre><code class="language-js">var x = Object.freeze([2, 3, [4, 5]]);

// not allowed:
x[0] = 42;

// oops, still allowed:
x[2][0] = 42;
</code></pre>
<p><code>Object.freeze(..)</code> provides shallow, naive immutability. You'll have to walk
the entire object/array structure manually and apply <code>Object.freeze(..)</code> to each
sub-object/array if you want a deeply immutable value.</p>
<p>But contrasted with <code>const</code> which can confuse you into thinking you're getting
an immutable value when you aren't, <code>Object.freeze(..)</code> <em>actually</em> gives you an
immutable value.</p>
<p>Recall the protection example from earlier:</p>
<pre><code class="language-js">var arr = Object.freeze([1, 2, 3]);

foo(arr);

console.log(arr[0]); // 1
</code></pre>
<p>Now <code>arr[0]</code> is quite reliably <code>1</code>.</p>
<p>This is so important because it makes reasoning about our code much easier when
we know we can trust that a value doesn't change when passed somewhere that we
do not see or control.</p>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<p>Whenever we start creating new values (arrays, objects, etc.) instead of
mutating existing ones, the obvious next question is: what does that mean for
performance?</p>
<p>If we have to reallocate a new array each time we need to add to it, that's not
only churning CPU time and consuming extra memory; the old values (if no longer
referenced) are also being garbage collected. That's even more CPU burn.</p>
<p>Is that an acceptable trade-off? It depends. No discussion or optimization of
code performance should happen <strong>without context.</strong></p>
<p>If you have a single state change that happens once (or even a couple of times)
in the whole life of the program, throwing away an old array/object for a new
one is almost certainly not a concern. The churn we're talking about will be so
small -- probably mere microseconds at most -- as to have no practical effect on
the performance of your application. Compared to the minutes or hours you will
save not having to track down and fix a bug related to unexpected value
mutation, there's not even a contest here.</p>
<p>Then again, if such an operation is going to occur frequently, or specifically
happen in a <em>critical path</em> of your application, then performance -- consider
both performance and memory! -- is a totally valid concern.</p>
<p>Think about a specialized data structure that's like an array, but that you want
to be able to make changes to and have each change behave implicitly as if the
result was a new array. How could you accomplish this without actually creating
a new array each time? Such a special array data structure could store the
original value and then track each change made as a delta from the previous
version.</p>
<p>Internally, it might be like a linked-list tree of object references where each
node in the tree represents a mutation of the original value. Actually, this is
conceptually similar to how <strong>Git</strong> version control works.</p>
<p align="center">
    <img alt="figure" src="images/fig18.png" width="33%">
</p>
<p>In this conceptual illustration, an original array <code>[3,6,1,0]</code> first has the
mutation of value <code>4</code> assigned to position <code>0</code> (resulting in <code>[4,6,1,0]</code>), then
<code>1</code> is assigned to position <code>3</code> (now <code>[4,6,1,1]</code>), finally <code>2</code> is assigned to
position <code>4</code> (result: <code>[4,6,1,1,2]</code>). The key idea is that at each mutation,
only the change from the previous version is recorded, not a duplication of the
entire original data structure. This approach is much more efficient in both
memory and CPU performance, in general.</p>
<p>Imagine using this hypothetical specialized array data structure like this:</p>
<pre><code class="language-js">var state = specialArray(4, 6, 1, 1);

var newState = state.set(4, 2);

state === newState; // false

state.get(2); // 1
state.get(4); // undefined

newState.get(2); // 1
newState.get(4); // 2

newState.slice(2, 5); // [1,1,2]
</code></pre>
<p>The <code>specialArray(..)</code> data structure would internally keep track of each
mutation operation (like <code>set(..)</code>) as a <em>diff</em>, so it won't have to reallocate
memory for the original values (<code>4</code>, <code>6</code>, <code>1</code>, and <code>1</code>) just to add the <code>2</code>
value to the end of the list. But importantly, <code>state</code> and <code>newState</code> point at
different versions (or views) of the array value, so <strong>the value immutability
semantic is preserved.</strong></p>
<p>Inventing your own performance-optimized data structures is an interesting
challenge. But pragmatically, you should probably use a library that already
does this well. One great option is
<a href="http://facebook.github.io/immutable-js">Immutable.js</a>, which provides a variety
of data structures, including <code>List</code> (like array) and <code>Map</code> (like object).</p>
<p>Consider the previous <code>specialArray</code> example but using <code>Immutable.List</code>:</p>
<pre><code class="language-js">var state = Immutable.List.of(4, 6, 1, 1);

var newState = state.set(4, 2);

state === newState; // false

state.get(2); // 1
state.get(4); // undefined

newState.get(2); // 1
newState.get(4); // 2

newState.toArray().slice(2, 5); // [1,1,2]
</code></pre>
<p>A powerful library like Immutable.js employs sophisticated performance
optimizations. Handling all the details and corner-cases manually without such a
library would be quite difficult.</p>
<p>When changes to a value are few or infrequent and performance is less of a
concern, I'd recommend the lighter-weight solution, sticking with built-in
<code>Object.freeze(..)</code> as discussed earlier.</p>
<h2><a class="header" href="#treatment" id="treatment">Treatment</a></h2>
<p>What if we receive a value to our function and we're not sure if it's mutable or
immutable? Is it ever OK to just go ahead and try to mutate it? <strong>No.</strong> As we
asserted at the beginning of this chapter, we should treat all received values
as immutable -- to avoid side effects and remain pure -- regardless of whether
they are or not.</p>
<p>Recall this example from earlier:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  var newUserRecord = Object.assign({}, user);
  newUserRecord.lastLogin = Date.now();
  return newUserRecord;
}
</code></pre>
<p>This implementation treats <code>user</code> as a value that should not be mutated; whether
it <em>is</em> immutable or not is irrelevant to reading this part of the code.
Contrast that with this implementation:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  user.lastLogin = Date.now();
  return user;
}
</code></pre>
<p>That version is a lot easier to write, and even performs better. But not only
does this approach make <code>updateLastLogin(..)</code> impure, it also mutates a value in
a way that makes both the reading of this code, as well as the places it's used,
more complicated.</p>
<p><strong>We should treat <code>user</code> as immutable</strong>, always, because at this point of
reading the code we do not know where the value comes from, or what potential
issues we may cause if we mutate it.</p>
<p>Nice examples of this approach can be seen in various built-in methods of the JS
array, such as <code>concat(..)</code> and <code>slice(..)</code>:</p>
<pre><code class="language-js">var arr = [1, 2, 3, 4, 5];

var arr2 = arr.concat(6);

arr; // [1,2,3,4,5]
arr2; // [1,2,3,4,5,6]

var arr3 = arr2.slice(1);

arr2; // [1,2,3,4,5,6]
arr3; // [2,3,4,5,6]
</code></pre>
<p>Other array prototype methods that treat the value instance as immutable and
return a new array instead of mutating: <code>map(..)</code> and <code>filter(..)</code>. The
<code>reduce(..)</code>/<code>reduceRight(..)</code> utilities also avoid mutating the instance,
though they don't by default return a new array.</p>
<p>Unfortunately, for historical reasons, quite a few other array methods are
impure mutators of their instance: <code>splice(..)</code>, <code>pop(..)</code>, <code>push(..)</code>,
<code>shift(..)</code>, <code>unshift(..)</code>, <code>reverse(..)</code>, <code>sort(..)</code>, and <code>fill(..)</code>.</p>
<p>It should not be seen as <em>forbidden</em> to use these kinds of utilities, as some
claim. For reasons such as performance optimization, sometimes you will want to
use them. But you should never use such a method on an array value that is not
already local to the function you're working in, to avoid creating a side effect
on some other remote part of the code.</p>
<p><a name="hiddenmutation"></a></p>
<p>Recall one of the implementations of
<a href="chapter_4.html"><code>compose(..)</code> from Chapter 4</a>:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    // copy the array of functions
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = list.pop()(result);
    }

    return result;
  };
}
</code></pre>
<p>The <code>...fns</code> gather parameter is making a new local array from the passed-in
arguments, so it's not an array that we could create an outside side effect on.
It would be reasonable then to assume that it's safe for us to mutate it
locally. But the subtle gotcha here is that the inner <code>composed(..)</code> which
closes over <code>fns</code> is not &quot;local&quot; in this sense.</p>
<p>Consider this different version which doesn't make a copy:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    while (fns.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = fns.pop()(result);
    }

    return result;
  };
}

var f = compose(
  x =&gt; x / 3,
  x =&gt; x + 1,
  x =&gt; x * 2
);

f(4); // 3

f(4); // 4 &lt;-- uh oh!
</code></pre>
<p>The second usage of <code>f(..)</code> here wasn't correct, since we mutated that <code>fns</code>
during the first call, which affected any subsequent uses. Depending on the
circumstances, making a copy of an array like <code>list = [...fns]</code> may or may not
be necessary. But I think it's safest to assume you need it -- even if only for
readability sake! -- unless you can prove you don't, rather than the other way
around.</p>
<p>Be disciplined and always treat <em>received values</em> as immutable, whether they are
or not. That effort will improve the readability and trustability of your code.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Value immutability is not about unchanging values. It's about creating and
tracking new values as the state of the program changes, rather than mutating
existing values. This approach leads to more confidence in reading the code,
because we limit the places where our state can change in ways we don't readily
see or expect.</p>
<p><code>const</code> declarations (constants) are commonly mistaken for their ability to
signal intent and enforce immutability. In reality, <code>const</code> has basically
nothing to do with value immutability, and its usage will likely create more
confusion than it solves. Instead, <code>Object.freeze(..)</code> provides a nice built-in
way of setting shallow value immutability on an array or object. In many cases,
this will be sufficient.</p>
<p>For performance-sensitive parts of the program, or in cases where changes happen
frequently, creating a new array or object (especially if it contains lots of
data) is undesirable, for both processing and memory concerns. In these cases,
using immutable data structures from a library like <strong>Immutable.js</strong> is probably
the best idea.</p>
<p>The importance of value immutability on code readability is less in the
inability to change a value, and more in the discipline to treat a value as
immutable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_5.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_7.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="chapter_5.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="chapter_7.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
