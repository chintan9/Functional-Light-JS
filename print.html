<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functional-Light JavaScript</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="expanded "><a href="chapter_4.html"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Functional-Light JavaScript</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#foreword" id="foreword">Foreword</a></h1>
<p>It's no secret that I am a Functional Programming nut. I evangelize functional
ideas and languages wherever I can, try to read the latest academic papers,
study abstract algebra in my spare time…the works. Even in JavaScript, I refuse
to write an impure statement, which is what led to writing <em>Professor Frisby's
Mostly Adequate Guide to Functional Programming</em>. Yep, full on, dogmatic zealot.</p>
<p>I was not always this way… I was once obsessed with objects. I loved modeling
the &quot;real world&quot;. I was the inventor of synthetic automatons, tinkering through
the night with masterful precision. The creator of sentient puppets, fingers
dancing on the keyboard to give them life -- a real 1337 h4x0r Geppetto. Yet,
after 5 <em>solid</em> years of writing object-oriented code, I was never quite
satisfied with the outcome. It just never worked out well for me. I felt like a
lousy programmer. I even lost faith that a simple, flexible codebase of decent
scale was possible.</p>
<p>I figured I'd try something different: Functional Programming. I began to dabble
with functional ideas in my everyday codebase, and much to my coworkers' dismay,
hadn't the slightest clue what I was doing. The code I wrote in those days was
awful. Atrocious. Digital sewage. The reason was a lack of clear vision or goal
on what I was even trying to accomplish. My Jiminy-Coding-Cricket, if you like,
was not there to guide me. It took a long time and a lot of garbage programs to
figure out how to FP.</p>
<p>Now, after all that messy exploration, I feel that pure Functional Programming
has delivered on its promise. Readable programs do exist! Reuse does exist! I no
longer invent, but rather discover my model. I've become a rogue detective
uncovering a vast conspiracy, cork board pinned full of mathematical evidence. A
digital-age Cousteau logging the characteristics of this bizarre land in the
name of science! It's not perfect and I still have a lot to learn, but I've
never been more satisfied in my work and pleased with the outcome.</p>
<p>Had this book existed when I was starting out, my transition into the world of
Functional Programming would have been much easier and less destructive. This
book is two-fold (right and left): it will not only teach you how to use various
constructs from FP effectively in your daily code, but more importantly, provide
you with an aim; guiding principles that will keep you on track.</p>
<p>You will learn Functional-Light: A paradigm that Kyle has pioneered to enable
declarative, Functional Programming while providing balance and interop with the
rest of the JavaScript world. You will understand the foundation which pure FP
is built upon without having to subscribe to the paradigm in its entirety. You
will gain the skills to practice and explore FP without having to rewrite
existing code for it to work well together. You can take a step forward in your
software career without backtracking and wandering aimlessly as I did years ago.
Coworkers and colleagues rejoice!</p>
<p>Kyle is a great teacher known for his relentless pursuit of the whole picture,
leaving no nook or cranny unexplored, yet he maintains an empathy for the
learner's plight. His style has resonated with the industry, leveling us all up
as a whole. His work has a solid place in JavaScript’s history and most people's
bookmarks bar. You are in good hands.</p>
<p>Functional Programming has many different definitions. A Lisp programmer's
definition is vastly different from a Haskell perspective. OCaml's FP bears
little resemblance to the paradigm seen in Erlang. You will even find several
competing definitions in JavaScript. Yet there is a tie that binds -- some
blurry know-it-when-I-see-it definition, much like obscenity (indeed, some do
find FP obscene!) and this book certainly captures it. The end result might not
be considered idiomatic in certain circles, but the knowledge acquired here
directly applies to any flavor of FP.</p>
<p>This book is a terrific place to begin your FP journey. Take it away, Kyle...</p>
<p><em>-Brian Lonsdorf (@drboolean)</em></p>
<h1><a class="header" href="#functional-light-javascript-1" id="functional-light-javascript-1">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#preface" id="preface">Preface</a></h1>
<blockquote>
<p><em>A monad is just a monoid in the category of endofunctors.</em></p>
</blockquote>
<p>Did I just lose you? Don't worry, I'd be lost, too! All those terms that only
mean something to the already-initiated in Functional Programming™ (FP)
are just jumbled nonsense to many of the rest of us.</p>
<p>This book is not going to teach you what those words mean. If that's what you're
looking for, keep looking. In fact, there are already plenty of great books that
teach FP the <em>right way</em>, from the top-down. Those words have important meanings
and if you formally study FP in-depth, you'll absolutely want to get familiar
with them.</p>
<p>But this book is going to approach the topic quite differently. I'm going to
present fundamental FP concepts from the ground-up, with fewer special or
non-intuitive terms than most approaches to FP. We'll try to take a practical
approach to each principle rather than a purely academic angle. <strong>There will be
terms</strong>, no doubt. But we'll be careful and deliberate about introducing them
and explaining why they're important.</p>
<p>Sadly, I am not a card-carrying member of the FP Cool Kids Club. I've never been
formally taught anything about FP. And though I have a CS academic background
and I am decent at math, mathematical notation is not how my brain understands
programming. I have never written a line of Scheme, Clojure, or Haskell. I'm not
an old-school Lisp'r.</p>
<p>I <em>have</em> attended countless conference talks about FP, each one with the
desperate clinging hope that finally, <em>this time</em> would be the time I understood
what this whole functional programming mysticism is all about. And each time, I
came away frustrated and reminded that those terms got all mixed up in my head
and I had no idea if or what I learned. Maybe I learned things. But I couldn't
figure out what those things were for the longest time.</p>
<p>Little by little, across those various exposures, I teased out bits and pieces
of important concepts that seem to just come all too naturally to the formal
FPer. I learned them slowly and I learned them pragmatically and experientially,
not academically with appropriate terminology. Have you ever known a thing for a
long time, and only later found out it had a specific name you never knew!?</p>
<p>Maybe you're like me; I heard terms such as &quot;map-reduce&quot; around industry
segments like &quot;big data&quot; for years with no real idea what they were. Eventually
I learned what the <code>map(..)</code> function did -- all long before I had any idea that
list operations were a cornerstone of the FPer path and what makes them so
important. I knew what <em>map</em> was long before I ever knew it was called
<code>map(..)</code>.</p>
<p>Eventually I began to gather all these tidbits of understanding into what I now
call &quot;Functional-Light Programming&quot; (FLP).</p>
<h2><a class="header" href="#mission" id="mission">Mission</a></h2>
<p>But why is it so important for you to learn functional programming, even the
light form?</p>
<p>I've come to believe something very deeply in recent years, so much so you could
<em>almost</em> call it a religious belief. I believe that programming is fundamentally
about humans, not about code. I believe that code is first and foremost a means
of human communication, and only as a <em>side effect</em> (hear my self-referential
chuckle) does it instruct the computer.</p>
<p>The way I see it, functional programming is at its heart about using patterns in
your code that are well-known, understandable, <em>and</em> proven to keep away the
mistakes that make code harder to understand. In that view, FP -- or, ahem, FLP!
-- might be one of the most important collections of tools any developer could
acquire.</p>
<blockquote>
<p>The curse of the monad is that... once you understand... you lose the ability
to explain it to anyone else.</p>
<p>Douglas Crockford 2012 &quot;Monads and Gonads&quot;</p>
<p>https://www.youtube.com/watch?v=dkZFtimgAcM</p>
</blockquote>
<p>I hope this book &quot;Maybe&quot; breaks the spirit of that curse, even though we won't
talk about &quot;monads&quot; until the very end in the appendices.</p>
<p>The formal FPer will often assert that the <em>real value</em> of FP is in using it
essentially 100%: it's an all-or-nothing proposition. The belief is that if you
use FP in one part of your program but not in another, the whole program is
polluted by the non-FP stuff and therefore suffers enough that the FP was
probably not worth it.</p>
<p>I'll say unequivocally: <strong>I think that absolutism is bogus</strong>. That's as silly to
me as suggesting that this book is only good if I use perfect grammar and active
voice throughout; if I make any mistakes, it degrades the entire book's quality.
Nonsense.</p>
<p>The better I am at writing in a clear, consistent voice, the better your reading
experience will be. But I'm not a 100% perfect author. Some parts will be better
written than others. The parts where I can still improve are not going to
invalidate the other parts of this book which are useful.</p>
<p>And so it goes with our code. The more you can apply these principles to more
parts of your code, the better your code will be. Use them well 25% of the time,
and you'll get some good benefit. Use them 80% of the time, and you'll see even
more benefit.</p>
<p>With perhaps a few exceptions, I don't think you'll find many absolutes in this
text. We'll instead talk about aspirations, goals, principles to strive for.
We'll talk about balance and pragmatism and trade-offs.</p>
<p>Welcome to this journey into the most useful and practical foundations of FP. We
both have plenty to learn!</p>
<h1><a class="header" href="#functional-light-javascript-2" id="functional-light-javascript-2">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-1-why-functional-programming" id="chapter-1-why-functional-programming">Chapter 1: Why Functional Programming?</a></h1>
<blockquote>
<p>Functional programmer: (noun) One who names variables &quot;x&quot;, names functions
&quot;f&quot;, and names code patterns &quot;zygohistomorphic prepromorphism&quot;</p>
<p>James Iry @jamesiry 5/13/15</p>
<p>https://twitter.com/jamesiry/status/598547781515485184</p>
</blockquote>
<p>Functional Programming (FP) is not a new concept by any means. It's been around
almost the entire history of programming. However, and I'm not sure it's fair to
say, but... it sure hasn't seemed like as mainstream of a concept in the overall
developer world until perhaps the last few years. I think FP has more been the
realm of academics.</p>
<p>That's all changing, though. A groundswell of interest is growing around FP, not
just at the languages level but even in libraries and frameworks. You very well
might be reading this text because you've finally realized FP is something you
can't ignore any longer. Or maybe you're like me and you've tried to learn FP
many times before but struggled to wade through all the terms or mathematical
notation.</p>
<p>This first chapter's purpose is to answer questions like &quot;Why should I use FP
style with my code?&quot; and &quot;How does Functional-Light JavaScript compare to what
others say about FP?&quot; After we've laid that groundwork, throughout the rest of
the book we'll uncover, piece by piece, the techniques and patterns for writing
JS in Functional-Light style.</p>
<h2><a class="header" href="#at-a-glance" id="at-a-glance">At a Glance</a></h2>
<p>Let's briefly illustrate the notion of &quot;Functional-Light JavaScript&quot; with a
before-and-after snapshot of code. Consider:</p>
<pre><code class="language-js">var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];
var faves = [];
var magicNumber = 0;

pickFavoriteNumbers();
calculateMagicNumber();
outputMsg(); // The magic number is: 42

// ***************

function calculateMagicNumber() {
  for (let fave of faves) {
    magicNumber = magicNumber + fave;
  }
}

function pickFavoriteNumbers() {
  for (let num of numbers) {
    if (num &gt;= 10 &amp;&amp; num &lt;= 20) {
      faves.push(num);
    }
  }
}

function outputMsg() {
  var msg = `The magic number is: ${magicNumber}`;
  console.log(msg);
}
</code></pre>
<p>Now consider a very different style that accomplishes exactly the same outcome:</p>
<pre><code class="language-js">var sumOnlyFavorites = FP.compose([
  FP.filterReducer(FP.gte(10)),
  FP.filterReducer(FP.lte(20))
])(sum);

var printMagicNumber = FP.pipe([
  FP.reduce(sumOnlyFavorites, 0),
  constructMsg,
  console.log
]);

var numbers = [4, 10, 0, 27, 42, 17, 15, -6, 58];

printMagicNumber(numbers); // The magic number is: 42

// ***************

function sum(x, y) {
  return x + y;
}
function constructMsg(v) {
  return `The magic number is: ${v}`;
}
</code></pre>
<p>Once you understand FP and Functional-Light, this is likely how you'd <em>read</em> and
mentally process that second snippet:</p>
<blockquote>
<p>We're first creating a function called <code>sumOnlyFavorites(..)</code> that's a
combination of three other functions. We combine two filters, one checking if
a value is greater-than-or-equal to 10 and one for less-than-or-equal to 20.
Then we include the <code>sum(..)</code> reducer in the transducer composition. The
resulting <code>sumOnlyFavorites(..)</code> function is a reducer that checks if a value
passes both filters, and if so, adds the value to an accumulator value.</p>
<p>Then we make another function called <code>printMagicNumber(..)</code> which first
reduces a list of numbers using that <code>sumOnlyFavorites(..)</code> reducer we just
defined, resulting in a sum of only numbers that passed the <em>favorite</em> checks.
Then <code>printMagicNumber(..)</code> pipes that final sum into <code>constructMsg(..)</code>,
which creates a string value that finally goes into <code>console.log(..)</code>.</p>
</blockquote>
<p>All those moving pieces <em>speak</em> to an FP developer in ways that likely seem
highly unfamiliar to you right now. This book will help you <em>speak</em> that same
kind of reasoning so that it's as readable to you as any other code, if not more
so!</p>
<p>A few other quick remarks about this code comparison:</p>
<ul>
<li>
<p>It's likely that for many readers, the former snippet feels closer to
comfortable/readable/maintainable than the latter snippet. It's entirely OK if
that's the case. You're in exactly the right spot. I'm confident that if you
stick it out through the whole book, and practice everything we talk about,
that second snippet will eventually become a lot more natural, maybe even
preferable!</p>
</li>
<li>
<p>You might have done the task significantly or entirely different from either
snippet presented. That's OK, too. This book won't be prescriptive in
dictating that you should do something a specific way. The goal is to
illustrate the pros/cons of various patterns and enable you to make those
decisions. By the end of this book, how you would approach the task may fall a
little closer to the second snippet than it does right now.</p>
</li>
<li>
<p>It's also possible that you're already a seasoned FP developer who's scanning
through the start of this book to see if it has anything useful for you to
read. That second snippet certainly has some bits that are quite familiar. But
I'm also betting that you thought, &quot;Hmmm, I wouldn't have done it <em>that</em>
way...&quot; a couple of times. That's OK, and entirely reasonable.</p>
<p>This is not a traditional, canonical FP book. We'll at times seem quite
heretical in our approaches. We're seeking to strike a pragmatic balance
between the clear undeniable benefits of FP, and the need to ship workable,
maintainable JS without having to tackle a daunting mountain of
math/notation/terminology. This is not <em>your</em> FP, it's &quot;Functional-Light
JavaScript&quot;.</p>
</li>
</ul>
<p>Whatever your reasons for reading this book, welcome!</p>
<h2><a class="header" href="#confidence" id="confidence">Confidence</a></h2>
<p>I have a very simple premise that sort of underlies everything I do as a teacher
of software development (in JavaScript): code that you cannot trust is code that
you do not understand. The reverse is true also: code that you don't understand
is code you can't trust. Furthermore, if you cannot trust or understand your
code, then you can't have any confidence whatsoever that the code you write is
suitable to the task. You run the program and basically just cross your fingers.</p>
<p>What do I mean by trust? I mean that you can verify, by reading and reasoning,
not just executing, that you understand what a piece of code <em>will</em> do; you
aren't just relying on what it <em>should</em> do. More often than is perhaps prudent,
we tend to rely on running test suites to verify our programs' correctness. I
don't mean to suggest tests are bad. But I do think we should aspire to be able
to understand our code well enough that we know the test suite will pass before
it runs.</p>
<p>The techniques that form the foundation of FP are designed from the mindset of
having far more confidence over our programs just by reading them. Someone who
understands FP, and who's disciplined enough to diligently use it throughout
their programs, will write code that they <strong>and others</strong> can read and verify
that the program will do what they want.</p>
<p>Confidence is also increased when we use techniques that avoid or minimize
likely sources of bugs. That's perhaps one of the biggest selling points of FP:
FP programs often have fewer bugs, and the bugs that do exist are usually in
more obvious places, so they're easier to find and fix. FP code tends to be more
bug-resistant -- certainly not bug-proof, though.</p>
<p>As you journey through this book, you will begin to develop more confidence in
the code you write, because you will use patterns and practices that are already
well proven; and you'll avoid the most common causes of program bugs!</p>
<h2><a class="header" href="#communication" id="communication">Communication</a></h2>
<p>Why is Functional Programming important? To answer that, we need to take a
bigger step back and talk about why programming itself is important.</p>
<p>It may surprise you to hear this, but I don't believe that code is primarily a
set of instructions for the computer. Actually, I think the fact that code
instructs the computer is almost a happy accident.</p>
<p>I believe very deeply that the vastly more important role of code is as a means
of communication with other human beings.</p>
<p>You probably know by experience that an awful lot of your time spent &quot;coding&quot; is
actually spent reading existing code. Very few of us are so privileged as to
spend all or most of our time simply banging out all new code and never dealing
with code that others (or our past selves) wrote.</p>
<p>It's widely estimated that developers spend 70% of code maintenance time on
reading to understand it. That is eye-opening. 70%. No wonder the global average
for a programmer's lines of code written per day is about 10. We spend up to 7
hours of our day just reading the code to figure out where those 10 lines should
go!</p>
<p>We need to focus a lot more on the readability of our code. And by the way,
readability is not just about fewer characters. Readability is actually most
impacted by familiarity.<a href="chapter_1.html#user-content-footnote-1"><sup>1</sup></a></p>
<p>If we are going to spend our time concerned with making code that will be more
readable and understandable, FP is central in that effort. The principles of FP
are well established, deeply studied and vetted, and provably verifiable. Taking
the time to learn and employ these FP principles will ultimately lead to more
readily and recognizably familiar code for you and others. The increase in code
familiarity, and the expediency of that recognition, will improve code
readability.</p>
<p>For example, once you learn what <code>map(..)</code> does, you'll be able to almost
instantly spot and understand it when you see it in any program. But every time
you see a <code>for</code> loop, you're going to have to read the whole loop to understand
it. The syntax of the <code>for</code> loop may be familiar, but the substance of what it's
doing is not; that has to be <em>read</em>, every time.</p>
<p>By having more code that's recognizable at a glance, and thus spending less time
figuring out what the code is doing, our focus is freed up to think about the
higher levels of program logic; this is the important stuff that most needs our
attention anyway.</p>
<p>FP (at least, without all the terminology weighing it down) is one of the most
effective tools for crafting readable code. <em>That</em> is why it's so important.</p>
<h2><a class="header" href="#readability" id="readability">Readability</a></h2>
<p>Readability is not a binary characteristic. It's a largely subjective human
factor describing our relationship to code. And it will naturally vary over time
as our skills and understanding evolve. I have experienced effects similar to
the following figure, and anecdotally many others I've talked to have as well.</p>
<p align="center">
    <img alt="figure" src="images/fig17.png" width="50%">
</p>
<p>You may just find yourself experiencing similar effects as you work through the
book. But take heart; if you stick this out, the curve comes back up!</p>
<p><em>Imperative</em> describes the code most of us probably already write naturally;
it's focused on precisely instructing the computer <em>how</em> to do something.
Declarative code -- the kind we'll be learning to write, which adheres to FP
principles -- is code that's more focused on describing the <em>what</em> outcome.</p>
<p>Let's revisit the two code snippets presented earlier in this chapter.</p>
<p>The first snippet is imperative, focused almost entirely on <em>how</em> to do the
tasks; it's littered with <code>if</code> statements, <code>for</code> loops, temporary variables,
reassignments, value mutations, function calls with side effects, and implicit
data flow between functions. You certainly <em>can</em> trace through its logic to see
how the numbers flow and change to the end state, but it's not at all clear or
straightforward.</p>
<p>The second snippet is more declarative; it does away with most of those
aforementioned imperative techniques. Notice there's no explicit conditionals,
loops, side effects, reassignments, or mutations; instead, it employs well-known
(to the FP world, anyway!) and trustable patterns like filtering, reduction,
transducing, and composition. The focus shifts from low-level <em>how</em> to higher
level <em>what</em> outcomes.</p>
<p>Instead of messing with an <code>if</code> statement to test a number, we delegate that to
a well-known FP utility like <code>gte(..)</code> (greater-than-or-equal-to), and then
focus on the more important task of combining that filter with another filter
and a summation function.</p>
<p>Moreover, the flow of data through the second program is explicit:</p>
<ol>
<li>A list of numbers goes into <code>printMagicNumber(..)</code>.</li>
<li>One at a time those numbers are processed by <code>sumOnlyFavorites(..)</code>,
resulting in a single number total of only our favorite kinds of numbers.</li>
<li>That total is converted to a message string with <code>constructMsg(..)</code>.</li>
<li>The message string is printed to the console with <code>console.log(..)</code>.</li>
</ol>
<p>You may still feel this approach is convoluted, and that the imperative snippet
was easier to understand. You're much more accustomed to it; familiarity has a
profound influence on our judgments of readability. By the end of this book,
though, you will have internalized the benefits of the second snippet's
declarative approach, and that familiarity will spring its readability to life.</p>
<p>I know asking you to believe that at this point is a leap of faith.</p>
<p>It takes a lot more effort, and sometimes more code, to improve its readability
as I'm suggesting, and to minimize or eliminate many of the mistakes that lead
to bugs. Quite honestly, when I started writing this book, I could never have
written (or even fully understood!) that second snippet. As I'm now further
along on my journey of learning, it's more natural and comfortable.</p>
<p>If you're hoping that FP refactoring, like a magic silver bullet, will quickly
transform your code to be more graceful, elegant, clever, resilient, and concise
-- that it will come easy in the short term -- unfortunately that's just not a
realistic expectation.</p>
<p>FP is a very different way of thinking about how code should be structured, to
make the flow of data much more obvious and to help your reader follow your
thinking. It will take time. This effort is eminently worthwhile, but it can be
an arduous journey.</p>
<p>It still often takes me multiple attempts at refactoring a snippet of imperative
code into more declarative FP, before I end up with something that's clear
enough for me to understand later. I've found converting to FP is a slow
iterative process rather than a quick binary flip from one paradigm to another.</p>
<p>I also apply the &quot;teach it later&quot; test to every piece of code I write. After
I've written a piece of code, I leave it alone for a few hours or days, then
come back and try to read it with fresh eyes, and pretend as if I need to teach
or explain it to someone else. Usually, it's jumbled and confusing the first few
passes, so I tweak it and repeat!</p>
<p>I'm not trying to dampen your spirits. I really want you to hack through these
weeds. I am glad I did it. I can finally start to see the curve bending upward
toward improved readability. The effort has been worth it. It will be for you,
too.</p>
<h2><a class="header" href="#perspective" id="perspective">Perspective</a></h2>
<p>Most other FP texts seem to take a top-down approach, but we're going to go the
opposite direction: working from the ground up, we'll uncover the basic
foundational principles that I believe formal FPers would admit are the
scaffolding for everything they do. But for the most part we'll stay arm's
length away from most of the intimidating terminology or mathematical notation
that can so easily frustrate learners.</p>
<p>I believe it's less important what you call something and more important that
you understand what it is and how it works. That's not to say there's no
importance to shared terminology -- it undoubtedly eases communication among
seasoned professionals. But for the learner, I've found it can be distracting.</p>
<p>So this book will try to focus more on the base concepts and less on the fancy
fluff. That's not to say there won't be terminology; there definitely will be.
But don't get too wrapped up in the sophisticated words. Wherever necessary,
look beyond them to the ideas.</p>
<p>I call the less formal practice herein &quot;Functional-Light Programming&quot; because I
think where the formalism of true FP suffers is that it can be quite
overwhelming if you're not already accustomed to formal thought. I'm not just
guessing; this is my own personal story. Even after teaching FP and writing this
book, I can still say that the formalism of terms and notation in FP is very,
very difficult for me to process. I've tried, and tried, and I can't seem to get
through much of it.</p>
<p>I know many FPers who believe that the formalism itself helps learning. But I
think there's clearly a cliff where that only becomes true once you reach a
certain comfort with the formalism. If you happen to already have a math
background or even some flavors of CS experience, this may come more naturally
to you. But some of us don't, and no matter how hard we try, the formalism keeps
getting in the way.</p>
<p>So this book introduces the concepts that I believe FP is built on, but comes at
it by giving you a boost from below to climb up the cliff wall, rather than
condescendingly shouting down at you from the top, prodding you to just figure
out how to climb as you go.</p>
<h2><a class="header" href="#how-to-find-balance" id="how-to-find-balance">How to Find Balance</a></h2>
<p>If you've been around programming for very long, chances are you've heard the
phrase &quot;YAGNI&quot; before: &quot;You Ain't Gonna Need It&quot;. This principle primarily comes
from extreme programming, and stresses the high risk and cost of building a
feature before it's needed.</p>
<p>Sometimes we guess we'll need a feature in the future, build it now believing
it'll be easier to do as we build other stuff, then realize we guessed wrong and
the feature wasn't needed, or needed to be quite different. Other times we guess
right, but build a feature too early, and suck up time from the features that
are genuinely needed now; we incur an opportunity cost in diluting our energy.</p>
<p>YAGNI challenges us to remember: even if it's counterintuitive in a situation,
we often should postpone building something until it's presently needed. We tend
to exaggerate our mental estimates of the future refactoring cost of adding it
later when it is needed. Odds are, it won't be as hard to do later as we might
assume.</p>
<p>As it applies to functional programming, I would offer this admonition: there
will be plenty of interesting and compelling patterns discussed in this text,
but just because you find some pattern exciting to apply, it may not necessarily
be appropriate to do so in a given part of your code.</p>
<p>This is where I will differ from many formal FPers: just because you <em>can</em> apply
FP to something doesn't mean you <em>should</em> apply FP to it. Moreover, there are
many ways to slice a problem, and even though you may have learned a more
sophisticated approach that is more &quot;future-proof&quot; to maintenance and
extensibility, a simpler FP pattern might be more than sufficient in that spot.</p>
<p>Generally, I'd recommend seeking balance in what you code, and to be
conservative in your application of FP concepts as you get the hang of things.
Default to the YAGNI principle in deciding if a certain pattern or abstraction
will help that part of the code be more readable or if it's just introducing
clever sophistication that isn't (yet) warranted.</p>
<blockquote>
<p>Reminder, any extensibility point that’s never used isn’t just wasted effort,
it’s likely to also get in your way as well</p>
<p>Jeremy D. Miller @jeremydmiller 2/20/15</p>
<p>https://twitter.com/jeremydmiller/status/568797862441586688</p>
</blockquote>
<p>Remember, every single line of code you write has a reader cost associated with
it. That reader may be another team member, or even your future self. Neither of
those readers will be impressed with overly clever, unnecessary sophistication
just to show off your FP prowess.</p>
<p>The best code is the code that is most readable in the future because it strikes
exactly the right balance between what it can/should be (idealism) and what it
must be (pragmatism).</p>
<h2><a class="header" href="#resources" id="resources">Resources</a></h2>
<p>I have drawn on a great many different resources to be able to compose this
text. I believe you, too, may benefit from them, so I wanted to take a moment to
point them out.</p>
<h3><a class="header" href="#books" id="books">Books</a></h3>
<p>Some FP/JavaScript books that you should definitely read:</p>
<ul>
<li><a href="https://drboolean.gitbooks.io/mostly-adequate-guide/content/ch1.html">Professor Frisby's Mostly Adequate Guide to Functional Programming</a>
by <a href="https://twitter.com/drboolean">Brian Lonsdorf</a></li>
<li><a href="https://leanpub.com/javascriptallongesix">JavaScript Allongé</a> by
<a href="https://twitter.com/raganwald">Reg Braithwaite</a></li>
<li><a href="http://shop.oreilly.com/product/0636920028857.do">Functional JavaScript</a> by
<a href="https://twitter.com/fogus">Michael Fogus</a></li>
</ul>
<h3><a class="header" href="#blogssites" id="blogssites">Blogs/sites</a></h3>
<p>Some other authors and content you should check out:</p>
<ul>
<li><a href="https://www.youtube.com/watch?v=BMUiFMZr7vk">Fun Fun Function Videos</a> by
<a href="https://twitter.com/mpjme">Mattias P Johansson</a></li>
<li><a href="https://github.com/stoeffel/awesome-fp-js">Awesome FP JS</a></li>
<li><a href="http://blog.jenkster.com/2015/12/what-is-functional-programming.html">Kris Jenkins</a></li>
<li><a href="https://medium.com/@_ericelliott">Eric Elliott</a></li>
<li><a href="https://james-forbes.com/">James A Forbes</a></li>
<li><a href="https://github.com/jlongster">James Longster</a></li>
<li><a href="http://staltz.com/">André Staltz</a></li>
<li><a href="https://github.com/hemanth/functional-programming-jargon#functional-programming-jargon">Functional Programming Jargon</a></li>
<li><a href="https://github.com/InceptionCode/Functional-Programming-Exercises">Functional Programming Exercises</a></li>
</ul>
<h3><a class="header" href="#libraries" id="libraries">Libraries</a></h3>
<p>The code snippets in this book largely do not rely on libraries. Each operation
that we discover, we'll derive how to implement it in standalone, plain ol'
JavaScript. However, as you begin to build more of your real code with FP,
you'll soon want a library to provide optimized and highly reliable versions of
these commonly accepted utilities.</p>
<p>By the way, you need to check the documentation for the library functions you
use to ensure you know how they work. There will be a lot of similarities in
many of them to the code we build on in this text, but there will undoubtedly be
some differences, even between popular libraries.</p>
<p>Here are a few popular FP libraries for JavaScript that are a great place to
start your exploration with:</p>
<ul>
<li><a href="http://ramdajs.com">Ramda</a></li>
<li><a href="https://github.com/lodash/lodash/wiki/FP-Guide">lodash/fp</a></li>
<li><a href="http://functionaljs.com/">functional.js</a></li>
<li><a href="https://github.com/facebook/immutable-js">Immutable.js</a></li>
</ul>
<p><a href="apC.html">Appendix C takes a deeper look at these libraries</a>
and others.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>You may have a variety of reasons for starting to read this book, and different
expectations of what you'll get out of it. This chapter has explained why I want
you to read the book and what I want you to get out of the journey. It also
helps you articulate to others (like your fellow developers) why they should
come on the journey with you!</p>
<p>Functional programming is about writing code that is based on proven principles
so we can gain a level of confidence and trust over the code we write and read.
We shouldn't be content to write code that we anxiously <em>hope</em> works, and then
abruptly breathe a sigh of relief when the test suite passes. We should <em>know</em>
what it will do before we run it, and we should be absolutely confident that
we've communicated all these ideas in our code for the benefit of other readers
(including our future selves).</p>
<p>This is the heart of Functional-Light JavaScript. The goal is to learn to
effectively communicate with our code but not have to suffocate under mountains
of notation or terminology to get there.</p>
<p>The journey to learning functional programming starts with deeply understanding
the nature of what a function is. That's what we tackle in the next chapter.</p>
<hr />
<p><a name="footnote-1"><sup>1</sup></a>Buse, Raymond P. L., and Westley R. Weimer.
“Learning a Metric for Code Readability.” IEEE Transactions on Software
Engineering, IEEE Press, July 2010, dl.acm.org/citation.cfm?id=1850615.</p>
<h1><a class="header" href="#functional-light-javascript-3" id="functional-light-javascript-3">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-2-the-nature-of-functions" id="chapter-2-the-nature-of-functions">Chapter 2: The Nature Of Functions</a></h1>
<p>Functional Programming is <strong>not just programming with the <code>function</code> keyword.</strong>
Oh, if only it was that easy -- I could end the book right here! Nevertheless,
functions really <em>are</em> at the center of FP. And it's how we use functions that
makes our code <em>functional</em>.</p>
<p>But how sure are you that you know what <em>function</em> really means?</p>
<p>In this chapter, we're going to lay the groundwork for the rest of the book by
exploring all the foundational aspects of functions. Actually, this is a review
of all the things even a non-FP programmer should know about functions. But
certainly if we want to get the most out of FP concepts, it's essential we
<em>know</em> functions inside and out.</p>
<p>Brace yourself, because there's a lot more to the function than you may have
realized.</p>
<h2><a class="header" href="#what-is-a-function" id="what-is-a-function">What Is a Function?</a></h2>
<p>The question &quot;What is a function?&quot; superficially seems to have an obvious
answer: a function is a collection of code that can be executed one or more
times.</p>
<p>While this definition is reasonable, it's missing some very important essence
that is the core of a <em>function</em> as it applies to FP. So let's dig below the
surface to understand functions more completely.</p>
<h3><a class="header" href="#brief-math-review" id="brief-math-review">Brief Math Review</a></h3>
<p>I know I've promised we'd stay away from math as much as possible, but bear with
me for a moment as we quickly observe some fundamental things about functions
and graphs from algebra before we proceed.</p>
<p>Do you remember learning anything about <code>f(x)</code> back in school? What about the
equation <code>y = f(x)</code>?</p>
<p>Let's say an equation is defined like this: <code>f(x) = 2x<sup>2</sup> +
3</code>. What does that mean? What does it mean to graph that equation? Here's
the graph:</p>
<p align="center">
    <img alt="figure" src="images/fig1.png" width="40%">
</p>
<p>What you can notice is that for any value of <code>x</code>, say <code>2</code>, if you plug it into
the equation, you get <code>11</code>. What is <code>11</code>, though? It's the <em>return value</em> of the
<code>f(x)</code> function, which earlier we said represents a <code>y</code> value.</p>
<p>In other words, we can choose to interpret the input and output values as a
point at <code>(2,11)</code> on that curve in the graph. And for every value of <code>x</code> we plug
in, we get another <code>y</code> value that pairs with it as a coordinate for a point.
Another is <code>(0,3)</code>, and another is <code>(-1,5)</code>. Put all those points together, and
you have the graph of that parabolic curve as shown here.</p>
<p>So what's any of this got to do with FP?</p>
<p>In math, a function always takes input(s), and always gives an output. A term
you'll often hear around FP is &quot;morphism&quot;; this is a fancy way of describing a
set of values that maps to another set of values, like the inputs of a function
related to the outputs of that function.</p>
<p>In algebraic math, those inputs and outputs are often interpreted as components
of coordinates to be graphed. In our programs, however, we can define functions
with all sorts of input(s) and output(s), even though they'll rarely be
interpreted as a visually plotted curve on a graph.</p>
<h3><a class="header" href="#function-vs-procedure" id="function-vs-procedure">Function vs Procedure</a></h3>
<p>So why all the talk of math and graphs? Because essentially Functional
Programming is about embracing using functions as <em>functions</em> in this
mathematical sense.</p>
<p>You may be more accustomed to thinking of functions as procedures. What's the
difference? A procedure is an arbitrary collection of functionality. It may have
inputs, it may not. It may have an output (<code>return</code> value), it may not.</p>
<p>A function takes input(s) and definitely always has a <code>return</code> value.</p>
<p>If you plan to do Functional Programming, <strong>you should be using functions as
much as possible</strong>, and trying to avoid procedures wherever possible. All your
<code>function</code>s should take input(s) and return output(s).</p>
<p>Why? The answer to that will have many levels of meaning that we'll uncover
throughout this book.</p>
<h2><a class="header" href="#function-input" id="function-input">Function Input</a></h2>
<p>So far, we can conclude that functions must expect input. But let's dig into how
function inputs work.</p>
<p>You sometimes hear people refer to these inputs as &quot;arguments&quot; and sometimes as
&quot;parameters&quot;. So what's that all about?</p>
<p><em>Arguments</em> are the values you pass in, and <em>parameters</em> are the named variables
inside the function that receive those passed-in values. Example:</p>
<pre><code class="language-js">function foo(x, y) {
  // ..
}

var a = 3;

foo(a, a * 2);
</code></pre>
<p><code>a</code> and <code>a * 2</code> (actually, the result of <code>a * 2</code>, which is <code>6</code>) are the
<em>arguments</em> to the <code>foo(..)</code> call. <code>x</code> and <code>y</code> are the <em>parameters</em> that receive
the argument values (<code>3</code> and <code>6</code>, respectively).</p>
<p><strong>Note:</strong> In JavaScript, there's no requirement that the number of <em>arguments</em>
matches the number of <em>parameters</em>. If you pass more <em>arguments</em> than you have
declared <em>parameters</em> to receive them, the values pass in just fine untouched.
These values can be accessed in a few different ways, including the old-school
<code>arguments</code> object you may have heard of before. If you pass fewer <em>arguments</em>
than the declared <em>parameters</em>, each unmatched parameter is treated as an
&quot;undefined&quot; variable, meaning it's present and available in the scope of the
function, but just starts out with the empty <code>undefined</code> value.</p>
<h3><a class="header" href="#defaulting-parameters" id="defaulting-parameters">Defaulting Parameters</a></h3>
<p>As of ES6, parameters can declare <em>default values</em>. In the case where the
argument for that parameter is not passed, or it's passed the value <code>undefined</code>,
the default assignment expression is substituted.</p>
<p>Consider:</p>
<pre><code class="language-js">function foo(x = 3) {
  console.log(x);
}

foo(); // 3
foo(undefined); // 3
foo(null); // null
foo(0); // 0
</code></pre>
<p>It's always a good practice to think about any default cases that can aid the
usability of your functions. However, defaulting parameters can lead to more
complexity in terms of reading and understanding the variations of how a
function is called. Be judicious in how much you rely on this feature.</p>
<h3><a class="header" href="#counting-inputs" id="counting-inputs">Counting Inputs</a></h3>
<p>The number of arguments a function &quot;expects&quot; -- how many arguments you'll likely
want to pass to it -- is determined by the number of parameters that are
declared:</p>
<pre><code class="language-js">function foo(x, y, z) {
  // ..
}
</code></pre>
<p><code>foo(..)</code> <em>expects</em> three arguments, because it has three declared parameters.
This count has a special term: arity. Arity is the number of parameters in a
function declaration. The arity of <code>foo(..)</code> is <code>3</code>.</p>
<p>Furthermore, a function with arity 1 is also called &quot;unary&quot;, a function with
arity 2 is also called &quot;binary&quot;, and a function with arity 3 or higher is called
&quot;n-ary&quot;.</p>
<p>You may wish to inspect a function reference during the runtime of a program to
determine its arity. This can be done with the <code>length</code> property of that
function reference:</p>
<pre><code class="language-js">function foo(x, y, z) {
  // ..
}

foo.length; // 3
</code></pre>
<p>One reason for determining the arity during execution would be if a piece of
code received a function reference from multiple sources, and sent different
values depending on the arity of each.</p>
<p>For example, imagine a case where an <code>fn</code> function reference could expect one,
two, or three arguments, but you always want to just pass a variable <code>x</code> in the
last position:</p>
<pre><code class="language-js">// `fn` is set to some function reference
// `x` exists with some value

if (fn.length == 1) {
  fn(x);
} else if (fn.length == 2) {
  fn(undefined, x);
} else if (fn.length == 3) {
  fn(undefined, undefined, x);
}
</code></pre>
<p><strong>Tip:</strong> The <code>length</code> property of a function is read-only and it's determined at
the time you declare the function. It should be thought of as essentially a
piece of metadata that describes something about the intended usage of the
function.</p>
<p>One gotcha to be aware of is that certain kinds of parameter list variations can
make the <code>length</code> property of the function report something different than you
might expect:</p>
<pre><code class="language-js">function foo(x, y = 2) {
  // ..
}

function bar(x, ...args) {
  // ..
}

function baz({ a, b }) {
  // ..
}

foo.length; // 1
bar.length; // 1
baz.length; // 1
</code></pre>
<p>What about counting the number of arguments the current function call received?
This was once trivial, but now the situation is slightly more complicated. Each
function has an <code>arguments</code> object (array-like) available that holds a reference
to each of the arguments passed in. You can then inspect the <code>length</code> property
of <code>arguments</code> to figure out how many were actually passed:</p>
<pre><code class="language-js">function foo(x, y, z) {
  console.log(arguments.length);
}

foo(3, 4); // 2
</code></pre>
<p>As of ES5 (and strict mode, specifically), <code>arguments</code> is considered by some to
be sort of deprecated; many avoid using it if possible. In JS, we &quot;never&quot; break
backward compatibility no matter how helpful that may be for future progress, so
<code>arguments</code> will never be removed. But it's now commonly suggested that you
avoid using it whenever possible.</p>
<p>However, I suggest that <code>arguments.length</code>, and only that, is OK to keep using
for those cases where you need to care about the passed number of arguments. A
future version of JS might possibly add a feature that offers the ability to
determine the number of arguments passed without consulting <code>arguments.length</code>;
if that happens, then we can fully drop usage of <code>arguments</code>!</p>
<p>Be careful: <strong>never</strong> access arguments positionally, like <code>arguments[1]</code>. Stick
to <code>arguments.length</code> only, and only if you must.</p>
<p>Except, how will you access an argument that was passed in a position beyond the
declared parameters? I'll answer that in a moment; but first, take a step back
and ask yourself, &quot;Why would I want to do that?&quot; Seriously. Think about that
closely for a minute.</p>
<p>It should be pretty rare that this occurs; it shouldn't be something you
regularly expect or rely on when writing your functions. If you find yourself in
such a scenario, spend an extra 20 minutes trying to design the interaction with
that function in a different way. Name that extra argument even if it's
exceptional.</p>
<p>A function signature that accepts an indeterminate amount of arguments is
referred to as a variadic function. Some people prefer this style of function
design, but I think you'll find that often the FPer wants to avoid these where
possible.</p>
<p>OK, enough harping on that point.</p>
<p>Say you do need to access the arguments in a positional array-like way, possibly
because you're accessing an argument that doesn't have a formal parameter at
that position. How do we do it?</p>
<p>ES6 to the rescue! Let's declare our function with the <code>...</code> operator --
variously referred to as &quot;spread&quot;, &quot;rest&quot;, or (my preference) &quot;gather&quot;:</p>
<pre><code class="language-js">function foo(x, y, z, ...args) {
  // ..
}
</code></pre>
<p>See the <code>...args</code> in the parameter list? That's an ES6 declarative form that
tells the engine to collect (ahem, &quot;gather&quot;) all remaining arguments (if any)
not assigned to named parameters, and put them in a real array named <code>args</code>.
<code>args</code> will always be an array, even if it's empty. But it <strong>will not</strong> include
values that are assigned to the <code>x</code>, <code>y</code>, and <code>z</code> parameters, only anything else
that's passed in beyond those first three values:</p>
<pre><code class="language-js">function foo(x, y, z, ...args) {
  console.log(x, y, z, args);
}

foo(); // undefined undefined undefined []
foo(1, 2, 3); // 1 2 3 []
foo(1, 2, 3, 4); // 1 2 3 [ 4 ]
foo(1, 2, 3, 4, 5); // 1 2 3 [ 4, 5 ]
</code></pre>
<p>So, if you <em>really</em> want to design a function that can account for an arbitrary
number of arguments to be passed in, use <code>...args</code> (or whatever name you like)
on the end. Now, you'll have a real, non-deprecated, non-yucky array to access
those argument values from.</p>
<p>Just pay attention to the fact that the value <code>4</code> is at position <code>0</code> of that
<code>args</code>, not position <code>3</code>. And its <code>length</code> value won't include those three <code>1</code>,
<code>2</code>, and <code>3</code> values. <code>...args</code> gathers everything else, not including the <code>x</code>,
<code>y</code>, and <code>z</code>.</p>
<p>You <em>can</em> use the <code>...</code> operator in the parameter list even if there's no other
formal parameters declared:</p>
<pre><code class="language-js">function foo(...args) {
  // ..
}
</code></pre>
<p>Now <code>args</code> will be the full array of arguments, whatever they are, and you can
use <code>args.length</code> to know exactly how many arguments have been passed in. And
you're safe to use <code>args[1]</code> or <code>args[317]</code> if you so choose. Please don't pass
in 318 arguments, though.</p>
<h3><a class="header" href="#arrays-of-arguments" id="arrays-of-arguments">Arrays of Arguments</a></h3>
<p>What if you wanted to pass along an array of values as the arguments to a
function call?</p>
<pre><code class="language-js">function foo(...args) {
  console.log(args[3]);
}

var arr = [1, 2, 3, 4, 5];

foo(...arr); // 4
</code></pre>
<p>Our new friend <code>...</code> is used, but now not just in the parameter list; it's also
used in the argument list at the call-site. It has the opposite behavior in this
context. In a parameter list, we said it <em>gathered</em> arguments together. In an
argument list, it <em>spreads</em> them out. So the contents of <code>arr</code> are actually
spread out as individual arguments to the <code>foo(..)</code> call. Do you see how that's
different from just passing in a reference to the whole <code>arr</code> array?</p>
<p>By the way, multiple values and <code>...</code> spreadings can be interleaved, as you see
fit:</p>
<pre><code class="language-js">var arr = [2];

foo(1, ...arr, 3, ...[4, 5]); // 4
</code></pre>
<p>Think of <code>...</code> in this symmetric sense: in a value-list position, it <em>spreads</em>.
In an assignment position -- like a parameter list, because arguments get
<em>assigned to</em> parameters -- it <em>gathers</em>.</p>
<p>Whichever behavior you invoke, <code>...</code> makes working with arrays of arguments much
easier. Gone are the days of <code>slice(..)</code>, <code>concat(..)</code>, and <code>apply(..)</code> to
wrangle our argument value arrays.</p>
<p><strong>Tip:</strong> Actually, these methods are not entirely useless. There will be a few
places we rely on them throughout the code in this book. But certainly in most
places, <code>...</code> will be much more declaratively readable, and preferable as a
result.</p>
<h3><a class="header" href="#parameter-destructuring" id="parameter-destructuring">Parameter Destructuring</a></h3>
<p>Consider the variadic <code>foo(..)</code> from the previous section:</p>
<pre><code class="language-js">function foo(...args) {
  // ..
}

foo(...[1, 2, 3]);
</code></pre>
<p>What if we wanted to change that interaction so the caller of our function
passes in an array of values instead of individual argument values? Just drop
the two <code>...</code> usages:</p>
<pre><code class="language-js">function foo(args) {
  // ..
}

foo([1, 2, 3]);
</code></pre>
<p>Simple enough. But what if now we wanted to give a parameter name to each of the
first two values in the passed-in array? We aren't declaring individual
parameters anymore, so it seems we lost that ability.</p>
<p>Thankfully, ES6 destructuring is the answer. Destructuring is a way to declare a
<em>pattern</em> for the kind of structure (object, array, etc.) that you expect to
see, and how decomposition (assignment) of its individual parts should be
processed.</p>
<p>Consider:</p>
<p><a name="funcparamdestr"></a></p>
<pre><code class="language-js">function foo([x, y, ...args] = []) {
  // ..
}

foo([1, 2, 3]);
</code></pre>
<p>Do you spot the <code>[ .. ]</code> brackets around the parameter list now? This is called
array parameter destructuring.</p>
<p>In this example, destructuring tells the engine that an array is expected in
this assignment position (aka parameter). The pattern says to take the first
value of that array and assign to a local parameter variable called <code>x</code>, the
second to <code>y</code>, and whatever is left is <em>gathered</em> into <code>args</code>.</p>
<h3><a class="header" href="#the-importance-of-declarative-style" id="the-importance-of-declarative-style">The Importance of Declarative Style</a></h3>
<p>Considering the destructured <code>foo(..)</code> we just looked at, we could instead have
processed the parameters manually:</p>
<pre><code class="language-js">function foo(params) {
  var x = params[0];
  var y = params[1];
  var args = params.slice(2);

  // ..
}
</code></pre>
<p>But here we highlight a principle we only briefly introduced in
<a href="chapter_1.html">Chapter 1</a>: declarative code communicates more
effectively than imperative code.</p>
<p>Declarative code (for example, the destructuring in the former <code>foo(..)</code>
snippet, or the <code>...</code> operator usages) focuses on what the outcome of a piece of
code should be.</p>
<p>Imperative code (such as the manual assignments in the latter snippet) focuses
more on how to get the outcome. If you later read such imperative code, you have
to mentally execute all of it to understand the desired outcome. The outcome is
<em>coded</em> there, but it's not as clear because it's clouded by the details of
<em>how</em> we get there.</p>
<p>The earlier <code>foo(..)</code> is regarded as more readable, because the destructuring
hides the unnecessary details of <em>how</em> to manage the parameter inputs; the
reader is free to focus only on <em>what</em> we will do with those parameters. That's
clearly the most important concern, so it's what the reader should be focused on
to understand the code most completely.</p>
<p>Wherever possible, and to whatever degrees our language and our
libraries/frameworks will let us, <strong>we should be striving for declarative,
self-explanatory code.</strong></p>
<h2><a class="header" href="#named-arguments" id="named-arguments">Named Arguments</a></h2>
<p>Just as we can destructure array parameters, we can destructure object
parameters:</p>
<pre><code class="language-js">function foo({ x, y } = {}) {
  console.log(x, y);
}

foo({
  y: 3
}); // undefined 3
</code></pre>
<p>We pass in an object as the single argument, and it's destructured into two
separate parameter variables <code>x</code> and <code>y</code>, which are assigned the values of those
corresponding property names from the object passed in. It didn't matter that
the <code>x</code> property wasn't on the object; it just ended up as a variable with
<code>undefined</code> like you'd expect.</p>
<p>But the part of parameter object destructuring I want you to pay attention to is
the object being passed into <code>foo(..)</code>.</p>
<p>With a normal call-site like <code>foo(undefined,3)</code>, position is used to map from
argument to parameter; we put the <code>3</code> in the second position to get it assigned
to a <code>y</code> parameter. But at this new kind of call-site where parameter
destructuring is involved, a simple object-property indicates which parameter
(<code>y</code>) the argument value <code>3</code> should be assigned to.</p>
<p>We didn't have to account for <code>x</code> in <em>that</em> call-site because in effect we
didn't care about <code>x</code>. We just omitted it, instead of having to do something
distracting like passing <code>undefined</code> as a positional placeholder.</p>
<p>Some languages have an explicit feature for this: named arguments. In other
words, at the call-site, labeling an input value to indicate which parameter it
maps to. JavaScript doesn't have named arguments, but parameter object
destructuring is the next best thing.</p>
<p>Another FP-related benefit of using an object destructuring to pass in
potentially multiple arguments is that a function that only takes one parameter
(the object) is much easier to compose with another function's single output.
Much more on that in <a href="chapter_4.html">Chapter 4</a>.</p>
<h3><a class="header" href="#unordered-parameters" id="unordered-parameters">Unordered Parameters</a></h3>
<p>Another key benefit is that named arguments, by virtue of being specified as
object properties, are not fundamentally ordered. That means we can specify
inputs in whatever order we want:</p>
<pre><code class="language-js">function foo({ x, y } = {}) {
  console.log(x, y);
}

foo({
  y: 3
}); // undefined 3
</code></pre>
<p>We're skipping the <code>x</code> parameter by simply omitting it. Or we could specify an
<code>x</code> argument if we cared to, even if we listed it after <code>y</code> in the object
literal. The call-site is no longer cluttered by ordered-placeholders like
<code>undefined</code> to skip a parameter.</p>
<p>Named arguments are much more flexible, and attractive from a readability
perspective, especially when the function in question can take three, four, or
more inputs.</p>
<p><strong>Tip:</strong> If this style of function arguments seems useful or interesting to you,
check out coverage of my <a href="apC.html">FPO library in Appendix C</a>.</p>
<h2><a class="header" href="#function-output" id="function-output">Function Output</a></h2>
<p>Let's shift our attention from a function's inputs to its output.</p>
<p>In JavaScript, functions always return a value. These three functions all have
identical <code>return</code> behavior:</p>
<pre><code class="language-js">function foo() {}

function bar() {
  return;
}

function baz() {
  return undefined;
}
</code></pre>
<p>The <code>undefined</code> value is implicitly <code>return</code>ed if you have no <code>return</code> or if you
just have an empty <code>return;</code>.</p>
<p>But keeping as much with the spirit of FP function definition as possible --
using functions and not procedures -- our functions should always have outputs,
which means they should explicitly <code>return</code> a value, and usually not
<code>undefined</code>.</p>
<p>A <code>return</code> statement can only return a single value. So if your function needs
to return multiple values, your only viable option is to collect them into a
compound value like an array or an object:</p>
<pre><code class="language-js">function foo() {
  var retValue1 = 11;
  var retValue2 = 31;
  return [retValue1, retValue2];
}
</code></pre>
<p>Then, we'll assign <code>x</code> and <code>y</code> from two respective items in the array that comes
back from <code>foo()</code>:</p>
<pre><code class="language-js">var [x, y] = foo();
console.log(x + y); // 42
</code></pre>
<p>Collecting multiple values into an array (or object) to return, and subsequently
destructuring those values back into distinct assignments, is a way to
transparently express multiple outputs for a function.</p>
<p><strong>Tip:</strong> I'd be remiss if I didn't suggest you take a moment to consider if a
function needing multiple outputs could be refactored to avoid that, perhaps
separated into two or more smaller single-purpose functions? Sometimes that will
be possible, sometimes not; but you should at least consider it.</p>
<h3><a class="header" href="#early-returns" id="early-returns">Early Returns</a></h3>
<p>The <code>return</code> statement doesn't just return a value from a function. It's also a
flow control structure; it ends the execution of the function at that point. A
function with multiple <code>return</code> statements thus has multiple possible exit
points, meaning that it may be harder to read a function to understand its
output behavior if there are many paths that could produce that output.</p>
<p>Consider:</p>
<pre><code class="language-js">function foo(x) {
  if (x &gt; 10) return x + 1;

  var y = x / 2;

  if (y &gt; 3) {
    if (x % 2 == 0) return x;
  }

  if (y &gt; 1) return y;

  return x;
}
</code></pre>
<p>Pop quiz: without cheating and running this code in your browser, what does
<code>foo(2)</code> return? What about <code>foo(4)</code>? And <code>foo(8)</code>? And <code>foo(12)</code>?</p>
<p>How confident are you in your answers? How much mental tax did you pay to get
those answers? I got it wrong the first two times I tried to think it through,
and I wrote it!</p>
<p>I think part of the readability problem here is that we're using <code>return</code> not
just to return different values, but also as a flow control construct to quit a
function's execution early in certain cases. There are obviously better ways to
write that flow control (the <code>if</code> logic, etc.), but I also think there are ways
to make the output paths more obvious.</p>
<p><strong>Note:</strong> The answers to the pop quiz are <code>2</code>, <code>2</code>, <code>8</code>, and <code>13</code>.</p>
<p>Consider this version of the code:</p>
<pre><code class="language-js">function foo(x) {
  var retValue;

  if (retValue == undefined &amp;&amp; x &gt; 10) {
    retValue = x + 1;
  }

  var y = x / 2;

  if (y &gt; 3) {
    if (retValue == undefined &amp;&amp; x % 2 == 0) {
      retValue = x;
    }
  }

  if (retValue == undefined &amp;&amp; y &gt; 1) {
    retValue = y;
  }

  if (retValue == undefined) {
    retValue = x;
  }

  return retValue;
}
</code></pre>
<p>This version is unquestionably more verbose. But I would argue it's slightly
simpler logic to follow, because every branch where <code>retValue</code> can get set is
<em>guarded</em> by the condition that checks if it's already been set.</p>
<p>Rather than <code>return</code>ing from the function early, we used normal flow control
(<code>if</code> logic) to determine the <code>retValue</code>'s assignment. At the end, we simply
<code>return retValue</code>.</p>
<p>I'm not unconditionally saying that you should always have a single <code>return</code>, or
that you should never do early <code>return</code>s, but I do think you should be careful
about the flow control part of <code>return</code> creating more implicitness in your
function definitions. Try to figure out the most explicit way to express the
logic; that will often be the best way.</p>
<h3><a class="header" href="#unreturned-outputs" id="unreturned-outputs">Un<code>return</code>ed Outputs</a></h3>
<p>One technique that you've probably used in most code you've written, and maybe
didn't even think about it much, is to have a function output some or all of its
values by simply changing variables outside itself.</p>
<p>Remember our <code>f(x) = 2x<sup>2</sup> + 3</code> function from earlier in the
chapter? We could have defined it like this in JS:</p>
<pre><code class="language-js">var y;

function f(x) {
  y = 2 * Math.pow(x, 2) + 3;
}

f(2);

y; // 11
</code></pre>
<p>I know this is a silly example; we could just as easily have <code>return</code>d the value
instead of setting it into <code>y</code> from within the function:</p>
<pre><code class="language-js">function f(x) {
  return 2 * Math.pow(x, 2) + 3;
}

var y = f(2);

y; // 11
</code></pre>
<p>Both functions accomplish the same task, so is there any reason we should pick
one version over the other? <strong>Yes, absolutely.</strong></p>
<p>One way to explain the difference is that the <code>return</code> in the latter version
signals an explicit output, whereas the <code>y</code> assignment in the former is an
implicit output. You may already have some intuition that guides you in such
cases; typically, developers prefer explicit patterns over implicit ones.</p>
<p>But changing a variable in an outer scope, as we did with the <code>y</code> assignment
inside of <code>foo(..)</code>, is just one way of achieving an implicit output. A more
subtle example is making changes to non-local values via reference.</p>
<p>Consider:</p>
<pre><code class="language-js">function sum(list) {
  var total = 0;
  for (let i = 0; i &lt; list.length; i++) {
    if (!list[i]) list[i] = 0;

    total = total + list[i];
  }

  return total;
}

var nums = [1, 3, 9, 27, , 84];

sum(nums); // 124
</code></pre>
<p>The most obvious output from this function is the sum <code>124</code>, which we explicitly
<code>return</code>ed. But do you spot the other output? Try that code and then inspect the
<code>nums</code> array. Now do you spot the difference?</p>
<p>Instead of an <code>undefined</code> empty slot value in position <code>4</code>, now there's a <code>0</code>.
The harmless looking <code>list[i] = 0</code> operation ended up affecting the array value
on the outside, even though we operated on a local <code>list</code> parameter variable.</p>
<p>Why? Because <code>list</code> holds a reference-copy of the <code>nums</code> reference, not a
value-copy of the <code>[1,3,9,..]</code> array value. JavaScript uses references and
reference-copies for arrays, objects, and functions, so we may create an
accidental output from our function all too easily.</p>
<p>This implicit function output has a special name in the FP world: side effects.
And a function that has <em>no side effects</em> also has a special name: pure
function. We'll talk a lot more about these in <a href="chapter_5.html">Chapter 5</a>, but
the punchline is that we'll want to prefer pure functions and avoid side effects
wherever possible.</p>
<h2><a class="header" href="#functions-of-functions" id="functions-of-functions">Functions of Functions</a></h2>
<p>Functions can receive and return values of any type. A function that receives or
returns one or more other function values has the special name: higher-order
function.</p>
<p>Consider:</p>
<pre><code class="language-js">function forEach(list, fn) {
  for (let v of list) {
    fn(v);
  }
}

forEach([1, 2, 3, 4, 5], function each(val) {
  console.log(val);
});
// 1 2 3 4 5
</code></pre>
<p><code>forEach(..)</code> is a higher-order function because it receives a function as an
argument.</p>
<p>A higher-order function can also output another function, like:</p>
<pre><code class="language-js">function foo() {
  return function inner(msg) {
    return msg.toUpperCase();
  };
}

var f = foo();

f(&quot;Hello!&quot;); // HELLO!
</code></pre>
<p><code>return</code> is not the only way to &quot;output&quot; an inner function:</p>
<pre><code class="language-js">function foo() {
  return bar(function inner(msg) {
    return msg.toUpperCase();
  });
}

function bar(func) {
  return func(&quot;Hello!&quot;);
}

foo(); // HELLO!
</code></pre>
<p>Functions that treat other functions as values are higher-order functions by
definition. FPers write these all the time!</p>
<h3><a class="header" href="#keeping-scope" id="keeping-scope">Keeping Scope</a></h3>
<p>One of the most powerful things in all of programming, and especially in FP, is
how a function behaves when it's inside another function's scope. When the inner
function makes reference to a variable from the outer function, this is called
closure.</p>
<p>Defined pragmatically:</p>
<blockquote>
<p>Closure is when a function remembers and accesses variables from outside of
its own scope, even when that function is executed in a different scope.</p>
</blockquote>
<p>Consider:</p>
<pre><code class="language-js">function foo(msg) {
  var fn = function inner() {
    return msg.toUpperCase();
  };

  return fn;
}

var helloFn = foo(&quot;Hello!&quot;);

helloFn(); // HELLO!
</code></pre>
<p>The <code>msg</code> parameter variable in the scope of <code>foo(..)</code> is referenced inside the
inner function. When <code>foo(..)</code> is executed and the inner function is created, it
captures the access to the <code>msg</code> variable, and retains that access even after
being <code>return</code>ed.</p>
<p>Once we have <code>helloFn</code>, a reference to the inner function, <code>foo(..)</code> has
finished and it would seem as if its scope should have gone away, meaning the
<code>msg</code> variable would no longer exist. But that doesn't happen, because the inner
function has a closure over <code>msg</code> that keeps it alive. The closed over <code>msg</code>
variable survives for as long as the inner function (now referenced by <code>helloFn</code>
in a different scope) stays around.</p>
<p>Let's look at a few more examples of closure in action:</p>
<pre><code class="language-js">function person(name) {
  return function identify() {
    console.log(`I am ${name}`);
  };
}

var fred = person(&quot;Fred&quot;);
var susan = person(&quot;Susan&quot;);

fred(); // I am Fred
susan(); // I am Susan
</code></pre>
<p>The inner function <code>identify()</code> has closure over the parameter <code>name</code>.</p>
<p>The access that closure enables is not restricted to merely reading the
variable's original value -- it's not just a snapshot but rather a live link.
You can update the value, and that new current state remains remembered until
the next access:</p>
<pre><code class="language-js">function runningCounter(start) {
  var val = start;

  return function current(increment = 1) {
    val = val + increment;
    return val;
  };
}

var score = runningCounter(0);

score(); // 1
score(); // 2
score(13); // 15
</code></pre>
<p><strong>Warning:</strong> For reasons that we'll explore in more depth later in the book,
this example of using closure to remember a state that changes (<code>val</code>) is
probably something you'll want to avoid where possible.</p>
<p>If you have an operation that needs two inputs, one of which you know now but
the other will be specified later, you can use closure to remember the first
input:</p>
<pre><code class="language-js">function makeAdder(x) {
  return function sum(y) {
    return x + y;
  };
}

// we already know `10` and `37` as first inputs, respectively
var addTo10 = makeAdder(10);
var addTo37 = makeAdder(37);

// later, we specify the second inputs
addTo10(3); // 13
addTo10(90); // 100

addTo37(13); // 50
</code></pre>
<p>Normally, a <code>sum(..)</code> function would take both an <code>x</code> and <code>y</code> input to add them
together. But in this example we receive and remember (via closure) the <code>x</code>
value(s) first, while the <code>y</code> value(s) are separately specified later.</p>
<p><strong>Note:</strong> This technique of specifying inputs in successive function calls is
very common in FP, and comes in two forms: partial application and currying.
We'll dive into them more thoroughly in
<a href="chapter_3.html">Chapter 3</a>.</p>
<p>Of course, since functions are just values in JS, we can remember function
values via closure:</p>
<pre><code class="language-js">function formatter(formatFn) {
  return function inner(str) {
    return formatFn(str);
  };
}

var lower = formatter(function formatting(v) {
  return v.toLowerCase();
});

var upperFirst = formatter(function formatting(v) {
  return v[0].toUpperCase() + v.substr(1).toLowerCase();
});

lower(&quot;WOW&quot;); // wow
upperFirst(&quot;hello&quot;); // Hello
</code></pre>
<p>Instead of distributing/repeating the <code>toUpperCase()</code> and <code>toLowerCase()</code> logic
all over our code, FP encourages us to create simple functions that encapsulate
-- a fancy way of saying wrapping up -- that behavior.</p>
<p>Specifically, we create two simple unary functions <code>lower(..)</code> and
<code>upperFirst(..)</code>, because those functions will be much easier to wire up to work
with other functions in the rest of our program.</p>
<p><strong>Tip:</strong> Did you spot how <code>upperFirst(..)</code> could have used <code>lower(..)</code>?</p>
<p>We'll use closure heavily throughout the rest of the text. It may just be the
most important foundational practice in all of FP, if not programming as a
whole. Make sure you're really comfortable with it!</p>
<h2><a class="header" href="#syntax" id="syntax">Syntax</a></h2>
<p>Before we move on from this primer on functions, let's take a moment to discuss
their syntax.</p>
<p>More than many other parts of this text, the discussions in this section are
mostly opinion and preference, whether you agree with the views presented here
or take opposite ones. These ideas are highly subjective, though many people
seem to feel rather absolutely about them.</p>
<p>Ultimately, you get to decide.</p>
<h3><a class="header" href="#whats-in-a-name" id="whats-in-a-name">What's in a Name?</a></h3>
<p>Syntactically speaking, function declarations require the inclusion of a name:</p>
<pre><code class="language-js">function helloMyNameIs() {
  // ..
}
</code></pre>
<p>But function expressions can come in both named and anonymous forms:</p>
<pre><code class="language-js">foo(function namedFunctionExpr() {
  // ..
});

bar(function() {
  // &lt;-- look, no name!
  // ..
});
</code></pre>
<p>What exactly do we mean by anonymous, by the way? Specifically, functions have a
<code>name</code> property that holds the string value of the name the function was given
syntactically, such as <code>&quot;helloMyNameIs&quot;</code> or <code>&quot;namedFunctionExpr&quot;</code>. This <code>name</code>
property is most notably used by the console/developer tools of your JS
environment to list the function when it participates in a stack trace (usually
from an exception).</p>
<p>Anonymous functions are generally displayed as <code>(anonymous function)</code>.</p>
<p>If you've ever had to debug a JS program from nothing but a stack trace of an
exception, you probably have felt the pain of seeing <code>(anonymous function)</code>
appear line after line. This listing doesn't give a developer any clue
whatsoever as to the path the exception came from. It's not doing the developer
any favors.</p>
<p>If you name your function expressions, the name is always used. So if you use a
good name like <code>handleProfileClicks</code> instead of <code>foo</code>, you'll get much more
helpful stack traces.</p>
<p>As of ES6, anonymous function expressions are in certain cases aided by <em>name
inferencing</em>. Consider:</p>
<pre><code class="language-js">var x = function() {};

x.name; // x
</code></pre>
<p>If the engine is able to guess what name you <em>probably</em> want the function to
take, it will go ahead and do so.</p>
<p>But beware, not all syntactic forms benefit from name inferencing. Probably the
most common place a function expression shows up is as an argument to a function
call:</p>
<pre><code class="language-js">function foo(fn) {
  console.log(fn.name);
}

var x = function() {};

foo(x); // x
foo(function() {}); //
</code></pre>
<p>When the name can't be inferred from the immediate surrounding syntax, it
remains an empty string. Such a function will be reported as
<code>(anonymous function)</code> in a stack trace should one occur.</p>
<p>There are other benefits to a function being named besides the debugging
question. First, the syntactic name (aka lexical name) is useful for internal
self-reference. Self-reference is necessary for recursion (both sync and async)
and also helpful with event handlers.</p>
<p>Consider these different scenarios:</p>
<pre><code class="language-js">// sync recursion:
function findPropIn(propName, obj) {
  if (obj == undefined || typeof obj != &quot;object&quot;) return;

  if (propName in obj) {
    return obj[propName];
  } else {
    for (let prop of Object.keys(obj)) {
      let ret = findPropIn(propName, obj[prop]);
      if (ret !== undefined) {
        return ret;
      }
    }
  }
}
</code></pre>
<pre><code class="language-js">// async recursion:
setTimeout(function waitForIt() {
  // does `it` exist yet?
  if (!o.it) {
    // try again later
    setTimeout(waitForIt, 100);
  }
}, 100);
</code></pre>
<pre><code class="language-js">// event handler unbinding
document.getElementById(&quot;onceBtn&quot;).addEventListener(
  &quot;click&quot;,
  function handleClick(evt) {
    // unbind event
    evt.target.removeEventListener(&quot;click&quot;, handleClick, false);

    // ..
  },
  false
);
</code></pre>
<p>In all these cases, the named function's lexical name was a useful and reliable
self-reference from inside itself.</p>
<p>Moreover, even in simple cases with one-liner functions, naming them tends to
make code more self-explanatory and thus easier to read for those who haven't
read it before:</p>
<pre><code class="language-js">people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});
// ..
</code></pre>
<p>The function name <code>getPreferredName(..)</code> tells the reader something about what
the mapping operation is intending to do that is not entirely obvious from just
its code. This name label helps the code be more readable.</p>
<p>Another place where anonymous function expressions are common is with
immediately invoked function expressions (IIFEs):</p>
<pre><code class="language-js">(function() {
  // look, I'm an IIFE!
})();
</code></pre>
<p>You virtually never see IIFEs using names for their function expressions, but
they should. Why? For all the same reasons we just went over: stack trace
debugging, reliable self-reference, and readability. If you can't come up with
any other name for your IIFE, at least use the word IIFE:</p>
<pre><code class="language-js">(function IIFE() {
  // You already knew I was an IIFE!
})();
</code></pre>
<p>What I'm getting at is there are multiple reasons why <strong>named functions are
always more preferable to anonymous functions.</strong> As a matter of fact, I'd go so
far as to say that there's basically never a case where an anonymous function is
more preferable. They just don't really have any advantage over their named
counterparts.</p>
<p>It's incredibly easy to write anonymous functions, because it's one less name we
have to devote our mental attention to figuring out.</p>
<p>I'll be honest; I'm as guilty of this as anyone. I don't like to struggle with
naming. The first few names I come up with for a function are usually bad. I
have to revisit the naming over and over. I'd much rather just punt with a good
ol' anonymous function expression.</p>
<p>But we're trading ease-of-writing for pain-of-reading. This is not a good
trade-off. Being lazy or uncreative enough to not want to figure out names for
your functions is an all too common, but poor, excuse for using anonymous
functions.</p>
<p><strong>Name every single function.</strong> And if you sit there stumped, unable to come up
with a good name for some function you've written, I'd strongly suggest you
don't fully understand that function's purpose yet -- or it's just too broad or
abstract. You need to go back and re-design the function until this is more
clear. And by that point, a name will become more apparent.</p>
<p>In my practice, if I don't have a good name to use for a function, I name it
<code>TODO</code> initially. I'm certain that I'll at least catch that later when I search
for &quot;TODO&quot; comments before committing code.</p>
<p>I can testify from my own experience that in the struggle to name something
well, I usually have come to understand it better, later, and often even
refactor its design for improved readability and maintainability.</p>
<p>This time investment is well worth it.</p>
<h3><a class="header" href="#functions-without-function" id="functions-without-function">Functions Without <code>function</code></a></h3>
<p>So far we've been using the full canonical syntax for functions. But you've no
doubt also heard all the buzz around the ES6 <code>=&gt;</code> arrow function syntax.</p>
<p>Compare:</p>
<pre><code class="language-js">people.map(function getPreferredName(person) {
  return person.nicknames[0] || person.firstName;
});

// vs.

people.map(person =&gt; person.nicknames[0] || person.firstName);
</code></pre>
<p>Whoa.</p>
<p>The keyword <code>function</code> is gone, so is <code>return</code>, the parentheses (<code>( )</code>), the
curly braces (<code>{ }</code>), and the innermost semicolon (<code>;</code>). In place of all that,
we used a so-called fat arrow symbol (<code>=&gt;</code>).</p>
<p>But there's another thing we omitted. Did you spot it? The <code>getPreferredName</code>
function name.</p>
<p>That's right; <code>=&gt;</code> arrow functions are lexically anonymous; there's no way to
syntactically provide it a name. Their names can be inferred like regular
functions, but again, the most common case of function expression values passed
as arguments won't get any assistance in that way. Bummer.</p>
<p>If <code>person.nicknames</code> isn't defined for some reason, an exception will be
thrown, meaning this <code>(anonymous function)</code> will be at the top of the stack
trace. Ugh.</p>
<p>Honestly, the anonymity of <code>=&gt;</code> arrow functions is a <code>=&gt;</code> dagger to the heart,
for me. I cannot abide by the loss of naming. It's harder to read, harder to
debug, and impossible to self-reference.</p>
<p>But if that wasn't bad enough, the other slap in the face is that there's a
whole bunch of subtle syntactic variations that you must wade through if you
have different scenarios for your function definition. I'm not going to cover
all of them in detail here, but briefly:</p>
<pre><code class="language-js">people.map(person =&gt; person.nicknames[0] || person.firstName);

// multiple parameters? need ( )
people.map((person, idx) =&gt; person.nicknames[0] || person.firstName);

// parameter destructuring? need ( )
people.map(({ person }) =&gt; person.nicknames[0] || person.firstName);

// parameter default? need ( )
people.map((person = {}) =&gt; person.nicknames[0] || person.firstName);

// returning an object? need ( )
people.map(person =&gt; ({
  preferredName: person.nicknames[0] || person.firstName
}));
</code></pre>
<p>The case for excitement over <code>=&gt;</code> in the FP world is primarily that it follows
almost exactly from the mathematical notation for functions, especially in FP
languages like Haskell. The shape of <code>=&gt;</code> arrow function syntax communicates
mathematically.</p>
<p>Digging even further, I'd suggest that the argument in favor of <code>=&gt;</code> is that by
using much lighter-weight syntax, we reduce the visual boundaries between
functions which lets us use simple function expressions much like we'd use lazy
expressions -- another favorite of the FPer.</p>
<p>I think most FPers are going to wave off the concerns I'm sharing. They love
anonymous functions and they love saving on syntax. But like I said before: you
decide.</p>
<p><strong>Note:</strong> Though I do not prefer to use <code>=&gt;</code> in practice in my production code,
they are useful in quick code explorations. Moreover, we will use arrow
functions in many places throughout the rest of this book -- especially when we
present typical FP utilities -- where conciseness is preferred to optimize for
the limited physical space in code snippets. Make your own determinations
whether this approach will make your own production-ready code more or less
readable.</p>
<h2><a class="header" href="#whats-this" id="whats-this">What's This?</a></h2>
<p>If you're not familiar with the <code>this</code> binding rules in JavaScript, I recommend
checking out my book <em>You Don't Know JS: this &amp; Object Prototypes</em>. For the
purposes of this section, I'll assume you know how <code>this</code> gets determined for a
function call (one of the four rules). But even if you're still fuzzy on <em>this</em>,
the good news is we're going to conclude that you shouldn't be using <code>this</code> if
you're trying to do FP.</p>
<p><strong>Note:</strong> We're tackling a topic that we'll ultimately conclude we shouldn't
use. Why!? Because the topic of <code>this</code> has implications for other topics covered
later in this book. For example, our notions of function purity are impacted by
<code>this</code> being essentially an implicit input to a function (see
<a href="chapter_5.html">Chapter 5</a>). Additionally, our perspective on <code>this</code> affects
whether we choose array methods (<code>arr.map(..)</code>) versus standalone utilities
(<code>map(..,arr)</code>) (see <a href="chapter_9.html">Chapter 9</a>). Understanding <code>this</code> is
essential to understanding why <code>this</code> really should <em>not</em> be part of your FP!</p>
<p>JavaScript <code>function</code>s have a <code>this</code> keyword that's automatically bound per
function call. The <code>this</code> keyword can be described in many different ways, but I
prefer to say it provides an object context for the function to run against.</p>
<p><code>this</code> is an implicit parameter input for your function.</p>
<p>Consider:</p>
<pre><code class="language-js">function sum() {
  return this.x + this.y;
}

var context = {
  x: 1,
  y: 2
};

sum.call(context); // 3

context.sum = sum;
context.sum(); // 3

var s = sum.bind(context);
s(); // 3
</code></pre>
<p>Of course, if <code>this</code> can be input into a function implicitly, the same object
context could be sent in as an explicit argument:</p>
<pre><code class="language-js">function sum(ctx) {
  return ctx.x + ctx.y;
}

var context = {
  x: 1,
  y: 2
};

sum(context);
</code></pre>
<p>Simpler. And this kind of code will be a lot easier to deal with in FP. It's
much easier to wire multiple functions together, or use any of the other input
wrangling techniques we will get into in the next chapter, when inputs are
always explicit. Doing them with implicit inputs like <code>this</code> ranges from awkward
to nearly impossible depending on the scenario.</p>
<p>There are other tricks we can leverage in a <code>this</code>-based system, including
prototype-delegation (also covered in detail in <em>You Don't Know JS: this &amp;
Object Prototypes</em>):</p>
<pre><code class="language-js">var Auth = {
  authorize() {
    var credentials = `${this.username}:${this.password}`;
    this.send(credentials, resp =&gt; {
      if (resp.error) this.displayError(resp.error);
      else this.displaySuccess();
    });
  },
  send(/* .. */) {
    // ..
  }
};

var Login = Object.assign(Object.create(Auth), {
  doLogin(user, pw) {
    this.username = user;
    this.password = pw;
    this.authorize();
  },
  displayError(err) {
    // ..
  },
  displaySuccess() {
    // ..
  }
});

Login.doLogin(&quot;fred&quot;, &quot;123456&quot;);
</code></pre>
<p><strong>Note:</strong> <code>Object.assign(..)</code> is an ES6+ utility for doing a shallow assignment
copy of properties from one or more source objects to a single target object:
<code>Object.assign( target, source1, ... )</code>.</p>
<p>In case you're having trouble parsing what this code does: we have two separate
objects <code>Login</code> and <code>Auth</code>, where <code>Login</code> performs prototype-delegation to
<code>Auth</code>. Through delegation and the implicit <code>this</code> context sharing, these two
objects virtually compose during the <code>this.authorize()</code> function call, so that
properties/methods on <code>this</code> are dynamically shared with the
<code>Auth.authorize(..)</code> function.</p>
<p><em>This</em> code doesn't fit with various principles of FP for a variety of reasons,
but one of the obvious hitches is the implicit <code>this</code> sharing. We could be more
explicit about it and keep code closer to FP-friendly style:</p>
<pre><code class="language-js">// ..

authorize(ctx) {
    var credentials = `${ctx.username}:${ctx.password}`;
    Auth.send( credentials, function onResp(resp){
        if (resp.error) ctx.displayError( resp.error );
        else ctx.displaySuccess();
    } );
}

// ..

doLogin(user,pw) {
    Auth.authorize( {
        username: user,
        password: pw
    } );
}

// ..
</code></pre>
<p>From my perspective, the problem is not with using objects to organize behavior.
It's that we're trying to use implicit input instead of being explicit about it.
When I'm wearing my FP hat, I want to leave <code>this</code> stuff on the shelf.</p>
<h2><a class="header" href="#summary-1" id="summary-1">Summary</a></h2>
<p>Functions are powerful.</p>
<p>But let's be clear what a function is. It's not just a collection of
statements/operations. Specifically, a function needs one or more inputs
(ideally, just one!) and an output.</p>
<p>Functions inside of functions can have closure over outer variables and remember
them for later. This is one of the most important concepts in all of
programming, and a fundamental foundation of FP.</p>
<p>Be careful of anonymous functions, especially <code>=&gt;</code> arrow functions. They're
convenient to write, but they shift the cost from author to reader. The whole
reason we're studying FP here is to write more readable code, so don't be so
quick to jump on that bandwagon.</p>
<p>Don't use <code>this</code>-aware functions. Just don't.</p>
<p>You should now be developing a clear and colorful perspective in your mind of
what <em>function</em> means in Functional Programming. It's time to start wrangling
functions to get them to interoperate, and the next chapter teaches you a
variety of critical techniques you'll need along the way.</p>
<h1><a class="header" href="#functional-light-javascript-4" id="functional-light-javascript-4">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-3-managing-function-inputs" id="chapter-3-managing-function-inputs">Chapter 3: Managing Function Inputs</a></h1>
<p><a href="chapter_2.html">Chapter 2</a> explored the core nature of JS <code>function</code>s, and laid
the foundation for what makes a <code>function</code> an FP <em>function</em>. But to leverage the
full power of FP, we also need patterns and practices for manipulating functions
to shift and adjust their interactions -- to bend them to our will.</p>
<p>Specifically, our attention for this chapter will be on the parameter inputs of
functions. As you bring functions of all different shapes together in your
programs, you'll quickly face incompatibilities in the number/order/type of
inputs, as well as the need to specify some inputs at different times than
others.</p>
<p>As a matter of fact, for stylistic purposes of readability, sometimes you'll
want to define functions in a way that hides their inputs entirely!</p>
<p>These kinds of techniques are absolutely essential to making functions truly
<em>function</em>-al.</p>
<h2><a class="header" href="#all-for-one" id="all-for-one">All for One</a></h2>
<p>Imagine you're passing a function to a utility, where the utility will send
multiple arguments to that function. But you may only want the function to
receive a single argument.</p>
<p>We can design a simple helper that wraps a function call to ensure only one
argument will pass through. Since this is effectively enforcing that a function
is treated as unary, let's name it as such:</p>
<p><a name="unary"></a></p>
<pre><code class="language-js">function unary(fn) {
  return function onlyOneArg(arg) {
    return fn(arg);
  };
}
</code></pre>
<p>Many FPers tend to prefer the shorter <code>=&gt;</code> arrow function syntax for such code
(see
<a href="chapter_2.html">Chapter 2, &quot;Functions without <code>function</code>&quot;</a>),
such as:</p>
<pre><code class="language-js">var unary = fn =&gt; arg =&gt; fn(arg);
</code></pre>
<p><strong>Note:</strong> No question this is more terse, sparse even. But I personally feel
that whatever it may gain in symmetry with the mathematical notation, it loses
more in overall readability with the functions all being anonymous, and by
obscuring the scope boundaries, making deciphering closure a little more
cryptic.</p>
<p>A commonly cited example for using <code>unary(..)</code> is with the <code>map(..)</code> utility
(see <a href="chapter_9.html">Chapter 9, &quot;Map&quot;</a>) and <code>parseInt(..)</code>. <code>map(..)</code> calls
a mapper function for each item in a list, and each time it invokes the mapper
function, it passes in three arguments: <code>value</code>, <code>idx</code>, <code>arr</code>.</p>
<p>That's usually not a big deal, unless you're trying to use something as a mapper
function that will behave incorrectly if it's passed too many arguments.
Consider:</p>
<pre><code class="language-js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt);
// [1,NaN,NaN]
</code></pre>
<p>For the signature <code>parseInt(str,radix)</code>, it's clear that when <code>map(..)</code> passes
<code>index</code> in the second argument position, it's interpreted by <code>parseInt(..)</code> as
the <code>radix</code>, which we don't want.</p>
<p><code>unary(..)</code> creates a function that will ignore all but the first argument
passed to it, meaning the passed-in <code>index</code> is never received by <code>parseInt(..)</code>
and mistaken as the <code>radix</code>:</p>
<p><a name="mapunary"></a></p>
<pre><code class="language-js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(unary(parseInt));
// [1,2,3]
</code></pre>
<h3><a class="header" href="#one-on-one" id="one-on-one">One on One</a></h3>
<p>Speaking of functions with only one argument, another common base utility in the
FP toolbelt is a function that takes one argument and does nothing but return
the value untouched:</p>
<pre><code class="language-js">function identity(v) {
  return v;
}

// or the ES6 =&gt; arrow form
var identity = v =&gt; v;
</code></pre>
<p>This utility looks so simple as to hardly be useful. But even simple functions
can be helpful in the world of FP. Like they say in acting: there are no small
parts, only small actors.</p>
<p>For example, imagine you'd like to split up a string using a regular expression,
but the resulting array may have some empty values in it. To discard those, we
can use JS's <code>filter(..)</code> array operation (see
<a href="chapter_9.html">Chapter 9, &quot;Filter&quot;</a>) with <code>identity(..)</code> as the
predicate:</p>
<pre><code class="language-js">var words = &quot;   Now is the time for all...  &quot;.split(/\s|\b/);
words;
// [&quot;&quot;,&quot;Now&quot;,&quot;is&quot;,&quot;the&quot;,&quot;time&quot;,&quot;for&quot;,&quot;all&quot;,&quot;...&quot;,&quot;&quot;]

words.filter(identity);
// [&quot;Now&quot;,&quot;is&quot;,&quot;the&quot;,&quot;time&quot;,&quot;for&quot;,&quot;all&quot;,&quot;...&quot;]
</code></pre>
<p>Because <code>identity(..)</code> simply returns the value passed to it, JS coerces each
value into either <code>true</code> or <code>false</code>, and that determines whether to keep or
exclude each value in the final array.</p>
<p><strong>Tip:</strong> Another unary function that can be used as the predicate in the
previous example is JS's built-in <code>Boolean(..)</code> function, which explicitly
coerces a value to <code>true</code> or <code>false</code>.</p>
<p>Another example of using <code>identity(..)</code> is as a default function in place of a
transformation:</p>
<pre><code class="language-js">function output(msg, formatFn = identity) {
  msg = formatFn(msg);
  console.log(msg);
}

function upper(txt) {
  return txt.toUpperCase();
}

output(&quot;Hello World&quot;, upper); // HELLO WORLD
output(&quot;Hello World&quot;); // Hello World
</code></pre>
<p>You also may see <code>identity(..)</code> used as a default transformation function for
<code>map(..)</code> calls or as the initial value in a <code>reduce(..)</code> of a list of
functions; both of these utilities will be covered in <a href="chapter_9.html">Chapter 9</a>.</p>
<h3><a class="header" href="#unchanging-one" id="unchanging-one">Unchanging One</a></h3>
<p>Certain APIs don't let you pass a value directly into a method, but require you
to pass in a function, even if that function literally just returns the value.
One such API is the <code>then(..)</code> method on JS Promises:</p>
<pre><code class="language-js">// doesn't work:
p1.then(foo)
  .then(p2)
  .then(bar);

// instead:
p1.then(foo)
  .then(function() {
    return p2;
  })
  .then(bar);
</code></pre>
<p>Many claim that ES6 <code>=&gt;</code> arrow functions are the best &quot;solution&quot;:</p>
<pre><code class="language-js">p1.then(foo)
  .then(() =&gt; p2)
  .then(bar);
</code></pre>
<p>But there's an FP utility that's more well suited for the task:</p>
<pre><code class="language-js">function constant(v) {
  return function value() {
    return v;
  };
}

// or the ES6 =&gt; form
var constant = v =&gt; () =&gt; v;
</code></pre>
<p>With this tidy little FP utility, we can solve our <code>then(..)</code> annoyance
properly:</p>
<pre><code class="language-js">p1.then(foo)
  .then(constant(p2))
  .then(bar);
</code></pre>
<p><strong>Warning:</strong> Although the <code>() =&gt; p2</code> arrow function version is shorter than
<code>constant(p2)</code>, I would encourage you to resist the temptation to use it. The
arrow function is returning a value from outside of itself, which is a bit worse
from the FP perspective. We'll cover the pitfalls of such actions later in the
book (see <a href="chapter_5.html">Chapter 5</a>).</p>
<h2><a class="header" href="#adapting-arguments-to-parameters" id="adapting-arguments-to-parameters">Adapting Arguments to Parameters</a></h2>
<p>There are a variety of patterns and tricks we can use to adapt a function's
signature to match the kinds of arguments we want to provide to it.</p>
<p>Recall
<a href="chapter_2.html">this function signature from Chapter 2</a>
which highlights using array parameter destructuring:</p>
<pre><code class="language-js">function foo( [x,y,...args] = [] ) {
</code></pre>
<p>This pattern is handy if an array will be passed in but you want to treat its
contents as individual parameters. <code>foo(..)</code> is thus technically unary -- when
it's executed, only one argument (an array) will be passed to it. But inside the
function, you get to address different inputs (<code>x</code>, <code>y</code>, etc) individually.</p>
<p>However, sometimes you won't have the ability to change the declaration of the
function to use array parameter destructuring. For example, imagine these
functions:</p>
<pre><code class="language-js">function foo(x, y) {
  console.log(x + y);
}

function bar(fn) {
  fn([3, 9]);
}

bar(foo); // fails
</code></pre>
<p>Do you spot why <code>bar(foo)</code> fails?</p>
<p>The array <code>[3,9]</code> is sent in as a single value to <code>fn(..)</code>, but <code>foo(..)</code>
expects <code>x</code> and <code>y</code> separately. If we could change the declaration of <code>foo(..)</code>
to be <code>function foo([x,y]) { ..</code>, we'd be fine. Or, if we could change the
behavior of <code>bar(..)</code> to make the call as <code>fn(...[3,9])</code>, the values <code>3</code> and <code>9</code>
would be passed in individually.</p>
<p>There will be occasions when you have two functions that are incompatible in
this way, and you won't be able to change their declarations/definitions. So,
how can you use them together?</p>
<p>We can define a helper to adapt a function so that it spreads out a single
received array as its individual arguments:</p>
<p><a name="spreadargs"></a></p>
<pre><code class="language-js">function spreadArgs(fn) {
  return function spreadFn(argsArr) {
    return fn(...argsArr);
  };
}

// or the ES6 =&gt; arrow form
var spreadArgs = fn =&gt; argsArr =&gt; fn(...argsArr);
</code></pre>
<p><strong>Note:</strong> I called this helper <code>spreadArgs(..)</code>, but in libraries like Ramda
it's commonly called <code>apply(..)</code>.</p>
<p>Now we can use <code>spreadArgs(..)</code> to adapt <code>foo(..)</code> to work as the proper input
to <code>bar(..)</code>:</p>
<pre><code class="language-js">bar(spreadArgs(foo)); // 12
</code></pre>
<p>It won't seem clear yet why these occasions arise, but you will see them often.
Essentially, <code>spreadArgs(..)</code> allows us to define functions that <code>return</code>
multiple values via an array, but still have those multiple values treated
independently as inputs to another function.</p>
<p>While we're talking about a <code>spreadArgs(..)</code> utility, let's also define a
utility to handle the opposite action:</p>
<pre><code class="language-js">function gatherArgs(fn) {
  return function gatheredFn(...argsArr) {
    return fn(argsArr);
  };
}

// or the ES6 =&gt; arrow form
var gatherArgs = fn =&gt; (...argsArr) =&gt; fn(argsArr);
</code></pre>
<p><strong>Note:</strong> In Ramda, this utility is referred to as <code>unapply(..)</code>, being that
it's the opposite of <code>apply(..)</code>. I think the &quot;spread&quot;/&quot;gather&quot; terminology is a
little more descriptive for what's going on.</p>
<p>We can use this utility to gather individual arguments into a single array,
perhaps because we want to adapt a function with array parameter destructuring
to another utility that passes arguments separately. We will
<a href="chapter_9.html">cover <code>reduce(..)</code> more fully in Chapter 9</a>; in short, it
repeatedly calls its reducer function with two individual parameters, which we
can now <em>gather</em> together:</p>
<pre><code class="language-js">function combineFirstTwo([v1, v2]) {
  return v1 + v2;
}

[1, 2, 3, 4, 5].reduce(gatherArgs(combineFirstTwo));
// 15
</code></pre>
<h2><a class="header" href="#some-now-some-later" id="some-now-some-later">Some Now, Some Later</a></h2>
<p>If a function takes multiple arguments, you may want to specify some of those up
front and leave the rest to be specified later.</p>
<p>Consider this function:</p>
<pre><code class="language-js">function ajax(url, data, callback) {
  // ..
}
</code></pre>
<p>Let's imagine you'd like to set up several API calls where the URLs are known up
front, but the data and the callback to handle the response won't be known until
later.</p>
<p>Of course, you can just defer making the <code>ajax(..)</code> call until all the bits are
known, and refer to some global constant for the URL at that time. But another
way is to create a function reference that already has the <code>url</code> argument
preset.</p>
<p>What we're going to do is make a new function that still calls <code>ajax(..)</code> under
the covers, and it manually sets the first argument to the API URL you care
about, while waiting to accept the other two arguments later:</p>
<pre><code class="language-js">function getPerson(data, cb) {
  ajax(&quot;http://some.api/person&quot;, data, cb);
}

function getOrder(data, cb) {
  ajax(&quot;http://some.api/order&quot;, data, cb);
}
</code></pre>
<p>Manually specifying these function call wrappers is certainly possible, but it
may get quite tedious, especially if there will also be variations with
different arguments preset, like:</p>
<pre><code class="language-js">function getCurrentUser(cb) {
  getPerson({ user: CURRENT_USER_ID }, cb);
}
</code></pre>
<p>One practice an FPer gets very used to is looking for patterns where we do the
same sorts of things repeatedly, and trying to turn those actions into generic
reusable utilities. As a matter of fact, I'm sure that's already the instinct
for many of you readers, so that's not uniquely an FP thing. But it's
unquestionably important for FP.</p>
<p>To conceive such a utility for argument presetting, let's examine conceptually
what's going on, not just looking at the manual implementations shown here.</p>
<p>One way to articulate what's going on is that the <code>getOrder(data,cb)</code> function
is a <em>partial application</em> of the <code>ajax(url,data,cb)</code> function. This terminology
comes from the notion that arguments are <em>applied</em> to parameters at the function
call-site. And as you can see, we're only applying some of the arguments up
front -- specifically, the argument for the <code>url</code> parameter -- while leaving the
rest to be applied later.</p>
<p>To be a tiny bit more formal about this pattern, partial application is strictly
a reduction in a function's arity; remember, that's the number of expected
parameter inputs. We reduced the original <code>ajax(..)</code> function's arity from 3 to
2 for the <code>getOrder(..)</code> function.</p>
<p>Let's define a <code>partial(..)</code> utility:</p>
<pre><code class="language-js">function partial(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...presetArgs, ...laterArgs);
  };
}

// or the ES6 =&gt; arrow form
var partial = (fn, ...presetArgs) =&gt; (...laterArgs) =&gt;
  fn(...presetArgs, ...laterArgs);
</code></pre>
<p><strong>Tip:</strong> Don't just take this snippet at face value. Pause for a few moments to
digest what's going on with this utility. Make sure you really <em>get it</em>.</p>
<p>The <code>partial(..)</code> function takes an <code>fn</code> for which function we are partially
applying. Then, any subsequent arguments passed in are gathered into the
<code>presetArgs</code> array and saved for later.</p>
<p>A new inner function (called <code>partiallyApplied(..)</code> just for clarity) is created
and <code>return</code>ed; the inner function's own arguments are gathered into an array
called <code>laterArgs</code>.</p>
<p>Notice the references to <code>fn</code> and <code>presetArgs</code> inside this inner function? How
does that work? After <code>partial(..)</code> finishes running, how does the inner
function keep being able to access <code>fn</code> and <code>presetArgs</code>? If you answered
<strong>closure</strong>, you're right on track! The inner function <code>partiallyApplied(..)</code>
closes over both the <code>fn</code> and <code>presetArgs</code> variables so it can keep accessing
them later, no matter where the function runs. This is why understanding closure
is critical!</p>
<p>When the <code>partiallyApplied(..)</code> function is later executed somewhere else in
your program, it uses the closed over <code>fn</code> to execute the original function,
first providing any of the (closed over) <code>presetArgs</code> partial application
arguments, then any further <code>laterArgs</code> arguments.</p>
<p>If any of that was confusing, stop and go re-read it. Trust me, you'll be glad
you did as we get further into the text.</p>
<p>Let's now use the <code>partial(..)</code> utility to make those earlier partially applied
functions:</p>
<pre><code class="language-js">var getPerson = partial(ajax, &quot;http://some.api/person&quot;);

var getOrder = partial(ajax, &quot;http://some.api/order&quot;);
</code></pre>
<p>Take a moment to consider the shape/internals of <code>getPerson(..)</code>. It will look
sorta like this:</p>
<pre><code class="language-js">var getPerson = function partiallyApplied(...laterArgs) {
  return ajax(&quot;http://some.api/person&quot;, ...laterArgs);
};
</code></pre>
<p>The same will be true of <code>getOrder(..)</code>. But what about <code>getCurrentUser(..)</code>?</p>
<pre><code class="language-js">// version 1
var getCurrentUser = partial(ajax, &quot;http://some.api/person&quot;, {
  user: CURRENT_USER_ID
});

// version 2
var getCurrentUser = partial(getPerson, { user: CURRENT_USER_ID });
</code></pre>
<p>We can either define <code>getCurrentUser(..)</code> with both the <code>url</code> and <code>data</code>
arguments specified directly (version 1), or define <code>getCurrentUser(..)</code> as a
partial application of the <code>getPerson(..)</code> partial application, specifying only
the additional <code>data</code> argument (version 2).</p>
<p>Version 2 is a little cleaner to express because it reuses something already
defined. As such, I think it fits a little closer to the spirit of FP.</p>
<p>Just to make sure we understand how these two versions will work under the
covers, they look respectively kinda like:</p>
<pre><code class="language-js">// version 1
var getCurrentUser = function partiallyApplied(...laterArgs) {
  return ajax(
    &quot;http://some.api/person&quot;,
    { user: CURRENT_USER_ID },
    ...laterArgs
  );
};

// version 2
var getCurrentUser = function outerPartiallyApplied(...outerLaterArgs) {
  var getPerson = function innerPartiallyApplied(...innerLaterArgs) {
    return ajax(&quot;http://some.api/person&quot;, ...innerLaterArgs);
  };

  return getPerson({ user: CURRENT_USER_ID }, ...outerLaterArgs);
};
</code></pre>
<p>Again, stop and re-read those code snippets to make sure you understand what's
going on there.</p>
<p><strong>Note:</strong> Version 2 has an extra layer of function wrapping involved. That may
smell strange and unnecessary, but this is just one of those things in FP that
you'll want to get really comfortable with. We'll be wrapping many layers of
functions onto each other as we progress through the text. Remember, this is
<em>function</em>al programming!</p>
<p>Let's take a look at another example of the usefulness of partial application.
Consider an <code>add(..)</code> function which takes two arguments and adds them together:</p>
<pre><code class="language-js">function add(x, y) {
  return x + y;
}
</code></pre>
<p>Now imagine we'd like take a list of numbers and add a certain number to each of
them. We'll use the <code>map(..)</code> utility (see
<a href="chapter_9.html">Chapter 9, &quot;Map&quot;</a>) built into JS arrays:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].map(function adder(val) {
  return add(3, val);
});
// [4,5,6,7,8]
</code></pre>
<p>The reason we can't pass <code>add(..)</code> directly to <code>map(..)</code> is because the
signature of <code>add(..)</code> doesn't match the mapping function that <code>map(..)</code>
expects. That's where partial application can help us: we can adapt the
signature of <code>add(..)</code> to something that will match:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].map(partial(add, 3));
// [4,5,6,7,8]
</code></pre>
<p>The <code>partial(add,3)</code> call produces a new unary function which is expecting only
one more argument.</p>
<p>The <code>map(..)</code> utility will loop through the array (<code>[1,2,3,4,5]</code>) and repeatedly
call this unary function, once for each of those values, respectively. So, the
calls made will effectively be <code>add(3,1)</code>, <code>add(3,2)</code>, <code>add(3,3)</code>, <code>add(3,4)</code>,
and <code>add(3,5)</code>. The array of those results is <code>[4,5,6,7,8]</code>.</p>
<h3><a class="header" href="#bind" id="bind"><code>bind(..)</code></a></h3>
<p>JavaScript functions all have a built-in utility called <code>bind(..)</code>. It has two
capabilities: presetting the <code>this</code> context and partially applying arguments.</p>
<p>I think it's incredibly misguided to conflate these two capabilities in one
utility. Sometimes you'll want to hard-bind the <code>this</code> context and not partially
apply arguments. Other times you'll want to partially apply arguments but not
care about <code>this</code> binding at all. I have never needed both at the same time.</p>
<p>The latter scenario (partial application without setting <code>this</code> context) is
awkward because you have to pass an ignorable placeholder for the <code>this</code>-binding
argument (the first one), usually <code>null</code>.</p>
<p>Consider:</p>
<pre><code class="language-js">var getPerson = ajax.bind(null, &quot;http://some.api/person&quot;);
</code></pre>
<p>That <code>null</code> just bugs me to no end. Despite this <em>this</em> annoyance, it's mildly
convenient that JS has a built-in utility for partial application. However, most
FP programmers prefer using the dedicated <code>partial(..)</code> utility in their chosen
FP library.</p>
<h3><a class="header" href="#reversing-arguments" id="reversing-arguments">Reversing Arguments</a></h3>
<p>Recall that the signature for our Ajax function is: <code>ajax( url, data, cb )</code>.
What if we wanted to partially apply the <code>cb</code> but wait to specify <code>data</code> and
<code>url</code> later? We could create a utility that wraps a function to reverse its
argument order:</p>
<pre><code class="language-js">function reverseArgs(fn) {
  return function argsReversed(...args) {
    return fn(...args.reverse());
  };
}

// or the ES6 =&gt; arrow form
var reverseArgs = fn =&gt; (...args) =&gt; fn(...args.reverse());
</code></pre>
<p>Now we can reverse the order of the <code>ajax(..)</code> arguments, so that we can then
partially apply from the right rather than the left. To restore the expected
order, we'll then reverse the subsequent partially applied function:</p>
<pre><code class="language-js">var cache = {};

var cacheResult = reverseArgs(
  partial(reverseArgs(ajax), function onResult(obj) {
    cache[obj.id] = obj;
  })
);

// later:
cacheResult(&quot;http://some.api/person&quot;, { user: CURRENT_USER_ID });
</code></pre>
<p>Instead of manually using <code>reverseArgs(..)</code> (twice!) for this purpose, we can
define a <code>partialRight(..)</code> which partially applies the rightmost arguments.
Under the covers, it can use the same double-reverse trick:</p>
<p><a name="partialright"></a></p>
<pre><code class="language-js">function partialRight(fn, ...presetArgs) {
  return reverseArgs(partial(reverseArgs(fn), ...presetArgs.reverse()));
}

var cacheResult = partialRight(ajax, function onResult(obj) {
  cache[obj.id] = obj;
});

// later:
cacheResult(&quot;http://some.api/person&quot;, { user: CURRENT_USER_ID });
</code></pre>
<p>Another more straightforward (and certainly more performant) implementation of
<code>partialRight(..)</code> that doesn't use the double-reverse trick:</p>
<pre><code class="language-js">function partialRight(fn, ...presetArgs) {
  return function partiallyApplied(...laterArgs) {
    return fn(...laterArgs, ...presetArgs);
  };
}

// or the ES6 =&gt; arrow form
var partialRight = (fn, ...presetArgs) =&gt; (...laterArgs) =&gt;
  fn(...laterArgs, ...presetArgs);
</code></pre>
<p>None of these implementations of <code>partialRight(..)</code> guarantee that a specific
parameter will receive a specific partially applied value; it only ensures that
the partially applied value(s) appear as the rightmost (aka, last) argument(s)
passed to the original function.</p>
<p>For example:</p>
<pre><code class="language-js">function foo(x, y, z, ...rest) {
  console.log(x, y, z, rest);
}

var f = partialRight(foo, &quot;z:last&quot;);

f(1, 2); // 1 2 &quot;z:last&quot; []

f(1); // 1 &quot;z:last&quot; undefined []

f(1, 2, 3); // 1 2 3 [&quot;z:last&quot;]

f(1, 2, 3, 4); // 1 2 3 [4,&quot;z:last&quot;]
</code></pre>
<p>The value <code>&quot;z:last&quot;</code> is only applied to the <code>z</code> parameter in the case where
<code>f(..)</code> is called with exactly two arguments (matching <code>x</code> and <code>y</code> parameters).
In all other cases, the <code>&quot;z:last&quot;</code> will just be the rightmost argument, however
many arguments precede it.</p>
<h2><a class="header" href="#one-at-a-time" id="one-at-a-time">One at a Time</a></h2>
<p>Let's examine a technique similar to partial application, where a function that
expects multiple arguments is broken down into successive chained functions that
each take a single argument (arity: 1) and return another function to accept the
next argument.</p>
<p>This technique is called currying.</p>
<p>To first illustrate, let's imagine we had a curried version of <code>ajax(..)</code>
already created. This is how we'd use it:</p>
<pre><code class="language-js">curriedAjax(&quot;http://some.api/person&quot;)({ user: CURRENT_USER_ID })(
  function foundUser(user) {
    /* .. */
  }
);
</code></pre>
<p>The three sets of <code>(..)</code>s denote three chained function calls. But perhaps
splitting out each of the three calls helps see what's going on better:</p>
<pre><code class="language-js">var personFetcher = curriedAjax(&quot;http://some.api/person&quot;);

var getCurrentUser = personFetcher({ user: CURRENT_USER_ID });

getCurrentUser(function foundUser(user) {
  /* .. */
});
</code></pre>
<p>Instead of taking all the arguments at once (like <code>ajax(..)</code>), or some of the
arguments up front and the rest later (via <code>partial(..)</code>), this
<code>curriedAjax(..)</code> function receives one argument at a time, each in a separate
function call.</p>
<p>Currying is similar to partial application in that each successive curried call
partially applies another argument to the original function, until all arguments
have been passed.</p>
<p>The main difference is that <code>curriedAjax(..)</code> will return a function (we call it
<code>personFetcher(..)</code>) that expects <strong>only the next argument</strong> <code>data</code>, not one
that (like the earlier <code>getPerson(..)</code>) can receive all the rest of the
arguments.</p>
<p>If an original function expected five arguments, the curried form of that
function would take just the first argument, and return a function to accept the
second. That one would take just the second argument, and return a function to
accept the third. And so on.</p>
<p>So currying unwinds a single higher-arity function into a series of chained
unary functions.</p>
<p>How might we define a utility to do this currying? Consider:</p>
<p><a name="curry"></a></p>
<pre><code class="language-js">function curry(fn, arity = fn.length) {
  return (function nextCurried(prevArgs) {
    return function curried(nextArg) {
      var args = [...prevArgs, nextArg];

      if (args.length &gt;= arity) {
        return fn(...args);
      } else {
        return nextCurried(args);
      }
    };
  })([]);
}

// or the ES6 =&gt; arrow form
var curry = (fn, arity = fn.length, nextCurried) =&gt;
  (nextCurried = prevArgs =&gt; nextArg =&gt; {
    var args = [...prevArgs, nextArg];

    if (args.length &gt;= arity) {
      return fn(...args);
    } else {
      return nextCurried(args);
    }
  })([]);
</code></pre>
<p>The approach here is to start a collection of arguments in <code>prevArgs</code> as an
empty <code>[]</code> array, and add each received <code>nextArg</code> to that, calling the
concatenation <code>args</code>. While <code>args.length</code> is less than <code>arity</code> (the number of
declared/expected parameters of the original <code>fn(..)</code> function), make and return
another <code>curried(..)</code> function to collect the next <code>nextArg</code> argument, passing
the running <code>args</code> collection along as its <code>prevArgs</code>. Once we have enough
<code>args</code>, execute the original <code>fn(..)</code> function with them.</p>
<p>By default, this implementation relies on being able to inspect the <code>length</code>
property of the to-be-curried function to know how many iterations of currying
we'll need before we've collected all its expected arguments.</p>
<p><strong>Note:</strong> If you use this implementation of <code>curry(..)</code> with a function that
doesn't have an accurate <code>length</code> property, you'll need to pass the <code>arity</code> (the
second parameter of <code>curry(..)</code>) to ensure <code>curry(..)</code> works correctly. <code>length</code>
will be inaccurate if the function's parameter signature includes default
parameter values, parameter destructuring, or is variadic with <code>...args</code> (see
<a href="chapter_2.html">Chapter 2</a>).</p>
<p>Here's how we would use <code>curry(..)</code> for our earlier <code>ajax(..)</code> example:</p>
<pre><code class="language-js">var curriedAjax = curry(ajax);

var personFetcher = curriedAjax(&quot;http://some.api/person&quot;);

var getCurrentUser = personFetcher({ user: CURRENT_USER_ID });

getCurrentUser(function foundUser(user) {
  /* .. */
});
</code></pre>
<p>Each call partially applies one more argument to the original <code>ajax(..)</code> call,
until all three have been provided and <code>ajax(..)</code> is actually invoked.</p>
<p>Remember our example from the discussion of partial application about adding <code>3</code>
to each value in a list of numbers? As currying is similar to partial
application, we could do that task with currying in almost the same way:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].map(curry(add)(3));
// [4,5,6,7,8]
</code></pre>
<p>The difference between the two? <code>partial(add,3)</code> vs <code>curry(add)(3)</code>.</p>
<p>Why might you choose <code>curry(..)</code> over <code>partial(..)</code>? It might be helpful in the
case where you know ahead of time that <code>add(..)</code> is the function to be adapted,
but the value <code>3</code> isn't known yet:</p>
<pre><code class="language-js">var adder = curry(add);

// later
[1, 2, 3, 4, 5].map(adder(3));
// [4,5,6,7,8]
</code></pre>
<p>Let's look at another numbers example, this time adding a list of them together:</p>
<pre><code class="language-js">function sum(...nums) {
  var total = 0;
  for (let num of nums) {
    total += num;
  }
  return total;
}

sum(1, 2, 3, 4, 5); // 15

// now with currying:
// (5 to indicate how many we should wait for)
var curriedSum = curry(sum, 5);

curriedSum(1)(2)(3)(4)(5); // 15
</code></pre>
<p>The advantage of currying here is that each call to pass in an argument produces
another function that's more specialized, and we can capture and use <em>that</em> new
function later in the program. Partial application specifies all the partially
applied arguments up front, producing a function that's waiting for all the rest
of the arguments <strong>on the next call</strong>.</p>
<p>If you wanted to use partial application to specify one parameter (or several!)
at a time, you'd have to keep calling <code>partial(..)</code> again on each successive
partially applied function. By contrast, curried functions do this
automatically, making working with individual arguments one-at-a-time more
ergonomic.</p>
<p>Both currying and partial application use closure to remember the arguments over
time until all have been received, and then the original function can be
invoked.</p>
<h3><a class="header" href="#visualizing-curried-functions" id="visualizing-curried-functions">Visualizing Curried Functions</a></h3>
<p>Let's examine more closely the <code>curriedSum(..)</code> from the previous section.
Recall its usage: <code>curriedSum(1)(2)(3)(4)(5)</code>; five subsequent (chained)
function calls.</p>
<p>What if we manually defined a <code>curriedSum(..)</code> instead of using <code>curry(..)</code>? How
would that look?</p>
<pre><code class="language-js">function curriedSum(v1) {
  return function(v2) {
    return function(v3) {
      return function(v4) {
        return function(v5) {
          return sum(v1, v2, v3, v4, v5);
        };
      };
    };
  };
}
</code></pre>
<p>Definitely uglier, no question. But this is an important way to visualize what's
going on with a curried function. Each nested function call is returning another
function that's going to accept the next argument, and that continues until
we've specified all the expected arguments.</p>
<p>When trying to decipher curried functions, I've found it helps me tremendously
if I can unwrap them mentally as a series of nested functions.</p>
<p>In fact, to reinforce that point, let's consider the same code but written with
ES6 arrow functions:</p>
<pre><code class="language-js">curriedSum = v1 =&gt; v2 =&gt; v3 =&gt; v4 =&gt; v5 =&gt; sum(v1, v2, v3, v4, v5);
</code></pre>
<p>And now, all on one line:</p>
<pre><code class="language-js">curriedSum = v1 =&gt; v2 =&gt; v3 =&gt; v4 =&gt; v5 =&gt; sum(v1, v2, v3, v4, v5);
</code></pre>
<p>Depending on your perspective, that form of visualizing the curried function may
be more or less helpful to you. For me, it's a fair bit more obscured.</p>
<p>But the reason I show it that way is that it happens to look almost identical to
the mathematical notation (and Haskell syntax) for a curried function! That's
one reason why those who like mathematical notation (and/or Haskell) like the
ES6 arrow function form.</p>
<h3><a class="header" href="#why-currying-and-partial-application" id="why-currying-and-partial-application">Why Currying and Partial Application?</a></h3>
<p>With either style -- currying (such as <code>sum(1)(2)(3)</code>) or partial application
(such as <code>partial(sum,1,2)(3)</code>) -- the call-site unquestionably looks stranger
than a more common one like <code>sum(1,2,3)</code>. So <strong>why would we ever go this
direction</strong> when adopting FP? There are multiple layers to answering that
question.</p>
<p>The first and most obvious reason is that both currying and partial application
allow you to separate in time/space (throughout your codebase) when and where
separate arguments are specified, whereas traditional function calls require all
the arguments to be present at the same time. If you have a place in your code
where you'll know some of the arguments and another place where the other
arguments are determined, currying or partial application are very useful.</p>
<p>Another layer to this answer, specifically for currying, is that composition of
functions is much easier when there's only one argument. So a function that
ultimately needs three arguments, if curried, becomes a function that needs just
one, three times over. That kind of unary function will be a lot easier to work
with when we start composing them. We'll tackle this topic later in
<a href="chapter_4.html">Chapter 4</a>.</p>
<p>But the most important layer is specialization of generalized functions, and how
such abstraction improves readability of code.</p>
<p>Consider our running <code>ajax(..)</code> example:</p>
<pre><code class="language-js">ajax(&quot;http://some.api/person&quot;, { user: CURRENT_USER_ID }, function foundUser(
  user
) {
  /* .. */
});
</code></pre>
<p>The call-site includes all the information necessary to pass to the most
generalized version of the utility (<code>ajax(..)</code>). The potential readability
downside is that it may be the case that the URL and the data are not relevant
information at this point in the program, but yet that information is cluttering
up the call-site nonetheless.</p>
<p>Now consider:</p>
<pre><code class="language-js">var getCurrentUser = partial(ajax, &quot;http://some.api/person&quot;, {
  user: CURRENT_USER_ID
});

// later

getCurrentUser(function foundUser(user) {
  /* .. */
});
</code></pre>
<p>In this version, we define a <code>getCurrentUser(..)</code> function ahead of time that
already has known information like URL and data preset. The call-site for
<code>getCurrentUser(..)</code> then isn't cluttered by information that <strong>at that point of
the code</strong> isn't relevant.</p>
<p>Moreover, the semantic name for the function <code>getCurrentUser(..)</code> more
accurately depicts what is happening than just <code>ajax(..)</code> with a URL and data
would.</p>
<p>That's what abstraction is all about: separating two sets of details -- in this
case, the <em>how</em> of getting a current user and the <em>what</em> we do with that user --
and inserting a semantic boundary between them, which eases the reasoning of
each part independently.</p>
<p>Whether you use currying or partial application, creating specialized functions
from generalized ones is a powerful technique for semantic abstraction and
improved readability.</p>
<h3><a class="header" href="#currying-more-than-one-argument" id="currying-more-than-one-argument">Currying More Than One Argument?</a></h3>
<p>The definition and implementation I've given of currying thus far is, I believe,
as true to the spirit as we can likely get in JavaScript.</p>
<p>Specifically, if we look briefly at how currying works in Haskell, we can
observe that multiple arguments always go in to a function one at a time, one
per curried call -- other than tuples (analogous to arrays for our purposes)
that transport multiple values in a single argument.</p>
<p>For example, in Haskell:</p>
<pre><code class="language-haskell">foo 1 2 3
</code></pre>
<p>This calls the <code>foo</code> function, and has the result of passing in three values
<code>1</code>, <code>2</code>, and <code>3</code>. But functions are automatically curried in Haskell, which
means each value goes in as a separate curried-call. The JS equivalent of that
would look like <code>foo(1)(2)(3)</code>, which is the same style as the <code>curry(..)</code> I
presented earlier.</p>
<p><strong>Note:</strong> In Haskell, <code>foo (1,2,3)</code> is not passing in those three values at once
as three separate arguments, but a tuple (kinda like a JS array) as a single
argument. To work, <code>foo</code> would need to be altered to handle a tuple in that
argument position. As far as I can tell, there's no way in Haskell to pass all
three arguments separately with just one function call; each argument gets its
own curried-call. Of course, the presence of multiple calls is transparent to
the Haskell developer, but it's a lot more syntactically obvious to the JS
developer.</p>
<p>For these reasons, I think the <code>curry(..)</code> that I demonstrated earlier is a
faithful adaptation, or what I might call &quot;strict currying&quot;. However, it's
important to note that there's a looser definition used in most popular
JavaScript FP libraries.</p>
<p>Specifically, JS currying utilities typically allow you to specify multiple
arguments for each curried-call. Revisiting our <code>sum(..)</code> example from before,
this would look like:</p>
<pre><code class="language-js">var curriedSum = looseCurry(sum, 5);

curriedSum(1)(2, 3)(4, 5); // 15
</code></pre>
<p>We see a slight syntax savings of fewer <code>( )</code>, and an implied performance
benefit of now having three function calls instead of five. But other than that,
using <code>looseCurry(..)</code> is identical in end result to the narrower <code>curry(..)</code>
definition from earlier. I would guess the convenience/performance factor is
probably why frameworks allow multiple arguments. This seems mostly like a
matter of taste.</p>
<p>We can adapt our previous currying implementation to this common looser
definition:</p>
<p><a name="loosecurry"></a></p>
<pre><code class="language-js">function looseCurry(fn, arity = fn.length) {
  return (function nextCurried(prevArgs) {
    return function curried(...nextArgs) {
      var args = [...prevArgs, ...nextArgs];

      if (args.length &gt;= arity) {
        return fn(...args);
      } else {
        return nextCurried(args);
      }
    };
  })([]);
}
</code></pre>
<p>Now each curried-call accepts one or more arguments (as <code>nextArgs</code>). We'll leave
it as an exercise for the interested reader to define the ES6 <code>=&gt;</code> version of
<code>looseCurry(..)</code> similar to how we did it for <code>curry(..)</code> earlier.</p>
<h3><a class="header" href="#no-curry-for-me-please" id="no-curry-for-me-please">No Curry for Me, Please</a></h3>
<p>It may also be the case that you have a curried function that you'd like to
essentially un-curry -- basically, to turn a function like <code>f(1)(2)(3)</code> back
into a function like <code>g(1,2,3)</code>.</p>
<p>The standard utility for this is (un)shockingly typically called <code>uncurry(..)</code>.
Here's a simple naive implementation:</p>
<pre><code class="language-js">function uncurry(fn) {
  return function uncurried(...args) {
    var ret = fn;

    for (let arg of args) {
      ret = ret(arg);
    }

    return ret;
  };
}

// or the ES6 =&gt; arrow form
var uncurry = fn =&gt; (...args) =&gt; {
  var ret = fn;

  for (let arg of args) {
    ret = ret(arg);
  }

  return ret;
};
</code></pre>
<p><strong>Warning:</strong> Don't just assume that <code>uncurry(curry(f))</code> has the same behavior as
<code>f</code>. In some libraries the uncurrying would result in a function like the
original, but not all of them; certainly our example here does not. The
uncurried function acts (mostly) the same as the original function if you pass
as many arguments to it as the original function expected. However, if you pass
fewer arguments, you still get back a partially curried function waiting for
more arguments; this quirk is illustrated in the following snippet:</p>
<pre><code class="language-js">function sum(...nums) {
  var sum = 0;
  for (let num of nums) {
    sum += num;
  }
  return sum;
}

var curriedSum = curry(sum, 5);
var uncurriedSum = uncurry(curriedSum);

curriedSum(1)(2)(3)(4)(5); // 15

uncurriedSum(1, 2, 3, 4, 5); // 15
uncurriedSum(1, 2, 3)(4)(5); // 15
</code></pre>
<p>Probably the more common case of using <code>uncurry(..)</code> is not with a manually
curried function as just shown, but with a function that comes out curried as a
result of some other set of operations. We'll illustrate that scenario later in
this chapter in the <a href="chapter_3.html#no-points">&quot;No Points&quot; discussion</a>.</p>
<h2><a class="header" href="#order-matters" id="order-matters">Order Matters</a></h2>
<p>In Chapter 2, we explored the
<a href="chapter_2.html">named arguments pattern</a>. One primary advantage
of named arguments is not needing to juggle argument ordering, thereby improving
readability.</p>
<p>We've looked at the advantages of using currying/partial application to provide
individual arguments to a function separately. But the downside is that these
techniques are traditionally based on positional arguments; argument ordering is
thus an inevitable headache.</p>
<p>Utilities like <code>reverseArgs(..)</code> (and others) are necessary to juggle arguments
to get them into the right order. Sometimes we get lucky and define a function
with parameters in the order that we later want to curry them, but other times
that order is incompatible and we have to jump through hoops to reorder.</p>
<p>The frustration is not merely that we need to use some utility to juggle the
properties, but the fact that the usage of the utility clutters up our code a
bit with extra noise. These kinds of things are like little paper cuts; one here
or there isn't a showstopper, but the pain can certainly add up.</p>
<p>Can we improve currying/partial application to free it from these ordering
concerns? Let's apply the tricks from named arguments style and invent some
helper utilities for this adaptation:</p>
<pre><code class="language-js">function partialProps(fn, presetArgsObj) {
  return function partiallyApplied(laterArgsObj) {
    return fn(Object.assign({}, presetArgsObj, laterArgsObj));
  };
}

function curryProps(fn, arity = 1) {
  return (function nextCurried(prevArgsObj) {
    return function curried(nextArgObj = {}) {
      var [key] = Object.keys(nextArgObj);
      var allArgsObj = Object.assign({}, prevArgsObj, {
        [key]: nextArgObj[key]
      });

      if (Object.keys(allArgsObj).length &gt;= arity) {
        return fn(allArgsObj);
      } else {
        return nextCurried(allArgsObj);
      }
    };
  })({});
}
</code></pre>
<p><strong>Tip:</strong> We don't even need a <code>partialPropsRight(..)</code> because we don't need to
care about what order properties are being mapped; the name mappings make that
ordering concern moot!</p>
<p>Here's how to use those helpers:</p>
<pre><code class="language-js">function foo({ x, y, z } = {}) {
  console.log(`x:${x} y:${y} z:${z}`);
}

var f1 = curryProps(foo, 3);
var f2 = partialProps(foo, { y: 2 });

f1({ y: 2 })({ x: 1 })({ z: 3 });
// x:1 y:2 z:3

f2({ z: 3, x: 1 });
// x:1 y:2 z:3
</code></pre>
<p>Even with currying or partial application, order doesn't matter anymore! We can
now specify which arguments we want in whatever sequence makes sense. No more
<code>reverseArgs(..)</code> or other nuisances. Cool!</p>
<p><strong>Tip:</strong> If this style of function arguments seems useful or interesting to you,
check out coverage of my <a href="apC.html">FPO library in Appendix C</a>.</p>
<h3><a class="header" href="#spreading-properties" id="spreading-properties">Spreading Properties</a></h3>
<p>Unfortunately, we can only take advantage of currying with named arguments if we
have control over the signature of <code>foo(..)</code> and define it to destructure its
first parameter. What if we wanted to use this technique with a function that
had its parameters individually listed (no parameter destructuring!), and we
couldn't change that function signature? For example:</p>
<pre><code class="language-js">function bar(x, y, z) {
  console.log(`x:${x} y:${y} z:${z}`);
}
</code></pre>
<p>Just like the <code>spreadArgs(..)</code> utility earlier, we can define a
<code>spreadArgProps(..)</code> helper that takes the <code>key: value</code> pairs out of an object
argument and &quot;spreads&quot; the values out as individual arguments.</p>
<p>There are some quirks to be aware of, though. With <code>spreadArgs(..)</code>, we were
dealing with arrays, where ordering is well defined and obvious. However, with
objects, property order is less clear and not necessarily reliable. Depending on
how an object is created and properties set, we cannot be absolutely certain
what enumeration order properties would come out.</p>
<p>Such a utility needs a way to let you define what order the function in question
expects its arguments (e.g., property enumeration order). We can pass an array
like <code>[&quot;x&quot;,&quot;y&quot;,&quot;z&quot;]</code> to tell the utility to pull the properties off the object
argument in exactly that order.</p>
<p>That's decent, but it's also unfortunate that it then <em>obligates</em> us to add that
property-name array even for the simplest of functions. Is there any kind of
trick we could use to detect what order the parameters are listed for a
function, in at least the common simple cases? Fortunately, yes!</p>
<p>JavaScript functions have a <code>.toString()</code> method that gives a string
representation of the function's code, including the function declaration
signature. Dusting off our regular expression parsing skills, we can parse the
string representation of the function, and pull out the individually named
parameters. The code looks a bit gnarly, but it's good enough to get the job
done:</p>
<pre><code class="language-js">function spreadArgProps(
    fn,
    propOrder =
        fn.toString()
        .replace( /^(?:(?:function.*\(([^]*?)\))|(?:([^\(\)]+?)
            \s*=&gt;)|(?:\(([^]*?)\)\s*=&gt;))[^]+$/, &quot;$1$2$3&quot; )
        .split( /\s*,\s*/ )
        .map( v =&gt; v.replace( /[=\s].*$/, &quot;&quot; ) )
) {
    return function spreadFn(argsObj){
        return fn( ...propOrder.map( k =&gt; argsObj[k] ) );
    };
}
</code></pre>
<p><strong>Note:</strong> This utility's parameter parsing logic is far from bullet-proof; we're
using regular expressions to parse code, which is already a faulty premise! But
our only goal here is to handle the common cases, which this does reasonably
well. We only need a sensible default detection of parameter order for functions
with simple parameters (including those with default parameter values). We
don't, for example, need to be able to parse out a complex destructured
parameter, because we wouldn't likely be using this utility with such a
function, anyway. So, this logic gets the job done 80% of the time; it lets us
override the <code>propOrder</code> array for any other more complex function signature
that wouldn't otherwise be correctly parsed. That's the kind of pragmatic
balance this book seeks to find wherever possible.</p>
<p>Let's illustrate using our <code>spreadArgProps(..)</code> utility:</p>
<pre><code class="language-js">function bar(x, y, z) {
  console.log(`x:${x} y:${y} z:${z}`);
}

var f3 = curryProps(spreadArgProps(bar), 3);
var f4 = partialProps(spreadArgProps(bar), { y: 2 });

f3({ y: 2 })({ x: 1 })({ z: 3 });
// x:1 y:2 z:3

f4({ z: 3, x: 1 });
// x:1 y:2 z:3
</code></pre>
<p>While order is no longer a concern, usage of functions defined in this style
requires you to know what each argument's exact name is. You can't just
remember, &quot;oh, the function goes in as the first argument&quot; anymore. Instead, you
have to remember, &quot;the function parameter is called 'fn'.&quot; Conventions can
create consistency of naming that lessens this burden, but it's still something
to be aware of.</p>
<p>Weigh these trade-offs carefully.</p>
<h2><a class="header" href="#no-points" id="no-points">No Points</a></h2>
<p>A popular style of coding in the FP world aims to reduce some of the visual
clutter by removing unnecessary parameter-argument mapping. This style is
formally called tacit programming, or more commonly: point-free style. The term
&quot;point&quot; here is referring to a function's parameter input.</p>
<p><strong>Warning:</strong> Stop for a moment. Let's make sure we're careful not to take this
discussion as an unbounded suggestion that you go overboard trying to be
point-free in your FP code at all costs. This should be a technique for
improving readability, when used in moderation. But as with most things in
software development, you can definitely abuse it. If your code gets harder to
understand because of the hoops you have to jump through to be point-free, stop.
You won't win a blue ribbon just because you found some clever but esoteric way
to remove another &quot;point&quot; from your code.</p>
<p>Let's start with a simple example:</p>
<pre><code class="language-js">function double(x) {
  return x * 2;
}

[1, 2, 3, 4, 5].map(function mapper(v) {
  return double(v);
});
// [2,4,6,8,10]
</code></pre>
<p>Can you see that <code>mapper(..)</code> and <code>double(..)</code> have the same (or compatible,
anyway) signatures? The parameter (&quot;point&quot;) <code>v</code> can directly map to the
corresponding argument in the <code>double(..)</code> call. As such, the <code>mapper(..)</code>
function wrapper is unnecessary. Let's simplify with point-free style:</p>
<pre><code class="language-js">function double(x) {
  return x * 2;
}

[1, 2, 3, 4, 5].map(double);
// [2,4,6,8,10]
</code></pre>
<p>Let's revisit an example from earlier:</p>
<pre><code class="language-js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(function mapper(v) {
  return parseInt(v);
});
// [1,2,3]
</code></pre>
<p>In this example, <code>mapper(..)</code> is actually serving an important purpose, which is
to discard the <code>index</code> argument that <code>map(..)</code> would pass in, because
<code>parseInt(..)</code> would incorrectly interpret that value as a <code>radix</code> for the
parsing.</p>
<p>If you recall from the beginning of this chapter, this was an example where
<code>unary(..)</code> helps us out:</p>
<pre><code class="language-js">[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(unary(parseInt));
// [1,2,3]
</code></pre>
<p>Point-free!</p>
<p>The key thing to look for is if you have a function with parameter(s) that
is/are directly passed to an inner function call. In both of the preceding
examples, <code>mapper(..)</code> had the <code>v</code> parameter that was passed along to another
function call. We were able to replace that layer of abstraction with a
point-free expression using <code>unary(..)</code>.</p>
<p><strong>Warning:</strong> You might have been tempted, as I was, to try
<code>map(partialRight(parseInt,10))</code> to right-partially apply the <code>10</code> value as the
<code>radix</code>. However, as we saw earlier, <code>partialRight(..)</code> only guarantees that
<code>10</code> will be the last argument passed in, not that it will be specifically the
second argument. Since <code>map(..)</code> itself passes three arguments (<code>value</code>,
<code>index</code>, <code>arr</code>) to its mapping function, the <code>10</code> value would just be the fourth
argument to <code>parseInt(..)</code>; it only pays attention to the first two.</p>
<p><a name="shortlongenough"></a></p>
<p>Here's another example:</p>
<pre><code class="language-js">// convenience to avoid any potential binding issue
// with trying to use `console.log` as a function
function output(txt) {
  console.log(txt);
}

function printIf(predicate, msg) {
  if (predicate(msg)) {
    output(msg);
  }
}

function isShortEnough(str) {
  return str.length &lt;= 5;
}

var msg1 = &quot;Hello&quot;;
var msg2 = msg1 + &quot; World&quot;;

printIf(isShortEnough, msg1); // Hello
printIf(isShortEnough, msg2);
</code></pre>
<p>Now let's say you want to print a message only if it's long enough; in other
words, if it's <code>!isShortEnough(..)</code>. Your first thought is probably this:</p>
<pre><code class="language-js">function isLongEnough(str) {
  return !isShortEnough(str);
}

printIf(isLongEnough, msg1);
printIf(isLongEnough, msg2); // Hello World
</code></pre>
<p>Easy enough... but &quot;points&quot; now! See how <code>str</code> is passed through? Without
re-implementing the <code>str.length</code> check, can we refactor this code to point-free
style?</p>
<p>Let's define a <code>not(..)</code> negation helper (often referred to as <code>complement(..)</code>
in FP libraries):</p>
<pre><code class="language-js">function not(predicate) {
  return function negated(...args) {
    return !predicate(...args);
  };
}

// or the ES6 =&gt; arrow form
var not = predicate =&gt; (...args) =&gt; !predicate(...args);
</code></pre>
<p>Next, let's use <code>not(..)</code> to alternatively define <code>isLongEnough(..)</code> without
&quot;points&quot;:</p>
<pre><code class="language-js">var isLongEnough = not(isShortEnough);

printIf(isLongEnough, msg2); // Hello World
</code></pre>
<p>That's pretty good, isn't it? But we <em>could</em> keep going. <code>printIf(..)</code> could be
refactored to be point-free itself.</p>
<p>We can express the <code>if</code> conditional part with a <code>when(..)</code> utility:</p>
<pre><code class="language-js">function when(predicate, fn) {
  return function conditional(...args) {
    if (predicate(...args)) {
      return fn(...args);
    }
  };
}

// or the ES6 =&gt; form
var when = (predicate, fn) =&gt; (...args) =&gt;
  predicate(...args) ? fn(...args) : undefined;
</code></pre>
<p>Let's mix <code>when(..)</code> with a few other helper utilities we've seen earlier in
this chapter, to make the point-free <code>printIf(..)</code>:</p>
<pre><code class="language-js">var printIf = uncurry(partialRight(when, output));
</code></pre>
<p>Here's how we did it: we right-partially-applied the <code>output</code> method as the
second (<code>fn</code>) argument for <code>when(..)</code>, which leaves us with a function still
expecting the first argument (<code>predicate</code>). <em>That</em> function when called produces
another function expecting the message string; it would look like this:
<code>fn(predicate)(str)</code>.</p>
<p>A chain of multiple (two) function calls like that looks an awful lot like a
curried function, so we <code>uncurry(..)</code> this result to produce a single function
that expects the two <code>str</code> and <code>predicate</code> arguments together, which matches the
original <code>printIf(predicate,str)</code> signature.</p>
<p>Here's the whole example put back together (assuming various utilities we've
already detailed in this chapter are present):</p>
<p><a name="finalshortlong"></a></p>
<pre><code class="language-js">function output(msg) {
  console.log(msg);
}

function isShortEnough(str) {
  return str.length &lt;= 5;
}

var isLongEnough = not(isShortEnough);

var printIf = uncurry(partialRight(when, output));

var msg1 = &quot;Hello&quot;;
var msg2 = msg1 + &quot; World&quot;;

printIf(isShortEnough, msg1); // Hello
printIf(isShortEnough, msg2);

printIf(isLongEnough, msg1);
printIf(isLongEnough, msg2); // Hello World
</code></pre>
<p>Hopefully the FP practice of point-free style coding is starting to make a
little more sense. It'll still take a lot of practice to train yourself to think
this way naturally. <strong>And you'll still have to make judgement calls</strong> as to
whether point-free coding is worth it, as well as what extent will benefit your
code's readability.</p>
<p>What do you think? Points or no points for you?</p>
<p><strong>Note:</strong> Want more practice with point-free style coding? We'll revisit this
technique in <a href="chapter_4.html">Chapter 4, &quot;Revisiting Points&quot;</a>,
based on newfound knowledge of function composition.</p>
<h2><a class="header" href="#summary-2" id="summary-2">Summary</a></h2>
<p>Partial application is a technique for reducing the arity (that is, the expected
number of arguments to a function) by creating a new function where some of the
arguments are preset.</p>
<p>Currying is a special form of partial application where the arity is reduced to
1, with a chain of successive chained function calls, each which takes one
argument. Once all arguments have been specified by these function calls, the
original function is executed with all the collected arguments. You can also
undo a currying.</p>
<p>Other important utilities like <code>unary(..)</code>, <code>identity(..)</code>, and <code>constant(..)</code>
are part of the base toolbox for FP.</p>
<p>Point-free is a style of writing code that eliminates unnecessary verbosity of
mapping parameters (&quot;points&quot;) to arguments, with the goal of making code easier
to read/understand.</p>
<p>All of these techniques twist functions around so they can work together more
naturally. With your functions shaped compatibly now, the next chapter will
teach you how to combine them to model the flows of data through your program.</p>
<h1><a class="header" href="#functional-light-javascript-5" id="functional-light-javascript-5">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-4-composing-functions" id="chapter-4-composing-functions">Chapter 4: Composing Functions</a></h1>
<p>By now, I hope you're feeling much more comfortable with what it means to use
functions for functional programming.</p>
<p>A functional programmer sees every function in their program like a simple
little Lego piece. They recognize the blue 2x2 brick at a glance, and know
exactly how it works and what they can do with it. When they begin building a
bigger, more complex Lego model, as they need each next piece, they already have
an instinct for which of their many spare pieces to grab.</p>
<p>But sometimes you take the blue 2x2 brick and the gray 4x1 brick and put them
together in a certain way, and you realize, &quot;that's a useful piece that I need
often&quot;.</p>
<p>So now you've come up with a new &quot;piece&quot;, a combination of two other pieces, and
you can reach for that kind of piece now anytime you need it. It's more
effective to recognize and use this compound blue-gray L-brick thing where it's
needed than to separately think about assembling the two individual bricks each
time.</p>
<p>Functions come in a variety of shapes and sizes. And we can define a certain
combination of them to make a new compound function that will be handy in
various parts of the program. This process of using functions together is called
composition.</p>
<p>Composition is how an FPer models the flow of data through the program. In some
senses, it's the most foundational concept in all of FP, because without it, you
can't declaratively model data and state changes. In other words, everything
else in FP would collapse without composition.</p>
<h2><a class="header" href="#output-to-input" id="output-to-input">Output to Input</a></h2>
<p>We've already seen a few examples of composition. For example, our discussion of
<a href="chapter_3.html"><code>unary(..)</code> in Chapter 3</a> included this
expression: <a href="chapter_3.html"><code>[..].map(unary(parseInt))</code></a>.
Think about what's happening there.</p>
<p>To compose two functions together, pass the output of the first function call as
the input of the second function call. In <code>map(unary(parseInt))</code>, the
<code>unary(parseInt)</code> call returns a value (a function); that value is directly
passed as an argument to <code>map(..)</code>, which returns an array.</p>
<p>To take a step back and visualize the conceptual flow of data, consider:</p>
<pre><code class="language-txt">arrayValue &lt;-- map &lt;-- unary &lt;-- parseInt
</code></pre>
<p><code>parseInt</code> is the input to <code>unary(..)</code>. The output of <code>unary(..)</code> is the input
to <code>map(..)</code>. The output of <code>map(..)</code> is <code>arrayValue</code>. This is the composition
of <code>map(..)</code> and <code>unary(..)</code>.</p>
<p><strong>Note:</strong> The right-to-left orientation here is on purpose, though it may seem
strange at this point in your learning. We'll come back to explain that more
fully later.</p>
<p>Think of this flow of data like a conveyor belt in a candy factory, where each
operation is a step in the process of cooling, cutting, and wrapping a piece of
candy. We'll use the candy factory metaphor throughout this chapter to explain
what composition is.</p>
<p align="center">
    <img alt="figure" src="images/fig2.png">
</p>
<p>Let's examine composition in action one step at a time. Consider these two
utilities you might have in your program:</p>
<pre><code class="language-js">function words(str) {
  return String(str)
    .toLowerCase()
    .split(/\s|\b/)
    .filter(function alpha(v) {
      return /^[\w]+$/.test(v);
    });
}

function unique(list) {
  var uniqList = [];

  for (let v of list) {
    // value not yet in the new list?
    if (uniqList.indexOf(v) === -1) {
      uniqList.push(v);
    }
  }

  return uniqList;
}
</code></pre>
<p><code>words(..)</code> splits a string into an array of words. <code>unique(..)</code> takes a list of
words and filters it to not have any repeat words in it.</p>
<p>To use these two utilities to analyze a string of text:</p>
<pre><code class="language-js">var text =
  &quot;To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.&quot;;

var wordsFound = words(text);
var wordsUsed = unique(wordsFound);

wordsUsed;
// [&quot;to&quot;,&quot;compose&quot;,&quot;two&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;pass&quot;,
// &quot;the&quot;,&quot;output&quot;,&quot;of&quot;,&quot;first&quot;,&quot;function&quot;,&quot;call&quot;,&quot;as&quot;,
// &quot;input&quot;,&quot;second&quot;]
</code></pre>
<p>We name the array output of <code>words(..)</code> as <code>wordsFound</code>. The input of
<code>unique(..)</code> is also an array, so we can pass the <code>wordsFound</code> into it.</p>
<p>Back to the candy factory assembly line: the first machine takes as &quot;input&quot; the
melted chocolate, and its &quot;output&quot; is a chunk of formed and cooled chocolate.
The next machine a little down the assembly line takes as its &quot;input&quot; the chunk
of chocolate, and its &quot;output&quot; is a cut-up piece of chocolate candy. Next, a
machine on the line takes small pieces of chocolate candy from the conveyor belt
and outputs wrapped candies ready to bag and ship.</p>
<img alt="figure" src="images/fig3.png" align="right" width="9%" hspace="20">
<p>The candy factory is fairly successful with this process, but as with all
businesses, management keeps searching for ways to grow.</p>
<p>To keep up with demand for more candy production, they decide to take out the
conveyor belt contraption and just stack all three machines on top of one
another, so that the output valve of one is connected directly to the input
valve of the one below it. There's no longer sprawling wasted space where a
chunk of chocolate slowly and noisily rumbles down a conveyor belt from the
first machine to the second.</p>
<p>This innovation saves a lot of room on the factory floor, so management is happy
they'll get to make more candy each day!</p>
<p>The code equivalent of this improved candy factory configuration is to skip the
intermediate step (the <code>wordsFound</code> variable in the earlier snippet), and just
use the two function calls together:</p>
<pre><code class="language-js">var wordsUsed = unique(words(text));
</code></pre>
<p><strong>Note:</strong> Though we typically read the function calls left-to-right --
<code>unique(..)</code> and then <code>words(..)</code> -- the order of operations will actually be
more right-to-left, or inner-to-outer. <code>words(..)</code> will run first and then
<code>unique(..)</code>. Later we'll talk about a pattern that matches the order of
execution to our natural left-to-right reading, called <code>pipe(..)</code>.</p>
<p>The stacked machines are working fine, but it's kind of clunky to have the wires
hanging out all over the place. The more of these machine-stacks they create,
the more cluttered the factory floor gets. And the effort to assemble and
maintain all these machine stacks is awfully time intensive.</p>
<img alt="figure" src="images/fig4.png" align="left" width="15%" hspace="20">
<p>One morning, an engineer at the candy factory has a great idea. She figures that
it'd be much more efficient if she made an outer box to hide all the wires; on
the inside, all three of the machines are hooked up together, and on the outside
everything is now neat and tidy. On the top of this fancy new machine is a valve
to pour in melted chocolate and on the bottom is a valve that spits out wrapped
chocolate candies. Brilliant!</p>
<p>This single compound machine is much easier to move around and install wherever
the factory needs it. The workers on the factory floor are even happier because
they don't need to fidget with buttons and dials on three individual machines
anymore; they quickly prefer using the single fancy machine.</p>
<p>Relating back to the code: we now realize that the pairing of <code>words(..)</code> and
<code>unique(..)</code> in that specific order of execution (think: compound Lego) is
something we could use in several other parts of our application. So, let's
define a compound function that combines them:</p>
<pre><code class="language-js">function uniqueWords(str) {
  return unique(words(str));
}
</code></pre>
<p><code>uniqueWords(..)</code> takes a string and returns an array. It's a composition of the
two functions: <code>unique(..)</code> and <code>words(..)</code>; it creates this flow of data:</p>
<pre><code class="language-txt">wordsUsed &lt;-- unique &lt;-- words &lt;-- text
</code></pre>
<p>You probably recognize it by now: the unfolding revolution in candy factory
design is function composition.</p>
<h3><a class="header" href="#machine-making" id="machine-making">Machine Making</a></h3>
<p>The candy factory is humming along nicely, and thanks to all the saved space,
they now have plenty of room to try out making new kinds of candies. Building on
the earlier success, management is keen to keep inventing new fancy compound
machines for their growing candy assortment.</p>
<p>But the factory engineers struggle to keep up, because each time a new kind of
fancy compound machine needs to be made, they spend quite a bit of time making
the new outer box and fitting the individual machines into it.</p>
<p>So the factory engineers contact an industrial machine vendor for help. They're
amazed to find out that this vendor offers a <strong>machine-making</strong> machine! As
incredible as it sounds, they purchase a machine that can take a couple of the
factory's smaller machines -- the chocolate cooling one and the cutting one, for
example -- and wire them together automatically, even wrapping a nice clean
bigger box around them. This is surely going to make the candy factory really
take off!</p>
<p align="center">
    <img alt="figure" src="images/fig5.png" width="50%">
</p>
<p>Back to code land, let's consider a utility called <code>compose2(..)</code> that creates a
composition of two functions automatically, exactly the same way we did
manually:</p>
<pre><code class="language-js">function compose2(fn2, fn1) {
  return function composed(origValue) {
    return fn2(fn1(origValue));
  };
}

// or the ES6 =&gt; form
var compose2 = (fn2, fn1) =&gt; origValue =&gt; fn2(fn1(origValue));
</code></pre>
<p>Did you notice that we defined the parameter order as <code>fn2,fn1</code>, and furthermore
that it's the second function listed (aka <code>fn1</code> parameter name) that runs first,
then the first function listed (<code>fn2</code>)? In other words, the functions compose
from right-to-left.</p>
<p>That may seem like a strange choice, but there are some reasons for it. Most
typical FP libraries define their <code>compose(..)</code> to work right-to-left in terms
of ordering, so we're sticking with that convention.</p>
<p>But why? I think the easiest explanation (but perhaps not the most historically
accurate) is that we're listing them to match the order they are written in code
manually, or rather the order we encounter them when reading from left-to-right.</p>
<p><code>unique(words(str))</code> lists the functions in the left-to-right order
<code>unique, words</code>, so we make our <code>compose2(..)</code> utility accept them in that
order, too. The execution order is right-to-left, but the code order is
left-to-right. Pay close attention to keep those distinct in your mind.</p>
<p>Now, the more efficient definition of the candy making machine is:</p>
<pre><code class="language-js">var uniqueWords = compose2(unique, words);
</code></pre>
<h3><a class="header" href="#composition-variation" id="composition-variation">Composition Variation</a></h3>
<p>It may seem like the <code>&lt;-- unique &lt;-- words</code> combination is the only order these
two functions can be composed. But we could actually compose them in the
opposite order to create a utility with a bit of a different purpose:</p>
<pre><code class="language-js">var letters = compose2(words, unique);

var chars = letters(&quot;How are you Henry?&quot;);
chars;
// [&quot;h&quot;,&quot;o&quot;,&quot;w&quot;,&quot;a&quot;,&quot;r&quot;,&quot;e&quot;,&quot;y&quot;,&quot;u&quot;,&quot;n&quot;]
</code></pre>
<p>This works because the <code>words(..)</code> utility, for value-type safety sake, first
coerces its input to a string using <code>String(..)</code>. So the array that <code>unique(..)</code>
returns -- now the input to <code>words(..)</code> -- becomes the string
<code>&quot;H,o,w, ,a,r,e,y,u,n,?&quot;</code>, and then the rest of the behavior in <code>words(..)</code>
processes that string into the <code>chars</code> array.</p>
<p>Admittedly, this is a contrived example. But the point is that function
compositions are not always unidirectional. Sometimes we put the gray brick on
top of the blue brick, and sometimes we put the blue brick on top.</p>
<p>The candy factory better be careful if they try to feed the wrapped candies into
the machine that mixes and cools the chocolate!</p>
<h2><a class="header" href="#general-composition" id="general-composition">General Composition</a></h2>
<p>If we can define the composition of two functions, we can just keep going to
support composing any number of functions. The general data visualization flow
for any number of functions being composed looks like this:</p>
<pre><code class="language-txt">finalValue &lt;-- func1 &lt;-- func2 &lt;-- ... &lt;-- funcN &lt;-- origValue
</code></pre>
<p align="center">
    <img alt="figure" src="images/fig6.png" width="50%">
</p>
<p>Now the candy factory owns the best machine of all: a machine that can take any
number of separate smaller machines and spit out a big fancy machine that does
every step in order. That's one heck of a candy operation! It's Willy Wonka's
dream!</p>
<p>We can implement a general <code>compose(..)</code> utility like this:</p>
<p><a name="generalcompose"></a></p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    // copy the array of functions
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = list.pop()(result);
    }

    return result;
  };
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; result =&gt; {
  var list = [...fns];

  while (list.length &gt; 0) {
    // take the last function off the end of the list
    // and execute it
    result = list.pop()(result);
  }

  return result;
};
</code></pre>
<p><strong>Warning:</strong> <code>fns</code> is a collected array of arguments, not a passed-in array, and
as such, it's local to <code>compose(..)</code>. It may be tempting to think the <code>[...fns]</code>
would thus be unnecessary. However, in this particular implementation, <code>.pop()</code>
inside the inner <code>composed(..)</code> function is mutating the list, so if we didn't
make a copy each time, the returned composed function could only be used
reliably once. We'll revisit this hazard in
<a href="chapter_6.html">Chapter 6</a>.</p>
<p>Now let's look at an example of composing more than two functions. Recalling our
<code>uniqueWords(..)</code> composition example, let's add a <code>skipShortWords(..)</code> to the
mix:</p>
<pre><code class="language-js">function skipShortWords(words) {
  var filteredWords = [];

  for (let word of words) {
    if (word.length &gt; 4) {
      filteredWords.push(word);
    }
  }

  return filteredWords;
}
</code></pre>
<p>Let's define <code>biggerWords(..)</code> that includes <code>skipShortWords(..)</code>. The manual
composition equivalent is <code>skipShortWords( unique( words( text ) ) )</code>, so let's
do that with <code>compose(..)</code>:</p>
<pre><code class="language-js">var text =
  &quot;To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.&quot;;

var biggerWords = compose(skipShortWords, unique, words);

var wordsUsed = biggerWords(text);

wordsUsed;
// [&quot;compose&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;output&quot;,&quot;first&quot;,
// &quot;function&quot;,&quot;input&quot;,&quot;second&quot;]
</code></pre>
<p>To do something more interesting with composition, let's use
<a href="chapter_3.html"><code>partialRight(..)</code>, which we first looked at in Chapter 3</a>.
We can build a right-partial application of <code>compose(..)</code> itself, pre-specifying
the second and third arguments (<code>unique(..)</code> and <code>words(..)</code>, respectively);
we'll call it <code>filterWords(..)</code>.</p>
<p>Then, we can complete the composition multiple times by calling
<code>filterWords(..)</code>, but with different first-arguments respectively:</p>
<pre><code class="language-js">// Note: uses a `&lt;= 4` check instead of the `&gt; 4` check
// that `skipShortWords(..)` uses
function skipLongWords(list) {
  /* .. */
}

var filterWords = partialRight(compose, unique, words);

var biggerWords = filterWords(skipShortWords);
var shorterWords = filterWords(skipLongWords);

biggerWords(text);
// [&quot;compose&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;output&quot;,&quot;first&quot;,
// &quot;function&quot;,&quot;input&quot;,&quot;second&quot;]

shorterWords(text);
// [&quot;to&quot;,&quot;two&quot;,&quot;pass&quot;,&quot;the&quot;,&quot;of&quot;,&quot;call&quot;,&quot;as&quot;]
</code></pre>
<p>Take a moment to consider what the right-partial application on <code>compose(..)</code>
gives us. It allows us to specify ahead of time the first step(s) of a
composition, and then create specialized variations of that composition with
different subsequent steps (<code>biggerWords(..)</code> and <code>shorterWords(..)</code>). This is
one of the most powerful tricks of FP!</p>
<p>You can also <code>curry(..)</code> a composition instead of partial application, though
because of right-to-left ordering, you might more often want to
<code>curry( reverseArgs(compose), ..)</code> rather than just <code>curry( compose, ..)</code>
itself.</p>
<p><strong>Note:</strong> Because <code>curry(..)</code> (at least
<a href="chapter_3.html">the way we implemented it in Chapter 3</a>)
relies on either detecting the arity (<code>length</code>) or having it manually specified,
and <code>compose(..)</code> is a variadic function, you'll need to manually specify the
intended arity like <code>curry(.. , 3)</code>.</p>
<h3><a class="header" href="#alternative-implementations" id="alternative-implementations">Alternative Implementations</a></h3>
<p>While you may very well never implement your own <code>compose(..)</code> to use in
production, and rather just use a library's implementation as provided, I've
found that understanding how it works under the covers actually helps solidify
general FP concepts very well.</p>
<p>So let's examine some different implementation options for <code>compose(..)</code>. We'll
also see there are some pros/cons to each implementation, especially
performance.</p>
<p>We'll be looking at the
<a href="chapter_9.html"><code>reduce(..)</code> utility in detail in Chapter 9</a>, but for
now, just know that it reduces a list (array) to a single finite value. It's
like a fancy loop.</p>
<p>For example, if you did an addition-reduction across a list of numbers (such as
<code>[1,2,3,4,5,6]</code>), you'd loop over them adding them together as you go. The
reduction would add <code>1</code> to <code>2</code>, and add that result to <code>3</code>, and then add that
result to <code>4</code>, and so on, resulting in the final summation: <code>21</code>.</p>
<p>The original version of <code>compose(..)</code> uses a loop and eagerly (aka, immediately)
calculates the result of one call to pass into the next call. This is a
reduction of a list of functions, so we can do that same thing with
<code>reduce(..)</code>:</p>
<p><a name="composereduce"></a></p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    return [...fns].reverse().reduce(function reducer(result, fn) {
      return fn(result);
    }, result);
  };
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; result =&gt;
  [...fns].reverse().reduce((result, fn) =&gt; fn(result), result);
</code></pre>
<p><strong>Note:</strong> This implementation of <code>compose(..)</code> uses
<code>[...fns].reverse().reduce(..)</code> to reduce from right-to-left. We'll
<a href="chapter_9.html">revisit <code>compose(..)</code> in Chapter 9</a>,
instead using <code>reduceRight(..)</code> for that purpose.</p>
<p>Notice that the <code>reduce(..)</code> looping happens each time the final <code>composed(..)</code>
function is run, and that each intermediate <code>result(..)</code> is passed along to the
next iteration as the input to the next call.</p>
<p>The advantage of this implementation is that the code is more concise and also
that it uses a well-known FP construct: <code>reduce(..)</code>. And the performance of
this implementation is also similar to the original <code>for</code>-loop version.</p>
<p>However, this implementation is limited in that the outer composed function
(aka, the first function in the composition) can only receive a single argument.
Most other implementations pass along all arguments to that first call. If every
function in the composition is unary, this is no big deal. But if you need to
pass multiple arguments to that first call, you'd want a different
implementation.</p>
<p>To fix that first call single-argument limitation, we can still use <code>reduce(..)</code>
but produce a lazy-evaluation function wrapping:</p>
<pre><code class="language-js">function compose(...fns) {
  return fns.reverse().reduce(function reducer(fn1, fn2) {
    return function composed(...args) {
      return fn2(fn1(...args));
    };
  });
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt;
  fns.reverse().reduce((fn1, fn2) =&gt; (...args) =&gt; fn2(fn1(...args)));
</code></pre>
<p>Notice that we return the result of the <code>reduce(..)</code> call directly, which is
itself a function, not a computed result. <em>That</em> function lets us pass in as
many arguments as we want, passing them all down the line to the first function
call in the composition, then bubbling up each result through each subsequent
call.</p>
<p>Instead of calculating the running result and passing it along as the
<code>reduce(..)</code> looping proceeds, this implementation runs the <code>reduce(..)</code> looping
<strong>once</strong> up front at composition time, and defers all the function call
calculations -- referred to as lazy calculation. Each partial result of the
reduction is a successively more wrapped function.</p>
<p>When you call the final composed function and provide one or more arguments, all
the levels of the big nested function, from the inner most call to the outer,
are executed in reverse succession (not via a loop).</p>
<p>The performance characteristics will potentially be different than in the
previous <code>reduce(..)</code>-based implementation. Here, <code>reduce(..)</code> only runs once to
produce a big composed function, and then this composed function call simply
executes all its nested functions each call. In the former version, <code>reduce(..)</code>
would be run for every call.</p>
<p>Your mileage may vary on which implementation is better, but keep in mind that
this latter implementation isn't limited in argument count the way the former
one is.</p>
<p>We could also define <code>compose(..)</code> using recursion. The recursive definition for
<code>compose(fn1,fn2, .. fnN)</code> would look like:</p>
<pre><code class="language-txt">compose( compose(fn1,fn2, .. fnN-1), fnN );
</code></pre>
<p><strong>Note:</strong> We will cover recursion more fully in <a href="chapter_8.html">Chapter 8</a>, so if
this approach seems confusing, don't worry for now. Or, go read that chapter
then come back and re-read this note. :)</p>
<p>Here's how we implement <code>compose(..)</code> with recursion:</p>
<pre><code class="language-js">function compose(...fns) {
  // pull off the last two arguments
  var [fn1, fn2, ...rest] = fns.reverse();

  var composedFn = function composed(...args) {
    return fn2(fn1(...args));
  };

  if (rest.length == 0) return composedFn;

  return compose(...rest.reverse(), composedFn);
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; {
  // pull off the last two arguments
  var [fn1, fn2, ...rest] = fns.reverse();

  var composedFn = (...args) =&gt; fn2(fn1(...args));

  if (rest.length == 0) return composedFn;

  return compose(...rest.reverse(), composedFn);
};
</code></pre>
<p>I think the benefit of a recursive implementation is mostly conceptual. I
personally find it much easier to think about a repetitive action in recursive
terms instead of in a loop where I have to track the running result, so I prefer
the code to express it that way.</p>
<p>Others will find the recursive approach quite a bit more daunting to mentally
juggle. I invite you to make your own evaluations.</p>
<h2><a class="header" href="#reordered-composition" id="reordered-composition">Reordered Composition</a></h2>
<p>We talked earlier about the right-to-left ordering of standard <code>compose(..)</code>
implementations. The advantage is in listing the arguments (functions) in the
same order they'd appear if doing the composition manually.</p>
<p>The disadvantage is they're listed in the reverse order that they execute, which
could be confusing. It was also more awkward to have to use
<code>partialRight(compose, ..)</code> to pre-specify the <em>first</em> function(s) to execute in
the composition.</p>
<p>The reverse ordering, composing from left-to-right, has a common name:
<code>pipe(..)</code>. This name is said to come from Unix/Linux land, where multiple
programs are strung together by &quot;pipe&quot;ing (<code>|</code> operator) the output of the first
one in as the input of the second, and so on (i.e.,
<code>ls -la | grep &quot;foo&quot; | less</code>).</p>
<p><code>pipe(..)</code> is identical to <code>compose(..)</code> except it processes through the list of
functions in left-to-right order:</p>
<pre><code class="language-js">function pipe(...fns) {
  return function piped(result) {
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the first function from the list
      // and execute it
      result = list.shift()(result);
    }

    return result;
  };
}
</code></pre>
<p>In fact, we could just define <code>pipe(..)</code> as the arguments-reversal of
<code>compose(..)</code>:</p>
<pre><code class="language-js">var pipe = reverseArgs(compose);
</code></pre>
<p>That was easy!</p>
<p>Recall this example from general composition earlier:</p>
<pre><code class="language-js">var biggerWords = compose(skipShortWords, unique, words);
</code></pre>
<p>To express that with <code>pipe(..)</code>, we just reverse the order we list them in:</p>
<pre><code class="language-js">var biggerWords = pipe(words, unique, skipShortWords);
</code></pre>
<p>The advantage of <code>pipe(..)</code> is that it lists the functions in order of
execution, which can sometimes reduce reader confusion. It may be simpler to
read the code: <code>pipe( words, unique, skipShortWords )</code>, and recognize that it's
executing <code>words(..)</code> first, then <code>unique(..)</code>, and finally
<code>skipShortWords(..)</code>.</p>
<p><code>pipe(..)</code> is also handy if you're in a situation where you want to partially
apply the <em>first</em> function(s) that execute. Earlier we did that with
right-partial application of <code>compose(..)</code>.</p>
<p>Compare:</p>
<pre><code class="language-js">var filterWords = partialRight(compose, unique, words);

// vs

var filterWords = partial(pipe, words, unique);
</code></pre>
<p>As you may recall from our first implementation of
<a href="chapter_3.html"><code>partialRight(..)</code> in Chapter 3</a>, it
uses <code>reverseArgs(..)</code> under the covers, just as our <code>pipe(..)</code> now does. So we
get the same result either way.</p>
<p><em>In this specific case</em>, the slight performance advantage to using <code>pipe(..)</code>
is, because we're not trying to preserve the right-to-left argument order of
<code>compose(..)</code>, we don't need to reverse the argument order back, like we do
inside <code>partialRight(..)</code>. So <code>partial(pipe, ..)</code> is a little more efficient
here than <code>partialRight(compose, ..)</code>.</p>
<h2><a class="header" href="#abstraction" id="abstraction">Abstraction</a></h2>
<p>Abstraction plays heavily into our reasoning about composition, so let's examine
it in more detail.</p>
<p>Similar to how partial application and currying (see
<a href="chapter_3.html">Chapter 3</a>) allow a progression from
generalized to specialized functions, we can abstract by pulling out the
generality between two or more tasks. The general part is defined once, so as to
avoid repetition. To perform each task's specialization, the general part is
parameterized.</p>
<p>For example, consider this (obviously contrived) code:</p>
<pre><code class="language-js">function saveComment(txt) {
  if (txt != &quot;&quot;) {
    comments[comments.length] = txt;
  }
}

function trackEvent(evt) {
  if (evt.name !== undefined) {
    events[evt.name] = evt;
  }
}
</code></pre>
<p>Both of these utilities are storing a value in a data source. That's the
generality. The specialty is that one of them sticks the value at the end of an
array, while the other sets the value at a property name of an object.</p>
<p>So let's abstract:</p>
<pre><code class="language-js">function storeData(store, location, value) {
  store[location] = value;
}

function saveComment(txt) {
  if (txt != &quot;&quot;) {
    storeData(comments, comments.length, txt);
  }
}

function trackEvent(evt) {
  if (evt.name !== undefined) {
    storeData(events, evt.name, evt);
  }
}
</code></pre>
<p>The general task of referencing a property on an object (or array, thanks to
JS's convenient operator overloading of <code>[ ]</code>) and setting its value is
abstracted into its own function <code>storeData(..)</code>. While this utility only has a
single line of code right now, one could envision other general behavior that
was common across both tasks, such as generating a unique numeric ID or storing
a timestamp with the value.</p>
<p>If we repeat the common general behavior in multiple places, we run the
maintenance risk of changing some instances but forgetting to change others.
There's a principle at play in this kind of abstraction, often referred to as
&quot;don't repeat yourself&quot; (DRY).</p>
<p>DRY strives to have only one definition in a program for any given task. An
alternative aphorism to motivate DRY coding is that programmers are just
generally lazy and don't want to do unnecessary work.</p>
<p>Abstraction can be taken too far. Consider:</p>
<pre><code class="language-js">function conditionallyStoreData(store, location, value, checkFn) {
  if (checkFn(value, store, location)) {
    store[location] = value;
  }
}

function notEmpty(val) {
  return val != &quot;&quot;;
}

function isUndefined(val) {
  return val === undefined;
}

function isPropUndefined(val, obj, prop) {
  return isUndefined(obj[prop]);
}

function saveComment(txt) {
  conditionallyStoreData(comments, comments.length, txt, notEmpty);
}

function trackEvent(evt) {
  conditionallyStoreData(events, evt.name, evt, isPropUndefined);
}
</code></pre>
<p>In an effort to be DRY and avoid repeating an <code>if</code> statement, we moved the
conditional into the general abstraction. We also assumed that we <em>may</em> have
checks for non-empty strings or non-<code>undefined</code> values elsewhere in the program
in the future, so we might as well DRY those out, too!</p>
<p>This code <em>is</em> more DRY, but to an overkill extent. Programmers must be careful
to apply the appropriate levels of abstraction to each part of their program, no
more, no less.</p>
<p>Regarding our greater discussion of function composition in this chapter, it
might seem like its benefit is this kind of DRY abstraction. But let's not jump
to that conclusion, because I think composition actually serves a more important
purpose in our code.</p>
<p>Moreover, <strong>composition is helpful even if there's only one occurrence of
something</strong> (no repetition to DRY out).</p>
<h3><a class="header" href="#separation-enables-focus" id="separation-enables-focus">Separation Enables Focus</a></h3>
<p>Aside from generalization vs. specialization, I think there's another more
useful definition for abstraction, as revealed by this quote:</p>
<blockquote>
<p>... abstraction is a process by which the programmer associates a name with a
potentially complicated program fragment, which can then be thought of in
terms of its purpose of function, rather than in terms of how that function is
achieved. By hiding irrelevant details, abstraction reduces conceptual
complexity, making it possible for the programmer to focus on a manageable
subset of the program text at any particular time.</p>
<p>Michael L. Scott, Programming Language
Pragmatics<a href="chapter_4.html#user-content-footnote-1"><sup>1</sup></a></p>
</blockquote>
<p>The point this quote makes is that abstraction -- generally, pulling out some
piece of code into its own function -- serves the primary purpose of separating
apart two pieces of functionality so that it's possible to focus on each piece
independently of the other.</p>
<p>Note that abstraction in this sense is not really intended to <em>hide</em> details, as
if to treat things as black boxes we <em>never</em> examine.</p>
<p>In this quote, &quot;irrelevant&quot;, in terms of what is hidden, shouldn't be thought of
as an absolute qualitative judgement, but rather relative to what you want to
focus on at any given moment. In other words, when we separate X from Y, if I
want to focus on X, Y is irrelevant at that moment. At another time, if I want
to focus on Y, X is irrelevant at that moment.</p>
<p><strong>We're not abstracting to hide details; we're separating details to improve
focus.</strong></p>
<p>Recall that at the outset of this book I stated that FP's goal is to create code
that is more readable and understandable. One effective way of doing that is
untangling complected (read: tightly braided, as in strands of rope) code into
separate, simpler (read: loosely bound) pieces of code. In that way, the reader
isn't distracted by the details of one part while looking for the details of the
other part.</p>
<p>Our higher goal is not to implement something only once, as it is with the DRY
mindset. As a matter of fact, sometimes we'll actually repeat ourselves in code.</p>
<p>As we
<a href="chapter_3.html">asserted in Chapter 3</a>, the
main goal with abstraction is to implement separate things, separately. We're
trying to improve focus, because that improves readability.</p>
<p>By separating two ideas, we insert a semantic boundary between them, which
affords us the ability to focus on each side independent of the other. In many
cases, that semantic boundary is something like the name of a function. The
function's implementation is focused on <em>how</em> to compute something, and the
call-site using that function by name is focused on <em>what</em> to do with its
output. We abstract the <em>how</em> from the <em>what</em> so they are separate and
separately reason'able.</p>
<p>Another way of describing this goal is with imperative vs. declarative
programming style. Imperative code is primarily concerned with explicitly
stating <em>how</em> to accomplish a task. Declarative code states <em>what</em> the outcome
should be, and leaves the implementation to some other responsibility.</p>
<p>Declarative code abstracts the <em>what</em> from the <em>how</em>. Typically declarative
coding is favored in readability over imperative, though no program (except of
course machine code 1s and 0s) is ever entirely one or the other. The programmer
must seek balance between them.</p>
<p>ES6 added many syntactic affordances that transform old imperative operations
into newer declarative forms. Perhaps one of the clearest is destructuring.
Destructuring is a pattern for assignment that describes how a compound value
(object, array) is taken apart into its constituent values.</p>
<p>Here's an example of array destructuring:</p>
<pre><code class="language-js">function getData() {
  return [1, 2, 3, 4, 5];
}

// imperative
var tmp = getData();
var a = tmp[0];
var b = tmp[3];

// declarative
var [a, , , b] = getData();
</code></pre>
<p>The <em>what</em> is assigning the first value of the array to <code>a</code> and the fourth value
to <code>b</code>. The <em>how</em> is getting a reference to the array (<code>tmp</code>) and manually
referencing indexes <code>0</code> and <code>3</code> in assignments to <code>a</code> and <code>b</code>, respectively.</p>
<p>Does the array destructuring <em>hide</em> the assignment? Depends on your perspective.
I'm asserting that it simply separates the <em>what</em> from the <em>how</em>. The JS engine
still does the assignments, but it prevents you from having to be distracted by
<em>how</em> it's done.</p>
<p>Instead, you read <code>[ a ,,, b ] = ..</code> and can see the assignment pattern merely
telling you <em>what</em> will happen. Array destructuring is an example of declarative
abstraction.</p>
<h3><a class="header" href="#composition-as-abstraction" id="composition-as-abstraction">Composition as Abstraction</a></h3>
<p>What's all this have to do with function composition? Function composition is
also declarative abstraction.</p>
<p>Recall the <code>shorterWords(..)</code> example from earlier. Let's compare an imperative
and declarative definition for it:</p>
<pre><code class="language-js">// imperative
function shorterWords(text) {
  return skipLongWords(unique(words(text)));
}

// declarative
var shorterWords = compose(skipLongWords, unique, words);
</code></pre>
<p>The declarative form focuses on the <em>what</em> -- these three functions pipe data
from a string to a list of shorter words -- and leaves the <em>how</em> to the
internals of <code>compose(..)</code>.</p>
<p>In a bigger sense, the <code>shorterWords = compose(..)</code> line explains the <em>how</em> for
defining a <code>shorterWords(..)</code> utility, leaving this declarative line somewhere
else in the code to focus only on the <em>what</em>:</p>
<pre><code class="language-js">shorterWords(text);
</code></pre>
<p>Composition abstracts getting a list of shorter words from the steps it takes to
do that.</p>
<p>By contrast, what if we hadn't used composition abstraction?</p>
<pre><code class="language-js">var wordsFound = words(text);
var uniqueWordsFound = unique(wordsFound);
skipLongWords(uniqueWordsFound);
</code></pre>
<p>Or even:</p>
<pre><code class="language-js">skipLongWords(unique(words(text)));
</code></pre>
<p>Either of these two versions demonstrates a more imperative style as opposed to
the prior declarative style. The reader's focus in those two snippets is
inextricably tied to the <em>how</em> and less on the <em>what</em>.</p>
<p>Function composition isn't just about saving code with DRY. Even if the usage of
<code>shorterWords(..)</code> only occurs in one place -- so there's no repetition to
avoid! -- separating the <em>how</em> from the <em>what</em> still improves our code.</p>
<p>Composition is a powerful tool for abstraction that transforms imperative code
into more readable declarative code.</p>
<h2><a class="header" href="#revisiting-points" id="revisiting-points">Revisiting Points</a></h2>
<p>Now that we've thoroughly covered composition (a trick that will be immensely
helpful in many areas of FP), let's watch it in action by revisiting point-free
style from <a href="chapter_3.html">Chapter 3, &quot;No Points&quot;</a> with a scenario
that's a fair bit more complex to refactor:</p>
<pre><code class="language-js">// given: ajax( url, data, cb )

var getPerson = partial(ajax, &quot;http://some.api/person&quot;);
var getLastOrder = partial(ajax, &quot;http://some.api/order&quot;, { id: -1 });

getLastOrder(function orderFound(order) {
  getPerson({ id: order.personId }, function personFound(person) {
    output(person.name);
  });
});
</code></pre>
<p>The &quot;points&quot; we'd like to remove are the <code>order</code> and <code>person</code> parameter
references.</p>
<p>Let's start by trying to get the <code>person</code> &quot;point&quot; out of the <code>personFound(..)</code>
function. To do so, let's first define:</p>
<pre><code class="language-js">function extractName(person) {
  return person.name;
}
</code></pre>
<p>Consider that this operation could instead be expressed in generic terms:
extracting any property by name off of any object. Let's call such a utility
<code>prop(..)</code>:</p>
<pre><code class="language-js">function prop(name, obj) {
  return obj[name];
}

// or the ES6 =&gt; form
var prop = (name, obj) =&gt; obj[name];
</code></pre>
<p>While we're dealing with object properties, let's also define the opposite
utility: <code>setProp(..)</code> for setting a property value onto an object.</p>
<p>However, we want to be careful not to just mutate an existing object but rather
create a clone of the object to make the change to, and then return it. The
reasons for such care will be discussed at length in <a href="chapter_5.html">Chapter 5</a>.</p>
<p><a name="setprop"></a></p>
<pre><code class="language-js">function setProp(name, obj, val) {
  var o = Object.assign({}, obj);
  o[name] = val;
  return o;
}
</code></pre>
<p>Now, to define an <code>extractName(..)</code> that pulls a <code>&quot;name&quot;</code> property off an
object, we'll partially apply <code>prop(..)</code>:</p>
<pre><code class="language-js">var extractName = partial(prop, &quot;name&quot;);
</code></pre>
<p><strong>Note:</strong> Don't miss that <code>extractName(..)</code> here hasn't actually extracted
anything yet. We partially applied <code>prop(..)</code> to make a function that's waiting
to extract the <code>&quot;name&quot;</code> property from whatever object we pass into it. We could
also have done it with <code>curry(prop)(&quot;name&quot;)</code>.</p>
<p>Next, let's narrow the focus on our example's nested lookup calls to this:</p>
<pre><code class="language-js">getLastOrder(function orderFound(order) {
  getPerson({ id: order.personId }, outputPersonName);
});
</code></pre>
<p>How can we define <code>outputPersonName(..)</code>? To visualize what we need, think about
the desired flow of data:</p>
<pre><code class="language-txt">output &lt;-- extractName &lt;-- person
</code></pre>
<p><code>outputPersonName(..)</code> needs to be a function that takes an (object) value,
passes it into <code>extractName(..)</code>, then passes that value to <code>output(..)</code>.</p>
<p>Hopefully you recognized that as a <code>compose(..)</code> operation. So we can define
<code>outputPersonName(..)</code> as:</p>
<pre><code class="language-js">var outputPersonName = compose(output, extractName);
</code></pre>
<p>The <code>outputPersonName(..)</code> function we just created is the callback provided to
<code>getPerson(..)</code>. So we can define a function called <code>processPerson(..)</code> that
presets the callback argument, using <code>partialRight(..)</code>:</p>
<pre><code class="language-js">var processPerson = partialRight(getPerson, outputPersonName);
</code></pre>
<p>Let's reconstruct the nested lookups example again with our new function:</p>
<pre><code class="language-js">getLastOrder(function orderFound(order) {
  processPerson({ id: order.personId });
});
</code></pre>
<p>Phew, we're making good progress!</p>
<p>But we need to keep going and remove the <code>order</code> &quot;point&quot;. The next step is to
observe that <code>personId</code> can be extracted from an object (like <code>order</code>) via
<code>prop(..)</code>, just like we did with <code>name</code> on the <code>person</code> object:</p>
<pre><code class="language-js">var extractPersonId = partial(prop, &quot;personId&quot;);
</code></pre>
<p>To construct the object (of the form <code>{ id: .. }</code>) that needs to be passed to
<code>processPerson(..)</code>, let's make another utility for wrapping a value in an
object at a specified property name, called <code>makeObjProp(..)</code>:</p>
<pre><code class="language-js">function makeObjProp(name, value) {
  return setProp(name, {}, value);
}

// or the ES6 =&gt; form
var makeObjProp = (name, value) =&gt; setProp(name, {}, value);
</code></pre>
<p><strong>Tip:</strong> This utility is known as <code>objOf(..)</code> in the Ramda library.</p>
<p>Just as we did with <code>prop(..)</code> to make <code>extractName(..)</code>, we'll partially apply
<code>makeObjProp(..)</code> to build a function <code>personData(..)</code> that makes our data
object:</p>
<pre><code class="language-js">var personData = partial(makeObjProp, &quot;id&quot;);
</code></pre>
<p>To use <code>processPerson(..)</code> to perform the lookup of a person attached to an
<code>order</code> value, the conceptual flow of data through operations we need is:</p>
<pre><code class="language-txt">processPerson &lt;-- personData &lt;-- extractPersonId &lt;-- order
</code></pre>
<p>So we'll just use <code>compose(..)</code> again to define a <code>lookupPerson(..)</code> utility:</p>
<pre><code class="language-js">var lookupPerson = compose(processPerson, personData, extractPersonId);
</code></pre>
<p>And... that's it! Putting the whole example back together without any &quot;points&quot;:</p>
<pre><code class="language-js">var getPerson = partial(ajax, &quot;http://some.api/person&quot;);
var getLastOrder = partial(ajax, &quot;http://some.api/order&quot;, { id: -1 });

var extractName = partial(prop, &quot;name&quot;);
var outputPersonName = compose(output, extractName);
var processPerson = partialRight(getPerson, outputPersonName);
var personData = partial(makeObjProp, &quot;id&quot;);
var extractPersonId = partial(prop, &quot;personId&quot;);
var lookupPerson = compose(processPerson, personData, extractPersonId);

getLastOrder(lookupPerson);
</code></pre>
<p>Wow. Point-free. And <code>compose(..)</code> turned out to be really helpful in two
places!</p>
<p>I think in this case, even though the steps to derive our final answer were a
bit drawn out, the end result is much more readable code, because we've ended up
explicitly calling out each step.</p>
<p>And even if you didn't like seeing/naming all those intermediate steps, you can
preserve point-free but wire the expressions together without individual
variables:</p>
<pre><code class="language-js">partial(ajax, &quot;http://some.api/order&quot;, { id: -1 })(
  compose(
    partialRight(
      partial(ajax, &quot;http://some.api/person&quot;),
      compose(output, partial(prop, &quot;name&quot;))
    ),
    partial(makeObjProp, &quot;id&quot;),
    partial(prop, &quot;personId&quot;)
  )
);
</code></pre>
<p>This snippet is less verbose for sure, but I think it's less readable than the
previous snippet where each operation is its own variable. Either way,
composition helped us with our point-free style.</p>
<h2><a class="header" href="#summary-3" id="summary-3">Summary</a></h2>
<p>Function composition is a pattern for defining a function that routes the output
of one function call into another function call, and its output to another, and
so on.</p>
<p>Because JS functions can only return single values, the pattern essentially
dictates that all functions in the composition (except perhaps the first called)
need to be unary, taking only a single input from the output of the previous
function.</p>
<p>Instead of listing out each step as a discrete call in our code, function
composition using a utility like <code>compose(..)</code> or <code>pipe(..)</code> abstracts that
implementation detail so the code is more readable, allowing us to focus on
<em>what</em> the composition will be used to accomplish, not <em>how</em> it will be
performed.</p>
<p>Composition is declarative data flow, meaning our code describes the flow of
data in an explicit, obvious, and readable way.</p>
<p>In many ways, composition is the most important foundational pattern, in large
part because it's the only way to route data through our programs aside from
using side effects; the next chapter explores why such should be avoided
wherever possible.</p>
<hr />
<p><a name="footnote-1"><sup>1</sup></a>Scott, Michael L. “Chapter 3: Names,
Scopes, and Bindings.” Programming Language Pragmatics, 4th ed., Morgan
Kaufmann, 2015, pp. 115.</p>
<h1><a class="header" href="#functional-light-javascript-6" id="functional-light-javascript-6">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-5-reducing-side-effects" id="chapter-5-reducing-side-effects">Chapter 5: Reducing Side Effects</a></h1>
<p>In <a href="chapter_2.html">Chapter 2</a>, we discussed how a function can have outputs
besides its <code>return</code> value. By now you should be very comfortable with the FP
definition of a function, so the idea of such side outputs -- side effects! --
should smell.</p>
<p>We're going to examine the various different forms of side effects and see why
they are harmful to our code's quality and readability.</p>
<p>But let me not bury the lede here. The punchline to this chapter: it's
impossible to write a program with no side effects. Well, not impossible; you
certainly can. But that program won't do anything useful or observable. If you
wrote a program with zero side effects, you wouldn't be able to tell the
difference between it and an empty program.</p>
<p>The FPer doesn't eliminate all side effects. Rather, the goal is to limit them
as much as possible. To do that, we first need to fully understand them.</p>
<h2><a class="header" href="#effects-on-the-side-please" id="effects-on-the-side-please">Effects on the Side, Please</a></h2>
<p>Cause and effect: one of the most fundamental, intuitive observations we humans
can make about the world around us. Push a book off the edge of a table, it
falls to the ground. You don't need a physics degree to know that the cause was
you pushing the book and the effect was gravity pulling it to the ground.
There's a clear and direct relationship.</p>
<p>In programming, we also deal entirely in cause and effect. If you call a
function (cause), it displays a message on the screen (effect).</p>
<p>When reading a program, it's supremely important that the reader be able to
clearly identify each cause and each effect. To any extent where a direct
relationship between cause and effect cannot be seen readily upon a read-through
of the program, that program's readability is degraded.</p>
<p>Consider:</p>
<pre><code class="language-js">function foo(x) {
  return x * 2;
}

var y = foo(3);
</code></pre>
<p>In this trivial program, it is immediately clear that calling foo (the cause)
with value <code>3</code> will have the effect of returning the value <code>6</code> that is then
assigned to <code>y</code> (the effect). There's no ambiguity here.</p>
<p>But now:</p>
<pre><code class="language-js">function foo(x) {
  y = x * 2;
}

var y;

foo(3);
</code></pre>
<p>This program has the exact same outcome. But there's a very big difference. The
cause and the effect are disjoint. The effect is indirect. The setting of <code>y</code> in
this way is what we call a side effect.</p>
<p><strong>Note:</strong> When a function makes a reference to a variable outside itself, this
is called a free variable. Not all free variable references will be bad, but
we'll want to be very careful with them.</p>
<p>What if I gave you a reference to call a function <code>bar(..)</code> that you cannot see
the code for, but I told you that it had no such indirect side effects, only an
explicit <code>return</code> value effect?</p>
<pre><code class="language-js">bar(4); // 42
</code></pre>
<p>Because you know that the internals of <code>bar(..)</code> do not create any side effects,
you can now reason about any <code>bar(..)</code> call like this one in a much more
straightforward way. But if you didn't know that <code>bar(..)</code> had no side effects,
to understand the outcome of calling it, you'd have to go read and dissect all
of its logic. This is extra mental tax burden for the reader.</p>
<p><strong>The readability of a side effecting function is worse</strong> because it requires
more reading to understand the program.</p>
<p>But the problem goes deeper than that. Consider:</p>
<pre><code class="language-js">var x = 1;

foo();

console.log(x);

bar();

console.log(x);

baz();

console.log(x);
</code></pre>
<p>How sure are you which values are going to be printed at each <code>console.log(x)</code>?</p>
<p>The correct answer is: not at all. If you're not sure whether <code>foo()</code>, <code>bar()</code>,
and <code>baz()</code> are side-effecting or not, you cannot guarantee what <code>x</code> will be at
each step unless you inspect the implementations of each, <strong>and</strong> then trace the
program from line 1 forward, keeping track of all the changes in state as you
go.</p>
<p>In other words, the final <code>console.log(x)</code> is impossible to analyze or predict
unless you've mentally executed the whole program up to that point.</p>
<p>Guess who's good at running your program? The JS engine. Guess who's not as good
at running your program? The reader of your code. And yet, your choice to write
code (potentially) with side effects in one or more of those function calls
means that you've burdened the reader with having to mentally execute your
program in its entirety up to a certain line, for them to read and understand
that line.</p>
<p>If <code>foo()</code>, <code>bar()</code>, and <code>baz()</code> were all free of side effects, they could not
affect <code>x</code>, which means we do not need to execute them to mentally trace what
happens with <code>x</code>. This is less mental tax, and makes the code more readable.</p>
<h3><a class="header" href="#hidden-causes" id="hidden-causes">Hidden Causes</a></h3>
<p>Outputs, changes in state, are the most commonly cited manifestation of side
effects. But another readability-harming practice is what some refer to as side
causes. Consider:</p>
<pre><code class="language-js">function foo(x) {
  return x + y;
}

var y = 3;

foo(1); // 4
</code></pre>
<p><code>y</code> is not changed by <code>foo(..)</code>, so it's not the same kind of side effect as we
saw before. But now, the calling of <code>foo(..)</code> actually depends on the presence
and current state of a <code>y</code>. If later, we do:</p>
<pre><code class="language-js">y = 5;

// ..

foo(1); // 6
</code></pre>
<p>Might we be surprised that the call to <code>foo(1)</code> returned different results from
call to call?</p>
<p><code>foo(..)</code> has an indirection of cause that is harmful to readability. The reader
cannot see, without inspecting <code>foo(..)</code>'s implementation carefully, what causes
are contributing to the output effect. It <em>looks</em> like the argument <code>1</code> is the
only cause, but it turns out it's not.</p>
<p>To aid readability, all of the causes that will contribute to determining the
effect output of <code>foo(..)</code> should be made as direct and obvious inputs to
<code>foo(..)</code>. The reader of the code will clearly see the cause(s) and effect.</p>
<h4><a class="header" href="#fixed-state" id="fixed-state">Fixed State</a></h4>
<p>Does avoiding side causes mean the <code>foo(..)</code> function cannot reference any free
variables?</p>
<p>Consider this code:</p>
<pre><code class="language-js">function foo(x) {
  return x + bar(x);
}

function bar(x) {
  return x * 2;
}

foo(3); // 9
</code></pre>
<p>It's clear that for both <code>foo(..)</code> and <code>bar(..)</code>, the only direct cause is the
<code>x</code> parameter. But what about the <code>bar(x)</code> call? <code>bar</code> is just an identifier,
and in JS it's not even a constant (aka, non-reassignable variable) by default.
The <code>foo(..)</code> function is relying on the value of <code>bar</code> -- a variable that
references the second function -- as a free variable.</p>
<p>So is this program relying on a side cause?</p>
<p>I say no. Even though it is <em>possible</em> to overwrite the <code>bar</code> variable's value
with some other function, I am not doing so in this code, nor is it a common
practice of mine or precedent to do so. For all intents and purposes, my
functions are constants (never reassigned).</p>
<p>Consider:</p>
<pre><code class="language-js">const PI = 3.141592;

function foo(x) {
  return x * PI;
}

foo(3); // 9.424776000000001
</code></pre>
<p><strong>Note:</strong> JavaScript has <code>Math.PI</code> built-in, so we're only using the <code>PI</code>
example in this text as a convenient illustration. In practice, always use
<code>Math.PI</code> instead of defining your own!</p>
<p>How about the preceding code snippet? Is <code>PI</code> a side cause of <code>foo(..)</code>?</p>
<p>Two observations will help us answer that question in a reasonable way:</p>
<ol>
<li>
<p>Think about every call you might ever make to <code>foo(3)</code>. Will it always return
that <code>9.424..</code> value? <strong>Yes.</strong> Every single time. If you give it the same
input (<code>x</code>), it will always return the same output.</p>
</li>
<li>
<p>Could you replace every usage of <code>PI</code> with its immediate value, and could the
program run <strong>exactly</strong> the same as it did before? <strong>Yes.</strong> There's no part
of this program that relies on being able to change the value of <code>PI</code> --
indeed since it's a <code>const</code>, it cannot be reassigned -- so the <code>PI</code> variable
here is only for readability/maintenance sake. Its value can be inlined
without any change in program behavior.</p>
</li>
</ol>
<p>My conclusion: <code>PI</code> here is not a violation of the spirit of minimizing/avoiding
side effects (or causes). Nor is the <code>bar(x)</code> call in the previous snippet.</p>
<p>In both cases, <code>PI</code> and <code>bar</code> are not part of the state of the program. They're
fixed, non-reassigned references. If they don't change throughout the program,
we don't have to worry about tracking them as changing state. As such, they
don't harm our readability. And they cannot be the source of bugs related to
variables changing in unexpected ways.</p>
<p><strong>Note:</strong> The use of <code>const</code> here does not, in my opinion, make the case that
<code>PI</code> is absolved as a side cause; <code>var PI</code> would lead to the same conclusion.
The lack of reassigning <code>PI</code> is what matters, not the inability to do so. We'll
discuss <a href="chapter_6.html"><code>const</code> in Chapter 6</a>.</p>
<h4><a class="header" href="#randomness" id="randomness">Randomness</a></h4>
<p>You may never have considered it before, but randomness is a side cause. A
function that uses <code>Math.random()</code> cannot have predictable output based on its
input. So any code that generates unique random IDs/etc. will by definition be
considered reliant on the program's side causes.</p>
<p>In computing, we use what's called pseudo-random algorithms for generation.
Turns out true randomness is pretty hard, so we just kinda fake it with complex
algorithms that produce values that seem observably random. These algorithms
calculate long streams of numbers, but the secret is, the sequence is actually
predictable if you know the starting point. This starting point is referred to
as a seed.</p>
<p>Some languages let you specify the seed value for the random number generation.
If you always specify the same seed, you'll always get the same sequence of
outputs from subsequent &quot;pseudo-random number&quot; generations. This is incredibly
useful for testing purposes, for example, but incredibly dangerous for
real-world application usage.</p>
<p>In JS, the randomness of <code>Math.random()</code> calculation is based on an indirect
input, because you cannot specify the seed. As such, we have to treat built-in
random number generation as a side cause.</p>
<h3><a class="header" href="#io-effects" id="io-effects">I/O Effects</a></h3>
<p>The most common (and essentially unavoidable) form of side cause/effect is
input/output (I/O). A program with no I/O is totally pointless, because its work
cannot be observed in any way. Useful programs must at a minimum have output,
and many also need input. Input is a side cause and output is a side effect.</p>
<p>The typical input for the browser JS programmer is user events (mouse,
keyboard), and for output is the DOM. If you work more in Node.js, you may more
likely receive input from, and send output to, the file system, network
connections, and/or the <code>stdin</code>/<code>stdout</code> streams.</p>
<p>As a matter of fact, these sources can be both input and output, both cause and
effect. Take the DOM, for example. We update (side effect) a DOM element to show
text or an image to the user, but the current state of the DOM is an implicit
input (side cause) to those operations as well.</p>
<h3><a class="header" href="#side-bugs" id="side-bugs">Side Bugs</a></h3>
<p>The scenarios where side causes and side effects can lead to bugs are as varied
as the programs in existence. But let's examine a scenario to illustrate these
hazards, in hopes that they help us recognize similar mistakes in our own
programs.</p>
<p>Consider:</p>
<pre><code class="language-js">var users = {};
var userOrders = {};

function fetchUserData(userId) {
  ajax(`http://some.api/user/${userId}`, function onUserData(user) {
    users[userId] = user;
  });
}

function fetchOrders(userId) {
  ajax(`http://some.api/orders/${userId}`, function onOrders(orders) {
    for (let order of orders) {
      // keep a reference to latest order for each user
      users[userId].latestOrder = order;
      userOrders[order.orderId] = order;
    }
  });
}

function deleteOrder(orderId) {
  var user = users[userOrders[orderId].userId];
  var isLatestOrder = userOrders[orderId] == user.latestOrder;

  // deleting the latest order for a user?
  if (isLatestOrder) {
    hideLatestOrderDisplay();
  }

  ajax(`http://some.api/delete/order/${orderId}`, function onDelete(success) {
    if (success) {
      // deleted the latest order for a user?
      if (isLatestOrder) {
        user.latestOrder = null;
      }

      userOrders[orderId] = null;
    } else if (isLatestOrder) {
      showLatestOrderDisplay();
    }
  });
}
</code></pre>
<p>I bet for some readers one of the potential bugs here is fairly obvious. If the
callback <code>onOrders(..)</code> runs before the <code>onUserData(..)</code> callback, it will
attempt to add a <code>latestOrder</code> property to a value (the <code>user</code> object at
<code>users[userId]</code>) that's not yet been set.</p>
<p>So one form of &quot;bug&quot; that can occur with logic that relies on side
causes/effects is the race condition of two different operations (async or not!)
that we expect to run in a certain order but under some cases may run in a
different order. There are strategies for ensuring the order of operations, and
it's fairly obvious that order is critical in that case.</p>
<p>Another more subtle bug can bite us here. Did you spot it?</p>
<p>Consider this order of calls:</p>
<pre><code class="language-js">fetchUserData( 123 );
onUserData(..);
fetchOrders( 123 );
onOrders(..);

// later

fetchOrders( 123 );
deleteOrder( 456 );
onOrders(..);
onDelete(..);
</code></pre>
<p>Do you see the interleaving of <code>fetchOrders(..)</code> and <code>onOrders(..)</code> with the
<code>deleteOrder(..)</code> and <code>onDelete(..)</code> pair? That potential sequencing exposes a
weird condition with our side causes/effects of state management.</p>
<p>There's a delay in time (because of the callback) between when we set the
<code>isLatestOrder</code> flag and when we use it to decide if we should empty the
<code>latestOrder</code> property of the user data object in <code>users</code>. During that delay, if
<code>onOrders(..)</code> callback fires, it can potentially change which order value that
user's <code>latestOrder</code> references. When <code>onDelete(..)</code> then fires, it will assume
it still needs to unset the <code>latestOrder</code> reference.</p>
<p>The bug: the data (state) <em>might</em> now be out of sync. <code>latestOrder</code> will be
unset, when potentially it should have stayed pointing at a newer order that
came in to <code>onOrders(..)</code>.</p>
<p>The worst part of this kind of bug is that you don't get a program-crashing
exception like we did with the other bug. We just simply have state that is
incorrect; our application's behavior is &quot;silently&quot; broken.</p>
<p>The sequencing dependency between <code>fetchUserData(..)</code> and <code>fetchOrders(..)</code> is
fairly obvious, and straightforwardly addressed. But the potential sequencing
dependency between <code>fetchOrders(..)</code> and <code>deleteOrder(..)</code> is far less obvious.
These two seem to be more independent. And ensuring that their order is
preserved is more tricky, because you don't know in advance (before the results
from <code>fetchOrders(..)</code>) whether that sequencing really must be enforced.</p>
<p>Yes, you can recompute the <code>isLatestOrder</code> flag once <code>deleteOrder(..)</code> fires.
But now you have a different problem: your UI state can be out of sync.</p>
<p>If you had called the <code>hideLatestOrderDisplay()</code> previously, you'll now need to
call the function <code>showLatestOrderDisplay()</code>, but only if a new <code>latestOrder</code>
has in fact been set. So you'll need to track at least three states: was the
deleted order the &quot;latest&quot; originally, and is the &quot;latest&quot; set, and are those
two orders different? These are solvable problems, of course. But they're not
obvious by any means.</p>
<p>All of these hassles are because we decided to structure our code with side
causes/effects on a shared set of state.</p>
<p>Functional programmers detest these sorts of side cause/effect bugs because of
how much it hurts our ability to read, reason about, validate, and ultimately
<strong>trust</strong> the code. That's why they take the principle to avoid side
causes/effects so seriously.</p>
<p>There are multiple different strategies for avoiding/fixing side causes/effects.
We'll talk about some later in this chapter, and others in later chapters. I'll
say one thing for certain: <strong>writing with side causes/effects is often of our
normal default</strong> so avoiding them is going to require careful and intentional
effort.</p>
<h2><a class="header" href="#once-is-enough-thanks" id="once-is-enough-thanks">Once Is Enough, Thanks</a></h2>
<p>If you must make side effect changes to state, one class of operations that's
useful for limiting the potential trouble is idempotence. If your update of a
value is idempotent, then data will be resilient to the case where you might
have multiple such updates from different side effect sources.</p>
<p>If you try to research it, the definition of idempotence can be a little
confusing; mathematicians use a slightly different meaning than programmers
typically do. However, both perspectives are useful for the functional
programmer.</p>
<p>First, let's give a counter example that is neither mathematically nor
programmingly idempotent:</p>
<pre><code class="language-js">function updateCounter(obj) {
  if (obj.count &lt; 10) {
    obj.count++;
    return true;
  }

  return false;
}
</code></pre>
<p>This function mutates an object via reference by incrementing <code>obj.count</code>, so it
produces a side effect on that object. If <code>updateCounter(o)</code> is called multiple
times -- while <code>o.count</code> is less than <code>10</code>, that is -- the program state changes
each time. Also, the output of <code>updateCounter(..)</code> is a Boolean, which is not
suitable to feed back into a subsequent call of <code>updateCounter(..)</code>.</p>
<h3><a class="header" href="#mathematical-idempotence" id="mathematical-idempotence">Mathematical Idempotence</a></h3>
<p>From the mathematical point of view, idempotence means an operation whose output
won't ever change after the first call, if you feed that output back into the
operation over and over again. In other words, <code>foo(x)</code> would produce the same
output as <code>foo(foo(x))</code> and <code>foo(foo(foo(x)))</code>.</p>
<p>A typical mathematical example is <code>Math.abs(..)</code> (absolute value).
<code>Math.abs(-2)</code> is <code>2</code>, which is the same result as
<code>Math.abs(Math.abs(Math.abs(Math.abs(-2))))</code>. Other idempotent mathematical
utilities include:</p>
<ul>
<li><code>Math.min(..)</code></li>
<li><code>Math.max(..)</code></li>
<li><code>Math.round(..)</code></li>
<li><code>Math.floor(..)</code></li>
<li><code>Math.ceil(..)</code></li>
</ul>
<p>Some custom mathematical operations we could define with this same
characteristic:</p>
<pre><code class="language-js">function toPower0(x) {
  return Math.pow(x, 0);
}

function snapUp3(x) {
  return x - (x % 3) + (x % 3 &gt; 0 &amp;&amp; 3);
}

toPower0(3) == toPower0(toPower0(3)); // true

snapUp3(3.14) == snapUp3(snapUp3(3.14)); // true
</code></pre>
<p>Mathematical-style idempotence is <strong>not</strong> restricted to mathematical operations.
Another place we can illustrate this form of idempotence is with JavaScript
primitive type coercions:</p>
<pre><code class="language-js">var x = 42,
  y = &quot;hello&quot;;

String(x) === String(String(x)); // true

Boolean(y) === Boolean(Boolean(y)); // true
</code></pre>
<p>Earlier in the text, we explored a common FP tool that fulfills this form of
idempotence:</p>
<pre><code class="language-js">identity(3) === identity(identity(3)); // true
</code></pre>
<p>Certain string operations are also naturally idempotent, such as:</p>
<pre><code class="language-js">function upper(x) {
  return x.toUpperCase();
}

function lower(x) {
  return x.toLowerCase();
}

var str = &quot;Hello World&quot;;

upper(str) == upper(upper(str)); // true

lower(str) == lower(lower(str)); // true
</code></pre>
<p>We can even design more sophisticated string formatting operations in an
idempotent way, such as:</p>
<pre><code class="language-js">function currency(val) {
  var num = parseFloat(String(val).replace(/[^\d.-]+/g, &quot;&quot;));
  var sign = num &lt; 0 ? &quot;-&quot; : &quot;&quot;;
  return `${sign}$${Math.abs(num).toFixed(2)}`;
}

currency(-3.1); // &quot;-$3.10&quot;

currency(-3.1) == currency(currency(-3.1)); // true
</code></pre>
<p><code>currency(..)</code> illustrates an important technique: in some cases the developer
can take extra steps to normalize an input/output operation to ensure the
operation is idempotent where it normally wouldn't be.</p>
<p>Wherever possible, restricting side effects to idempotent operations is much
better than unrestricted updates.</p>
<h3><a class="header" href="#programming-idempotence" id="programming-idempotence">Programming Idempotence</a></h3>
<p>The programming-oriented definition for idempotence is similar, but less formal.
Instead of requiring <code>f(x) === f(f(x))</code>, this view of idempotence is just that
<code>f(x);</code> results in the same program behavior as <code>f(x); f(x);</code>. In other words,
the result of calling <code>f(x)</code> subsequent times after the first call doesn't
change anything.</p>
<p>That perspective fits more with our observations about side effects, because
it's more likely that such an <code>f(..)</code> operation creates an idempotent side
effect rather than necessarily returning an idempotent output value.</p>
<p>This idempotence-style is often cited for HTTP operations (verbs) such as GET or
PUT. If an HTTP REST API is properly following the specification guidance for
idempotence, PUT is defined as an update operation that fully replaces a
resource. As such, a client could either send a PUT request once or multiple
times (with the same data), and the server would have the same resultant state
regardless.</p>
<p>Thinking about this in more concrete terms with programming, let's examine some
side effect operations for their idempotence (or lack thereof):</p>
<pre><code class="language-js">// idempotent:
obj.count = 2;
a[a.length - 1] = 42;
person.name = upper(person.name);

// non-idempotent:
obj.count++;
a[a.length] = 42;
person.lastUpdated = Date.now();
</code></pre>
<p>Remember: the notion of idempotence here is that each idempotent operation (like
<code>obj.count = 2</code>) could be repeated multiple times and not change the program
state beyond the first update. The non-idempotent operations change the state
each time.</p>
<p>What about DOM updates?</p>
<pre><code class="language-js">var hist = document.getElementById(&quot;orderHistory&quot;);

// idempotent:
hist.innerHTML = order.historyText;

// non-idempotent:
var update = document.createTextNode(order.latestUpdate);
hist.appendChild(update);
</code></pre>
<p>The key difference illustrated here is that the idempotent update replaces the
DOM element's content. The current state of the DOM element is irrelevant,
because it's unconditionally overwritten. The non-idempotent operation adds
content to the element; implicitly, the current state of the DOM element is part
of computing the next state.</p>
<p>It won't always be possible to define your operations on data in an idempotent
way, but if you can, it will definitely help reduce the chances that your side
effects will crop up to break your expectations when you least expect it.</p>
<h2><a class="header" href="#pure-bliss" id="pure-bliss">Pure Bliss</a></h2>
<p>A function with no side causes/effects is called a pure function. A pure
function is idempotent in the programming sense, because it cannot have any side
effects. Consider:</p>
<pre><code class="language-js">function add(x, y) {
  return x + y;
}
</code></pre>
<p>All the inputs (<code>x</code> and <code>y</code>) and outputs (<code>return ..</code>) are direct; there are no
free variable references. Calling <code>add(3,4)</code> multiple times would be
indistinguishable from only calling it once. <code>add(..)</code> is pure and
programming-style idempotent.</p>
<p>However, not all pure functions are idempotent in the mathematical sense,
because they don't have to return a value that would be suitable for feeding
back in as their own input. Consider:</p>
<pre><code class="language-js">function calculateAverage(nums) {
  var sum = 0;
  for (let num of nums) {
    sum += num;
  }
  return sum / nums.length;
}

calculateAverage([1, 2, 4, 7, 11, 16, 22]); // 9
</code></pre>
<p>The output <code>9</code> is not an array, so you cannot pass it back in:
<code>calculateAverage(calculateAverage( .. ))</code>.</p>
<p>As we discussed earlier, a pure function <em>can</em> reference free variables, as long
as those free variables aren't side causes.</p>
<p>Some examples:</p>
<pre><code class="language-js">const PI = 3.141592;

function circleArea(radius) {
  return PI * radius * radius;
}

function cylinderVolume(radius, height) {
  return height * circleArea(radius);
}
</code></pre>
<p><code>circleArea(..)</code> references the free variable <code>PI</code>, but it's a constant so it's
not a side cause. <code>cylinderVolume(..)</code> references the free variable
<code>circleArea</code>, which is also not a side cause because this program treats it as,
in effect, a constant reference to its function value. Both these functions are
pure.</p>
<p>Another example where a function can still be pure but reference free variables
is with closure:</p>
<pre><code class="language-js">function unary(fn) {
  return function onlyOneArg(arg) {
    return fn(arg);
  };
}
</code></pre>
<p><code>unary(..)</code> itself is clearly pure -- its only input is <code>fn</code> and its only output
is the <code>return</code>ed function -- but what about the inner function
<code>onlyOneArg(..)</code>, which closes over the free variable <code>fn</code>?</p>
<p>It's still pure because <code>fn</code> never changes. In fact, we have full confidence in
that fact because lexically speaking, those few lines are the only ones that
could possibly reassign <code>fn</code>.</p>
<p><strong>Note:</strong> <code>fn</code> is a reference to a function object, which is by default a
mutable value. Somewhere else in the program <em>could</em>, for example, add a
property to this function object, which technically &quot;changes&quot; the value
(mutation, not reassignment). However, because we're not relying on anything
about <code>fn</code> other than our ability to call it, and it's not possible to affect
the callability of a function value, <code>fn</code> is still effectively unchanging for
our reasoning purposes; it cannot be a side cause.</p>
<p>Another common way to articulate a function's purity is: <strong>given the same
input(s), it always produces the same output.</strong> If you pass <code>3</code> to
<code>circleArea(..)</code>, it will always output the same result (<code>28.274328</code>).</p>
<p>If a function <em>can</em> produce a different output each time it's given the same
inputs, it is impure. Even if such a function always <code>return</code>s the same value,
if it produces an indirect output side effect, the program state is changed each
time it's called; this is impure.</p>
<p>Impure functions are undesirable because they make all of their calls harder to
reason about. A pure function's call is perfectly predictable. When someone
reading the code sees multiple <code>circleArea(3)</code> calls, they won't have to spend
any extra effort to figure out what its output will be <em>each time</em>.</p>
<p><strong>Note:</strong> An interesting thing to ponder: is the heat produced by the CPU while
performing any given operation an unavoidable side effect of even the most pure
functions/programs? What about just the CPU time delay as it spends time on a
pure operation before it can do another one?</p>
<h3><a class="header" href="#purely-relative" id="purely-relative">Purely Relative</a></h3>
<p>We have to be very careful when talking about a function being pure.
JavaScript's dynamic value nature makes it all too easy to have non-obvious side
causes/effects.</p>
<p>Consider:</p>
<pre><code class="language-js">function rememberNumbers(nums) {
  return function caller(fn) {
    return fn(nums);
  };
}

var list = [1, 2, 3, 4, 5];

var simpleList = rememberNumbers(list);
</code></pre>
<p><code>simpleList(..)</code> looks like a pure function, as it's a reference to the inner
function <code>caller(..)</code>, which just closes over the free variable <code>nums</code>. However,
there's multiple ways that <code>simpleList(..)</code> can actually turn out to be impure.</p>
<p>First, our assertion of purity is based on the array value (referenced both by
<code>list</code> and <code>nums</code>) never changing:</p>
<pre><code class="language-js">function median(nums) {
  return (nums[0] + nums[nums.length - 1]) / 2;
}

simpleList(median); // 3

// ..

list.push(6);

// ..

simpleList(median); // 3.5
</code></pre>
<p>When we mutate the array, the <code>simpleList(..)</code> call changes its output. So, is
<code>simpleList(..)</code> pure or impure? Depends on your perspective. It's pure for a
given set of assumptions. It could be pure in any program that didn't have the
<code>list.push(6)</code> mutation.</p>
<p>We could guard against this kind of impurity by altering the definition of
<code>rememberNumbers(..)</code>. One approach is to duplicate the <code>nums</code> array:</p>
<pre><code class="language-js">function rememberNumbers(nums) {
  // make a copy of the array
  nums = [...nums];

  return function caller(fn) {
    return fn(nums);
  };
}
</code></pre>
<p>But an even trickier hidden side effect could be lurking:</p>
<pre><code class="language-js">var list = [1, 2, 3, 4, 5];

// make `list[0]` be a getter with a side effect
Object.defineProperty(list, 0, {
  get: function() {
    console.log(&quot;[0] was accessed!&quot;);
    return 1;
  }
});

var simpleList = rememberNumbers(list);
// [0] was accessed!
</code></pre>
<p>A perhaps more robust option is to change the signature of <code>rememberNumbers(..)</code>
to not receive an array in the first place, but rather the numbers as individual
arguments:</p>
<pre><code class="language-js">function rememberNumbers(...nums) {
  return function caller(fn) {
    return fn(nums);
  };
}

var simpleList = rememberNumbers(...list);
// [0] was accessed!
</code></pre>
<p>The two <code>...</code>s have the effect of copying <code>list</code> into <code>nums</code> instead of passing
it by reference.</p>
<p><strong>Note:</strong> The console message side effect here comes not from
<code>rememberNumbers(..)</code> but from the <code>...list</code> spreading. So in this case, both
<code>rememberNumbers(..)</code> and <code>simpleList(..)</code> are pure.</p>
<p>But what if the mutation is even harder to spot? Composition of a pure function
with an impure function <strong>always</strong> produces an impure function. If we pass an
impure function into the otherwise pure <code>simpleList(..)</code>, it's now impure:</p>
<pre><code class="language-js">// yes, a silly contrived example :)
function firstValue(nums) {
  return nums[0];
}

function lastValue(nums) {
  return firstValue(nums.reverse());
}

simpleList(lastValue); // 5

list; // [1,2,3,4,5] -- OK!

simpleList(lastValue); // 1
</code></pre>
<p><strong>Note:</strong> Despite <code>reverse()</code> looking safe (like other array methods in JS) in
that it returns a reversed array, it actually mutates the array rather than
creating a new one.</p>
<p>We need a more robust definition of <code>rememberNumbers(..)</code> to guard against the
<code>fn(..)</code> mutating its closed over <code>nums</code> via reference:</p>
<pre><code class="language-js">function rememberNumbers(...nums) {
  return function caller(fn) {
    // send in a copy!
    return fn([...nums]);
  };
}
</code></pre>
<p>So is <code>simpleList(..)</code> reliably pure yet!? <strong>Nope.</strong> :(</p>
<p>We're only guarding against side effects we can control (mutating by reference).
Any function we pass that has other side effects will have polluted the purity
of <code>simpleList(..)</code>:</p>
<pre><code class="language-js">simpleList(function impureIO(nums) {
  console.log(nums.length);
});
</code></pre>
<p>In fact, there's no way to define <code>rememberNumbers(..)</code> to make a perfectly pure
<code>simpleList(..)</code> function.</p>
<p>Purity is about confidence. But we have to admit that in many cases, <strong>any
confidence we feel is actually relative to the context</strong> of our program and what
we know about it. In practice (in JavaScript) the question of function purity is
not about being absolutely pure or not, but about a range of confidence in its
purity.</p>
<p>The more pure, the better. The more effort you put into making a function
pure(r), the higher your confidence will be when you read code that uses it, and
that will make that part of the code more readable.</p>
<h2><a class="header" href="#there-or-not" id="there-or-not">There or Not</a></h2>
<p>So far, we've defined function purity both as a function without side
causes/effects and as a function that, given the same input(s), always produces
the same output. These are just two different ways of looking at the same
characteristics.</p>
<p>But a third way of looking at function purity, and perhaps the most widely
accepted definition, is that a pure function has referential transparency.</p>
<p>Referential transparency is the assertion that a function call could be replaced
by its output value, and the overall program behavior wouldn't change. In other
words, it would be impossible to tell from the program's execution whether the
function call was made or its return value was inlined in place of the function
call.</p>
<p>From the perspective of referential transparency, both of these programs have
identical behavior as they are built with pure functions:</p>
<pre><code class="language-js">function calculateAverage(nums) {
  var sum = 0;
  for (let num of nums) {
    sum += num;
  }
  return sum / nums.length;
}

var numbers = [1, 2, 4, 7, 11, 16, 22];

var avg = calculateAverage(numbers);

console.log(&quot;The average is:&quot;, avg); // The average is: 9
</code></pre>
<pre><code class="language-js">function calculateAverage(nums) {
  var sum = 0;
  for (let num of nums) {
    sum += num;
  }
  return sum / nums.length;
}

var numbers = [1, 2, 4, 7, 11, 16, 22];

var avg = 9;

console.log(&quot;The average is:&quot;, avg); // The average is: 9
</code></pre>
<p>The only difference between these two snippets is that in the latter one, we
skipped the <code>calculateAverage(nums)</code> call and just inlined its output (<code>9</code>).
Since the rest of the program behaves identically, <code>calculateAverage(..)</code> has
referential transparency, and is thus a pure function.</p>
<h3><a class="header" href="#mentally-transparent" id="mentally-transparent">Mentally Transparent</a></h3>
<p>The notion that a referentially transparent pure function <em>can be</em> replaced with
its output does not mean that it <em>should literally be</em> replaced. Far from it.</p>
<p>The reasons we build functions into our programs instead of using pre-computed
magic constants are not just about responding to changing data, but also about
readability with proper abstractions. The function call to calculate the average
of that list of numbers makes that part of the program more readable than the
line that just assigns the value explicitly. It tells the story to the reader of
where <code>avg</code> comes from, what it means, and so on.</p>
<p>What we're really suggesting with referential transparency is that as you're
reading a program, once you've mentally computed what a pure function call's
output is, you no longer need to think about what that exact function call is
doing when you see it in code, especially if it appears multiple times.</p>
<p>That result becomes kinda like a mental <code>const</code> declaration, which as you're
reading you can transparently swap in and not spend any more mental energy
working out.</p>
<p>Hopefully the importance of this characteristic of a pure function is obvious.
We're trying to make our programs more readable. One way we can do that is to
give the reader less work, by providing assistance to skip over the unnecessary
stuff so they can focus on the important stuff.</p>
<p>The reader shouldn't need to keep re-computing some outcome that isn't going to
change (and doesn't need to). If you define a pure function with referential
transparency, the reader won't have to.</p>
<h3><a class="header" href="#not-so-transparent" id="not-so-transparent">Not So Transparent?</a></h3>
<p>What about a function that has a side effect, but this side effect isn't ever
observed or relied upon anywhere else in the program? Does that function still
have referential transparency?</p>
<p>Here's one:</p>
<pre><code class="language-js">function calculateAverage(nums) {
  sum = 0;
  for (let num of nums) {
    sum += num;
  }
  return sum / nums.length;
}

var sum;
var numbers = [1, 2, 4, 7, 11, 16, 22];

var avg = calculateAverage(numbers);
</code></pre>
<p>Did you spot it?</p>
<p><code>sum</code> is an outer free variable that <code>calculateAverage(..)</code> uses to do its work.
But, every time we call <code>calculateAverage(..)</code> with the same list, we're going
to get <code>9</code> as the output. And this program couldn't be distinguished in terms of
behavior from a program that replaced the <code>calculateAverage(nums)</code> call with the
value <code>9</code>. No other part of the program cares about the <code>sum</code> variable, so it's
an unobserved side effect.</p>
<p>Is a side cause/effect that's unobserved like this tree:</p>
<blockquote>
<p>If a tree falls in the forest, but no one is around to hear it, does it still
make a sound?</p>
</blockquote>
<p>By the narrowest definition of referential transparency, I think you'd have to
say <code>calculateAverage(..)</code> is still a pure function. However, because we're
trying to avoid a strictly academic approach in favor of balancing it with
pragmatism, I also think this conclusion needs more perspective. Let's explore.</p>
<h4><a class="header" href="#performance-effects" id="performance-effects">Performance Effects</a></h4>
<p>You'll generally find these kind of side-effects-that-go-unobserved being used
to optimize the performance of an operation. For example:</p>
<pre><code class="language-js">var cache = [];

function specialNumber(n) {
  // if we've already calculated this special number,
  // skip the work and just return it from the cache
  if (cache[n] !== undefined) {
    return cache[n];
  }

  var x = 1,
    y = 1;

  for (let i = 1; i &lt;= n; i++) {
    x += i % 2;
    y += i % 3;
  }

  cache[n] = (x * y) / (n + 1);

  return cache[n];
}

specialNumber(6); // 4
specialNumber(42); // 22
specialNumber(1e6); // 500001
specialNumber(987654321); // 493827162
</code></pre>
<p>This silly <code>specialNumber(..)</code> algorithm is deterministic and thus pure from the
definition that it always gives the same output for the same input. It's also
pure from the referential transparency perspective -- replace any call to
<code>specialNumber(42)</code> with <code>22</code> and the end result of the program is the same.</p>
<p>However, the function has to do quite a bit of work to calculate some of the
bigger numbers, especially the <code>987654321</code> input. If we needed to get that
particular special number multiple times throughout our program, the <code>cache</code>ing
of the result means that subsequent calls are far more efficient.</p>
<p>Don't be so quick to assume that you could just run the calculation
<code>specialNumber(987654321)</code> once and manually stick that result in some
variable/constant. Programs are often highly modularized and globally accessible
scopes are not usually the way you want to share state between those independent
pieces. Having <code>specialNumber(..)</code> do its own caching (even though it happens to
be using a global variable to do so!) is a more preferable abstraction of that
state sharing.</p>
<p>The point is that if <code>specialNumber(..)</code> is the only part of the program that
accesses and updates the <code>cache</code> side cause/effect, the referential transparency
perspective observably holds true, and this might be seen as an acceptable
pragmatic &quot;cheat&quot; of the pure function ideal.</p>
<p>But should it?</p>
<p>Typically, this sort of performance optimization side effecting is done by
hiding the caching of results so they <em>cannot</em> be observed by any other part of
the program. This process is referred to as memoization. I always think of that
word as &quot;memorization&quot;; I have no idea if that's even remotely where it comes
from, but it certainly helps me understand the concept better.</p>
<p>Consider:</p>
<pre><code class="language-js">var specialNumber = (function memoization() {
  var cache = [];

  return function specialNumber(n) {
    // if we've already calculated this special number,
    // skip the work and just return it from the cache
    if (cache[n] !== undefined) {
      return cache[n];
    }

    var x = 1,
      y = 1;

    for (let i = 1; i &lt;= n; i++) {
      x += i % 2;
      y += i % 3;
    }

    cache[n] = (x * y) / (n + 1);

    return cache[n];
  };
})();
</code></pre>
<p>We've contained the <code>cache</code> side causes/effects of <code>specialNumber(..)</code> inside
the scope of the <code>memoization()</code> IIFE, so now we're sure that no other parts of
the program <em>can</em> observe them, not just that they <em>don't</em> observe them.</p>
<p>That last sentence may seem like a subtle point, but actually I think it might
be <strong>the most important point of the entire chapter</strong>. Read it again.</p>
<p>Recall this philosophical musing:</p>
<blockquote>
<p>If a tree falls in the forest, but no one is around to hear it, does it still
make a sound?</p>
</blockquote>
<p>Going with the metaphor, what I'm getting at is: whether the sound is made or
not, it would be better if we never create a scenario where the tree can fall
without us being around; we'll always hear the sound when a tree falls.</p>
<p>The purpose of reducing side causes/effects is not per se to have a program
where they aren't observed, but to design a program where fewer of them are
possible, because this makes the code easier to reason about. A program with
side causes/effects that <em>just happen</em> to not be observed is not nearly as
effective in this goal as a program that <em>cannot</em> observe them.</p>
<p>If side causes/effects can happen, the writer and reader must mentally juggle
them. Make it so they can't happen, and both writer and reader will find more
confidence over what can and cannot happen in any part.</p>
<h2><a class="header" href="#purifying" id="purifying">Purifying</a></h2>
<p>The first best option in writing functions is that you design them from the
beginning to be pure. But you'll spend plenty of time maintaining existing code,
where those kinds of decisions were already made; you'll run across a lot of
impure functions.</p>
<p>If possible, refactor the impure function to be pure. Sometimes you can just
shift the side effects out of a function to the part of the program where the
call of that function happens. The side effect wasn't eliminated, but it was
made more obvious by showing up at the call-site.</p>
<p>Consider this trivial example:</p>
<pre><code class="language-js">function addMaxNum(arr) {
  var maxNum = Math.max(...arr);
  arr.push(maxNum + 1);
}

var nums = [4, 2, 7, 3];

addMaxNum(nums);

nums; // [4,2,7,3,8]
</code></pre>
<p>The <code>nums</code> array needs to be modified, but we don't have to obscure that side
effect by containing it in <code>addMaxNum(..)</code>. Let's move the <code>push(..)</code> mutation
out, so that <code>addMaxNum(..)</code> becomes a pure function, and the side effect is now
more obvious:</p>
<pre><code class="language-js">function addMaxNum(arr) {
  var maxNum = Math.max(...arr);
  return maxNum + 1;
}

var nums = [4, 2, 7, 3];

nums.push(addMaxNum(nums));

nums; // [4,2,7,3,8]
</code></pre>
<p><strong>Note:</strong> Another technique for this kind of task could be to use an immutable
data structure, which we cover in the next chapter.</p>
<p>But what can you do if you have an impure function where the refactoring is not
as easy?</p>
<p>You need to figure what kind of side causes/effects the function has. It may be
that the side causes/effects come variously from lexical free variables,
mutations-by-reference, or even <code>this</code> binding. We'll look at approaches that
address each of these scenarios.</p>
<h3><a class="header" href="#containing-effects" id="containing-effects">Containing Effects</a></h3>
<p>If the nature of the concerned side causes/effects is with lexical free
variables, and you have the option to modify the surrounding code, you can
encapsulate them using scope.</p>
<p>Recall:</p>
<pre><code class="language-js">var users = {};

function fetchUserData(userId) {
  ajax(`http://some.api/user/${userId}`, function onUserData(user) {
    users[userId] = user;
  });
}
</code></pre>
<p>One option for purifying this code is to create a wrapper around both the
variable and the impure function. Essentially, the wrapper has to receive as
input &quot;the entire universe&quot; of state it can operate on.</p>
<pre><code class="language-js">function safer_fetchUserData(userId, users) {
  // simple, naive ES6+ shallow object copy, could also
  // be done w/ various libs or frameworks
  users = Object.assign({}, users);

  fetchUserData(userId);

  // return the copied state
  return users;

  // ***********************

  // original untouched impure function:
  function fetchUserData(userId) {
    ajax(`http://some.api/user/${userId}`, function onUserData(user) {
      users[userId] = user;
    });
  }
}
</code></pre>
<p><strong>Warning:</strong> <code>safer_fetchUserData(..)</code> is <em>more</em> pure, but is not strictly pure
in that it still relies on the I/O of making an Ajax call. There's no getting
around the fact that an Ajax call is an impure side effect, so we'll just leave
that detail unaddressed.</p>
<p>Both <code>userId</code> and <code>users</code> are input for the original <code>fetchUserData</code>, and
<code>users</code> is also output. The <code>safer_fetchUserData(..)</code> takes both of these
inputs, and returns <code>users</code>. To make sure we're not creating a side effect on
the outside when <code>users</code> is mutated, we make a local copy of <code>users</code>.</p>
<p>This technique has limited usefulness mostly because if you cannot modify a
function itself to be pure, you're not that likely to be able to modify its
surrounding code either. However, it's helpful to explore it if possible, as
it's the simplest of our fixes.</p>
<p>Regardless of whether this will be a practical technique for refactoring to pure
functions, the more important take-away is that function purity only need be
skin deep. That is, the <strong>purity of a function is judged from the outside</strong>,
regardless of what goes on inside. As long as a function's usage behaves pure,
it is pure. Inside a pure function, impure techniques can be used -- in
moderation! -- for a variety of reasons, including most commonly, for
performance. It's not necessarily, as they say, &quot;turtles all the way down&quot;.</p>
<p>Be very careful, though. Any part of the program that's impure, even if it's
wrapped with and only ever used via a pure function, is a potential source of
bugs and confusion for readers of the code. The overall goal is to reduce side
effects wherever possible, not just hide them.</p>
<h3><a class="header" href="#covering-up-effects" id="covering-up-effects">Covering Up Effects</a></h3>
<p>Many times you will be unable to modify the code to encapsulate the lexical free
variables inside the scope of a wrapper function. For example, the impure
function may be in a third-party library file that you do not control,
containing something like:</p>
<pre><code class="language-js">var nums = [];
var smallCount = 0;
var largeCount = 0;

function generateMoreRandoms(count) {
  for (let i = 0; i &lt; count; i++) {
    let num = Math.random();

    if (num &gt;= 0.5) {
      largeCount++;
    } else {
      smallCount++;
    }

    nums.push(num);
  }
}
</code></pre>
<p>The brute-force strategy to <em>quarantine</em> the side causes/effects when using this
utility in the rest of our program is to create an interface function that
performs the following steps:</p>
<ol>
<li>Capture the to-be-affected current states</li>
<li>Set initial input states</li>
<li>Run the impure function</li>
<li>Capture the side effect states</li>
<li>Restore the original states</li>
<li>Return the captured side effect states</li>
</ol>
<pre><code class="language-js">function safer_generateMoreRandoms(count, initial) {
  // (1) Save original state
  var orig = {
    nums,
    smallCount,
    largeCount
  };

  // (2) Set up initial pre-side effects state
  nums = [...initial.nums];
  smallCount = initial.smallCount;
  largeCount = initial.largeCount;

  // (3) Beware impurity!
  generateMoreRandoms(count);

  // (4) Capture side effect state
  var sides = {
    nums,
    smallCount,
    largeCount
  };

  // (5) Restore original state
  nums = orig.nums;
  smallCount = orig.smallCount;
  largeCount = orig.largeCount;

  // (6) Expose side effect state directly as output
  return sides;
}
</code></pre>
<p>And to use <code>safer_generateMoreRandoms(..)</code>:</p>
<pre><code class="language-js">var initialStates = {
  nums: [0.3, 0.4, 0.5],
  smallCount: 2,
  largeCount: 1
};

safer_generateMoreRandoms(5, initialStates);
// { nums: [0.3,0.4,0.5,0.8510024448959794,0.04206799238...

nums; // []
smallCount; // 0
largeCount; // 0
</code></pre>
<p>That's a lot of manual work to avoid a few side causes/effects; it'd be a lot
easier if we just didn't have them in the first place. But if we have no choice,
this extra effort is well worth it to avoid surprises in our programs.</p>
<p><strong>Note:</strong> This technique really only works when you're dealing with synchronous
code. Asynchronous code can't reliably be managed with this approach because it
can't prevent surprises if other parts of the program access/modify the state
variables in the interim.</p>
<h3><a class="header" href="#evading-effects" id="evading-effects">Evading Effects</a></h3>
<p>When the nature of the side effect to be dealt with is a mutation of a direct
input value (object, array, etc.) via reference, we can again create an
interface function to interact with instead of the original impure function.</p>
<p>Consider:</p>
<pre><code class="language-js">function handleInactiveUsers(userList, dateCutoff) {
  for (let i = 0; i &lt; userList.length; i++) {
    if (userList[i].lastLogin == null) {
      // remove the user from the list
      userList.splice(i, 1);
      i--;
    } else if (userList[i].lastLogin &lt; dateCutoff) {
      userList[i].inactive = true;
    }
  }
}
</code></pre>
<p>Both the <code>userList</code> array itself, plus the objects in it, are mutated. One
strategy to protect against these side effects is to do a deep (well, just not
shallow) copy first:</p>
<pre><code class="language-js">function safer_handleInactiveUsers(userList, dateCutoff) {
  // make a copy of both the list and its user objects
  let copiedUserList = userList.map(function mapper(user) {
    // copy a `user` object
    return Object.assign({}, user);
  });

  // call the original function with the copy
  handleInactiveUsers(copiedUserList, dateCutoff);

  // expose the mutated list as a direct output
  return copiedUserList;
}
</code></pre>
<p>The success of this technique will be dependent on the thoroughness of the
<em>copy</em> you make of the value. Using <code>[...userList]</code> would not work here, since
that only creates a shallow copy of the <code>userList</code> array itself. Each element of
the array is an object that needs to be copied, so we need to take extra care.
Of course, if those objects have objects inside them (they might!), the copying
needs to be even more robust.</p>
<h3><a class="header" href="#this-revisited" id="this-revisited"><code>this</code> Revisited</a></h3>
<p>Another variation of the via-reference side cause/effect is with <code>this</code>-aware
functions having <code>this</code> as an implicit input. See
<a href="chapter_2.html">Chapter 2, &quot;What's This&quot;</a> for more info on why the
<code>this</code> keyword is problematic for FPers.</p>
<p>Consider:</p>
<pre><code class="language-js">var ids = {
  prefix: &quot;_&quot;,
  generate() {
    return this.prefix + Math.random();
  }
};
</code></pre>
<p>Our strategy is similar to the previous section's discussion: create an
interface function that forces the <code>generate()</code> function to use a predictable
<code>this</code> context:</p>
<pre><code class="language-js">function safer_generate(context) {
  return ids.generate.call(context);
}

// *********************

safer_generate({ prefix: &quot;foo&quot; });
// &quot;foo0.8988802158307285&quot;
</code></pre>
<p>These strategies are in no way fool-proof; the safest protection against side
causes/effects is to not do them. But if you're trying to improve the
readability and confidence level of your program, reducing the side
causes/effects wherever possible is a huge step forward.</p>
<p>Essentially, we're not really eliminating side causes/effects, but rather
containing and limiting them, so that more of our code is verifiable and
reliable. If we later run into program bugs, we know that the parts of our code
still using side causes/effects are the most likely culprits.</p>
<h2><a class="header" href="#summary-4" id="summary-4">Summary</a></h2>
<p>Side effects are harmful to code readability and quality because they make your
code much harder to understand. Side effects are also one of the most common
<em>causes</em> of bugs in programs, because juggling them is hard. Idempotence is a
strategy for restricting side effects by essentially creating one-time-only
operations.</p>
<p>Pure functions are how we best avoid side effects. A pure function is one that
always returns the same output given the same input, and has no side causes or
side effects. Referential transparency further states that -- more as a mental
exercise than a literal action -- a pure function's call could be replaced with
its output and the program would not have altered behavior.</p>
<p>Refactoring an impure function to be pure is the preferred option. But if that's
not possible, try encapsulating the side causes/effects, or creating a pure
interface against them.</p>
<p>No program can be entirely free of side effects. But prefer pure functions in as
many places as that's practical. Collect impure functions side effects together
as much as possible, so that it's easier to identify and audit these most likely
culprits of bugs when they arise.</p>
<h1><a class="header" href="#functional-light-javascript-7" id="functional-light-javascript-7">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-6-value-immutability" id="chapter-6-value-immutability">Chapter 6: Value Immutability</a></h1>
<p>In <a href="chapter_5.html">Chapter 5</a>, we talked about the importance of reducing side
causes/effects: the ways that your application's state can change unexpectedly
and cause surprises (bugs). The fewer places we have with such landmines, the
more confidence we have over our code, and the more readable it will be. Our
topic for this chapter follows directly from that same effort.</p>
<p>If programming-style idempotence is about defining a value change operation so
that it can only affect state once, we now turn our attention to the goal of
reducing the number of change occurrences from one to zero.</p>
<p>Let's now explore value immutability, the notion that in our programs we use
only values that cannot be changed.</p>
<h2><a class="header" href="#primitive-immutability" id="primitive-immutability">Primitive Immutability</a></h2>
<p>Values of the primitive types (<code>number</code>, <code>string</code>, <code>boolean</code>, <code>null</code>, and
<code>undefined</code>) are already immutable; there's nothing you can do to change them:</p>
<pre><code class="language-js">// invalid, and also makes no sense
2 = 2.5;
</code></pre>
<p>However, JS does have a peculiar behavior which seems like it allows mutating
such primitive type values: &quot;boxing&quot;. When you access a property on certain
primitive type values -- specifically <code>number</code>, <code>string</code>, and <code>boolean</code> -- under
the covers JS automatically wraps (aka &quot;boxes&quot;) the value in its object
counterpart (<code>Number</code>, <code>String</code>, and <code>Boolean</code>, respectively).</p>
<p>Consider:</p>
<pre><code class="language-js">var x = 2;

x.length = 4;

x; // 2
x.length; // undefined
</code></pre>
<p>Numbers do not normally have a <code>length</code> property available, so the
<code>x.length = 4</code> setting is trying to add a new property, and it silently fails
(or is ignored/discarded, depending on your point-of-view); <code>x</code> continues to
hold the simple primitive <code>2</code> number.</p>
<p>But the fact that JS allows the <code>x.length = 4</code> statement to run at all can seem
troubling, if for no other reason than its potential confusion to readers. The
good news is, if you use strict mode (<code>&quot;use strict&quot;;</code>), such a statement will
throw an error.</p>
<p>What if you try to mutate the explicitly boxed object representation of such a
value?</p>
<pre><code class="language-js">var x = new Number(2);

// works fine
x.length = 4;
</code></pre>
<p><code>x</code> in this snippet is holding a reference to an object, so custom properties
can be added and changed without issue.</p>
<p>The immutability of simple primitives like <code>number</code>s probably seems fairly
obvious. But what about <code>string</code> values? JS developers have a very common
misconception that strings are like arrays and can thus be changed. JS syntax
even hints at them being &quot;array like&quot; with the <code>[ ]</code> access operator. However,
strings are also immutable:</p>
<pre><code class="language-js">var s = &quot;hello&quot;;

s[1]; // &quot;e&quot;

s[1] = &quot;E&quot;;
s.length = 10;

s; // &quot;hello&quot;
</code></pre>
<p>Despite being able to access <code>s[1]</code> like it's an array, JS strings are not real
arrays. Setting <code>s[1] = &quot;E&quot;</code> and <code>s.length = 10</code> both silently fail, just as
<code>x.length = 4</code> did before. In strict mode, these assignments will fail, because
both the <code>1</code> property and the <code>length</code> property are read-only on this primitive
<code>string</code> value.</p>
<p>Interestingly, even the boxed <code>String</code> object value will act (mostly) immutable
as it will throw errors in strict mode if you change existing properties:</p>
<pre><code class="language-js">&quot;use strict&quot;;

var s = new String(&quot;hello&quot;);

s[1] = &quot;E&quot;; // error
s.length = 10; // error

s[42] = &quot;?&quot;; // OK

s; // &quot;hello&quot;
</code></pre>
<h2><a class="header" href="#value-to-value" id="value-to-value">Value to Value</a></h2>
<p>We'll unpack this idea more throughout the chapter, but just to start with a
clear understanding in mind: value immutability does not mean we can't have
values change over the course of our program. A program without changing state
is not a very interesting one! It also doesn't mean that our variables can't
hold different values. These are all common misconceptions about value
immutability.</p>
<p>Value immutability means that <em>when</em> we need to change the state in our program,
we must create and track a new value rather than mutate an existing value.</p>
<p>For example:</p>
<pre><code class="language-js">function addValue(arr) {
  var newArr = [...arr, 4];
  return newArr;
}

addValue([1, 2, 3]); // [1,2,3,4]
</code></pre>
<p>Notice that we did not change the array that <code>arr</code> references, but rather
created a new array (<code>newArr</code>) that contains the existing values plus the new
<code>4</code> value.</p>
<p>Analyze <code>addValue(..)</code> based on what we discussed in <a href="chapter_5.html">Chapter 5</a>
about side causes/effects. Is it pure? Does it have referential transparency?
Given the same array, will it always produce the same output? Is it free of both
side causes and side effects? <strong>Yes.</strong></p>
<p>Imagine the <code>[1,2,3]</code> array represents a sequence of data from some previous
operations and we stored in some variable. It is our current state. If we want
to compute what the next state of our application is, we call <code>addValue(..)</code>.
But we want that act of next-state computation to be direct and explicit. So the
<code>addValue(..)</code> operation takes a direct input, returns a direct output, and
avoids the side effect of mutating the original array that <code>arr</code> references.</p>
<p>This means we can calculate the new state of <code>[1,2,3,4]</code> and be fully in control
of that transition of states. No other part of our program can unexpectedly
transition us to that state early, or to another state entirely, like
<code>[1,2,3,5]</code>. By being disciplined about our values and treating them as
immutable, we drastically reduce the surface area of surprise, making our
programs easier to read, reason about, and ultimately trust.</p>
<p>The array that <code>arr</code> references is actually mutable. We just chose not to mutate
it, so we practiced the spirit of value immutability.</p>
<p>We can use the copy-instead-of-mutate strategy for objects, too. Consider:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  var newUserRecord = Object.assign({}, user);
  newUserRecord.lastLogin = Date.now();
  return newUserRecord;
}

var user = {
  // ..
};

user = updateLastLogin(user);
</code></pre>
<h3><a class="header" href="#non-local" id="non-local">Non-Local</a></h3>
<p>Non-primitive values are held by reference, and when passed as arguments, it's
the reference that's copied, not the value itself.</p>
<p>If you have an object or array in one part of the program, and pass it to a
function that resides in another part of the program, that function can now
affect the value via this reference copy, mutating it in possibly unexpected
ways.</p>
<p>In other words, if passed as arguments, non-primitive values become non-local.
Potentially the entire program has to be considered to understand whether such a
value will be changed or not.</p>
<p>Consider:</p>
<pre><code class="language-js">var arr = [1, 2, 3];

foo(arr);

console.log(arr[0]);
</code></pre>
<p>Ostensibly, you're expecting <code>arr[0]</code> to still be the value <code>1</code>. But is it? You
don't know, because <code>foo(..)</code> <em>might</em> mutate the array using the reference copy
you pass to it.</p>
<p>We already saw a trick in the previous chapter to avoid such a surprise:</p>
<pre><code class="language-js">var arr = [1, 2, 3];

foo([...arr]); // ha! a copy!

console.log(arr[0]); // 1
</code></pre>
<p>In a little bit, we'll see another strategy for protecting ourselves from a
value being mutated out from underneath us unexpectedly.</p>
<h2><a class="header" href="#reassignment" id="reassignment">Reassignment</a></h2>
<p>How would you describe what a &quot;constant&quot; is? Think about that for a moment
before you move on to the next paragraph.</p>
<p align="center">
    * * * *
</p>
<p>Some of you may have conjured descriptions like, &quot;a value that can't change&quot;, &quot;a
variable that can't be changed&quot;, or something similar. These are all
approximately in the neighborhood, but not quite at the right house. The precise
definition we should use for a constant is: a variable that cannot be
reassigned.</p>
<p>This nitpicking is really important, because it clarifies that a constant
actually has nothing to do with the value, except to say that whatever value a
constant holds, that variable cannot be reassigned any other value. But it says
nothing about the nature of the value itself.</p>
<p>Consider:</p>
<pre><code class="language-js">var x = 2;
</code></pre>
<p>Like we discussed earlier, the value <code>2</code> is an unchangeable (immutable)
primitive. If I change that code to:</p>
<pre><code class="language-js">const x = 2;
</code></pre>
<p>The presence of the <code>const</code> keyword, known familiarly as a &quot;constant
declaration&quot;, actually does nothing at all to change the nature of <code>2</code>; it's
already unchangeable, and it always will be.</p>
<p>It's true that this later line will fail with an error:</p>
<pre><code class="language-js">// try to change `x`, fingers crossed!
x = 3; // Error!
</code></pre>
<p>But again, we're not changing anything about the value. We're attempting to
reassign the variable <code>x</code>. The values involved are almost incidental.</p>
<p>To prove that <code>const</code> has nothing to do with the nature of the value, consider:</p>
<pre><code class="language-js">const x = [2];
</code></pre>
<p>Is the array a constant? <strong>No.</strong> <code>x</code> is a constant because it cannot be
reassigned. But this later line is totally OK:</p>
<pre><code class="language-js">x[0] = 3;
</code></pre>
<p>Why? Because the array is still totally mutable, even though <code>x</code> is a constant.</p>
<p>The confusion around <code>const</code> and &quot;constant&quot; only dealing with assignments and
not value semantics is a long and dirty story. It seems a high degree of
developers in just about every language that has a <code>const</code> stumble over the same
sorts of confusions. Java in fact deprecated <code>const</code> and introduced a new
keyword <code>final</code> at least in part to separate itself from the confusion over
&quot;constant&quot; semantics.</p>
<p>Setting aside the confusion detractions, what importance does <code>const</code> hold for
the FPer, if not to have anything to do with creating an immutable value?</p>
<h3><a class="header" href="#intent" id="intent">Intent</a></h3>
<p>The use of <code>const</code> tells the reader of your code that <em>that</em> variable will not
be reassigned. As a signal of intent, <code>const</code> is often highly lauded as a
welcome addition to JavaScript and a universal improvement in code readability.</p>
<p>In my opinion, this is mostly hype; there's not much substance to these claims.
I see only the mildest of faint benefit in signaling your intent in this way.
And when you match that up against decades of precedent around confusion about
it implying value immutability, I don't think <code>const</code> comes close to carrying
its own weight.</p>
<p>To back up my assertion, let's consider scope. <code>const</code> creates a block scoped
variable, meaning that variable only exists in that one localized block:</p>
<pre><code class="language-js">// lots of code

{
  const x = 2;

  // a few lines of code
}

// lots of code
</code></pre>
<p>Typically, blocks are considered best designed to be only a few lines long. If
you have blocks of more than say 10 lines, most developers will advise you to
refactor. So <code>const x = 2</code> only applies to those next nine lines of code at
most.</p>
<p>No other part of the program can ever affect the assignment of <code>x</code>. <strong>Period.</strong></p>
<p>My claim is that program has basically the same magnitude of readability as this
one:</p>
<pre><code class="language-js">// lots of code

{
  let x = 2;

  // a few lines of code
}

// lots of code
</code></pre>
<p>If you look at the next few lines of code after <code>let x = 2;</code>, you'll be able to
easily tell that <code>x</code> is in fact <em>not</em> reassigned. That to me is a <strong>much
stronger signal</strong> -- actually not reassigning it! -- than the use of some
confusable <code>const</code> declaration to say &quot;won't reassign it&quot;.</p>
<p>Moreover, let's consider what this code is likely to communicate to a reader at
first glance:</p>
<pre><code class="language-js">const magicNums = [1, 2, 3, 4];
</code></pre>
<p>Isn't it at least possible (probable?) that the reader of your code will assume
(wrongly) that your intent is to never mutate the array? That seems like a
reasonable inference to me. Imagine their confusion if later you do in fact
allow the array value referenced by <code>magicNums</code> to be mutated. Might that
surprise them?</p>
<p>Worse, what if you intentionally mutate <code>magicNums</code> in some way that turns out
to not be obvious to the reader? Subsequently in the code, they see a usage of
<code>magicNums</code> and assume (again, wrongly) that it's still <code>[1,2,3,4]</code> because they
read your intent as, &quot;not gonna change this&quot;.</p>
<p>I think you should use <code>var</code> or <code>let</code> for declaring variables to hold values
that you intend to mutate. I think that actually is a <strong>much clearer signal</strong> of
your intent than using <code>const</code>.</p>
<p>But the troubles with <code>const</code> don't stop there. Remember we asserted at the top
of the chapter that to treat values as immutable means that when our state needs
to change, we have to create a new value instead of mutating it? What are you
going to do with that new array once you've created it? If you declared your
reference to it using <code>const</code>, you can't reassign it.</p>
<pre><code class="language-js">const magicNums = [1, 2, 3, 4];

// later:
magicNums = magicNums.concat(42); // oops, can't reassign!
</code></pre>
<p>So... what next?</p>
<p>In this light, I see <code>const</code> as actually making our efforts to adhere to FP
harder, not easier. My conclusion: <code>const</code> is not all that useful. It creates
unnecessary confusion and restricts us in inconvenient ways. I only use <code>const</code>
for simple constants like:</p>
<pre><code class="language-js">const PI = 3.141592;
</code></pre>
<p>The value <code>3.141592</code> is already immutable, and I'm clearly signaling, &quot;this <code>PI</code>
will always be used as stand-in placeholder for this literal value.&quot; To me,
that's what <code>const</code> is good for. And to be frank, I don't use many of those
kinds of declarations in my typical coding.</p>
<p>I've written and seen a lot of JavaScript, and I just think it's an imagined
problem that very many of our bugs come from accidental reassignment.</p>
<p>One of the reasons FPers so highly favor <code>const</code> and avoid reassignment is
because of equational reasoning. Though this topic is more related to other
languages than JS and goes beyond what we'll get into here, it is a valid point.
However, I prefer the pragmatic view over the more academic one.</p>
<p>For example, I've found measured use of variable reassignment can be useful in
simplifying the description of intermediate states of computation. When a value
goes through multiple type coercions or other transformations, I don't generally
want to come up with new variable names for each representation:</p>
<pre><code class="language-js">var a = &quot;420&quot;;

// later

a = Number(a);

// later

a = [a];
</code></pre>
<p>If after changing from <code>&quot;420&quot;</code> to <code>420</code>, the original <code>&quot;420&quot;</code> value is no longer
needed, then I think it's more readable to reassign <code>a</code> rather than come up with
a new variable name like <code>aNum</code>.</p>
<p>The thing we really should worry more about is not whether our variables get
reassigned, but <strong>whether our values get mutated</strong>. Why? Because values are
portable; lexical assignments are not. You can pass an array to a function, and
it can be changed without you realizing it. But a reassignment will never be
unexpectedly caused by some other part of your program.</p>
<h3><a class="header" href="#its-freezing-in-here" id="its-freezing-in-here">It's Freezing in Here</a></h3>
<p>There's a cheap and simple way to turn a mutable object/array/function into an
&quot;immutable value&quot; (of sorts):</p>
<pre><code class="language-js">var x = Object.freeze([2]);
</code></pre>
<p>The <code>Object.freeze(..)</code> utility goes through all the properties/indices of an
object/array and marks them as read-only, so they cannot be reassigned. It's
sorta like declaring properties with a <code>const</code>, actually! <code>Object.freeze(..)</code>
also marks the properties as non-reconfigurable, and it marks the object/array
itself as non-extensible (no new properties can be added). In effect, it makes
the top level of the object immutable.</p>
<p>Top level only, though. Be careful!</p>
<pre><code class="language-js">var x = Object.freeze([2, 3, [4, 5]]);

// not allowed:
x[0] = 42;

// oops, still allowed:
x[2][0] = 42;
</code></pre>
<p><code>Object.freeze(..)</code> provides shallow, naive immutability. You'll have to walk
the entire object/array structure manually and apply <code>Object.freeze(..)</code> to each
sub-object/array if you want a deeply immutable value.</p>
<p>But contrasted with <code>const</code> which can confuse you into thinking you're getting
an immutable value when you aren't, <code>Object.freeze(..)</code> <em>actually</em> gives you an
immutable value.</p>
<p>Recall the protection example from earlier:</p>
<pre><code class="language-js">var arr = Object.freeze([1, 2, 3]);

foo(arr);

console.log(arr[0]); // 1
</code></pre>
<p>Now <code>arr[0]</code> is quite reliably <code>1</code>.</p>
<p>This is so important because it makes reasoning about our code much easier when
we know we can trust that a value doesn't change when passed somewhere that we
do not see or control.</p>
<h2><a class="header" href="#performance" id="performance">Performance</a></h2>
<p>Whenever we start creating new values (arrays, objects, etc.) instead of
mutating existing ones, the obvious next question is: what does that mean for
performance?</p>
<p>If we have to reallocate a new array each time we need to add to it, that's not
only churning CPU time and consuming extra memory; the old values (if no longer
referenced) are also being garbage collected. That's even more CPU burn.</p>
<p>Is that an acceptable trade-off? It depends. No discussion or optimization of
code performance should happen <strong>without context.</strong></p>
<p>If you have a single state change that happens once (or even a couple of times)
in the whole life of the program, throwing away an old array/object for a new
one is almost certainly not a concern. The churn we're talking about will be so
small -- probably mere microseconds at most -- as to have no practical effect on
the performance of your application. Compared to the minutes or hours you will
save not having to track down and fix a bug related to unexpected value
mutation, there's not even a contest here.</p>
<p>Then again, if such an operation is going to occur frequently, or specifically
happen in a <em>critical path</em> of your application, then performance -- consider
both performance and memory! -- is a totally valid concern.</p>
<p>Think about a specialized data structure that's like an array, but that you want
to be able to make changes to and have each change behave implicitly as if the
result was a new array. How could you accomplish this without actually creating
a new array each time? Such a special array data structure could store the
original value and then track each change made as a delta from the previous
version.</p>
<p>Internally, it might be like a linked-list tree of object references where each
node in the tree represents a mutation of the original value. Actually, this is
conceptually similar to how <strong>Git</strong> version control works.</p>
<p align="center">
    <img alt="figure" src="images/fig18.png" width="33%">
</p>
<p>In this conceptual illustration, an original array <code>[3,6,1,0]</code> first has the
mutation of value <code>4</code> assigned to position <code>0</code> (resulting in <code>[4,6,1,0]</code>), then
<code>1</code> is assigned to position <code>3</code> (now <code>[4,6,1,1]</code>), finally <code>2</code> is assigned to
position <code>4</code> (result: <code>[4,6,1,1,2]</code>). The key idea is that at each mutation,
only the change from the previous version is recorded, not a duplication of the
entire original data structure. This approach is much more efficient in both
memory and CPU performance, in general.</p>
<p>Imagine using this hypothetical specialized array data structure like this:</p>
<pre><code class="language-js">var state = specialArray(4, 6, 1, 1);

var newState = state.set(4, 2);

state === newState; // false

state.get(2); // 1
state.get(4); // undefined

newState.get(2); // 1
newState.get(4); // 2

newState.slice(2, 5); // [1,1,2]
</code></pre>
<p>The <code>specialArray(..)</code> data structure would internally keep track of each
mutation operation (like <code>set(..)</code>) as a <em>diff</em>, so it won't have to reallocate
memory for the original values (<code>4</code>, <code>6</code>, <code>1</code>, and <code>1</code>) just to add the <code>2</code>
value to the end of the list. But importantly, <code>state</code> and <code>newState</code> point at
different versions (or views) of the array value, so <strong>the value immutability
semantic is preserved.</strong></p>
<p>Inventing your own performance-optimized data structures is an interesting
challenge. But pragmatically, you should probably use a library that already
does this well. One great option is
<a href="http://facebook.github.io/immutable-js">Immutable.js</a>, which provides a variety
of data structures, including <code>List</code> (like array) and <code>Map</code> (like object).</p>
<p>Consider the previous <code>specialArray</code> example but using <code>Immutable.List</code>:</p>
<pre><code class="language-js">var state = Immutable.List.of(4, 6, 1, 1);

var newState = state.set(4, 2);

state === newState; // false

state.get(2); // 1
state.get(4); // undefined

newState.get(2); // 1
newState.get(4); // 2

newState.toArray().slice(2, 5); // [1,1,2]
</code></pre>
<p>A powerful library like Immutable.js employs sophisticated performance
optimizations. Handling all the details and corner-cases manually without such a
library would be quite difficult.</p>
<p>When changes to a value are few or infrequent and performance is less of a
concern, I'd recommend the lighter-weight solution, sticking with built-in
<code>Object.freeze(..)</code> as discussed earlier.</p>
<h2><a class="header" href="#treatment" id="treatment">Treatment</a></h2>
<p>What if we receive a value to our function and we're not sure if it's mutable or
immutable? Is it ever OK to just go ahead and try to mutate it? <strong>No.</strong> As we
asserted at the beginning of this chapter, we should treat all received values
as immutable -- to avoid side effects and remain pure -- regardless of whether
they are or not.</p>
<p>Recall this example from earlier:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  var newUserRecord = Object.assign({}, user);
  newUserRecord.lastLogin = Date.now();
  return newUserRecord;
}
</code></pre>
<p>This implementation treats <code>user</code> as a value that should not be mutated; whether
it <em>is</em> immutable or not is irrelevant to reading this part of the code.
Contrast that with this implementation:</p>
<pre><code class="language-js">function updateLastLogin(user) {
  user.lastLogin = Date.now();
  return user;
}
</code></pre>
<p>That version is a lot easier to write, and even performs better. But not only
does this approach make <code>updateLastLogin(..)</code> impure, it also mutates a value in
a way that makes both the reading of this code, as well as the places it's used,
more complicated.</p>
<p><strong>We should treat <code>user</code> as immutable</strong>, always, because at this point of
reading the code we do not know where the value comes from, or what potential
issues we may cause if we mutate it.</p>
<p>Nice examples of this approach can be seen in various built-in methods of the JS
array, such as <code>concat(..)</code> and <code>slice(..)</code>:</p>
<pre><code class="language-js">var arr = [1, 2, 3, 4, 5];

var arr2 = arr.concat(6);

arr; // [1,2,3,4,5]
arr2; // [1,2,3,4,5,6]

var arr3 = arr2.slice(1);

arr2; // [1,2,3,4,5,6]
arr3; // [2,3,4,5,6]
</code></pre>
<p>Other array prototype methods that treat the value instance as immutable and
return a new array instead of mutating: <code>map(..)</code> and <code>filter(..)</code>. The
<code>reduce(..)</code>/<code>reduceRight(..)</code> utilities also avoid mutating the instance,
though they don't by default return a new array.</p>
<p>Unfortunately, for historical reasons, quite a few other array methods are
impure mutators of their instance: <code>splice(..)</code>, <code>pop(..)</code>, <code>push(..)</code>,
<code>shift(..)</code>, <code>unshift(..)</code>, <code>reverse(..)</code>, <code>sort(..)</code>, and <code>fill(..)</code>.</p>
<p>It should not be seen as <em>forbidden</em> to use these kinds of utilities, as some
claim. For reasons such as performance optimization, sometimes you will want to
use them. But you should never use such a method on an array value that is not
already local to the function you're working in, to avoid creating a side effect
on some other remote part of the code.</p>
<p><a name="hiddenmutation"></a></p>
<p>Recall one of the implementations of
<a href="chapter_4.html"><code>compose(..)</code> from Chapter 4</a>:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    // copy the array of functions
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = list.pop()(result);
    }

    return result;
  };
}
</code></pre>
<p>The <code>...fns</code> gather parameter is making a new local array from the passed-in
arguments, so it's not an array that we could create an outside side effect on.
It would be reasonable then to assume that it's safe for us to mutate it
locally. But the subtle gotcha here is that the inner <code>composed(..)</code> which
closes over <code>fns</code> is not &quot;local&quot; in this sense.</p>
<p>Consider this different version which doesn't make a copy:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    while (fns.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = fns.pop()(result);
    }

    return result;
  };
}

var f = compose(
  x =&gt; x / 3,
  x =&gt; x + 1,
  x =&gt; x * 2
);

f(4); // 3

f(4); // 4 &lt;-- uh oh!
</code></pre>
<p>The second usage of <code>f(..)</code> here wasn't correct, since we mutated that <code>fns</code>
during the first call, which affected any subsequent uses. Depending on the
circumstances, making a copy of an array like <code>list = [...fns]</code> may or may not
be necessary. But I think it's safest to assume you need it -- even if only for
readability sake! -- unless you can prove you don't, rather than the other way
around.</p>
<p>Be disciplined and always treat <em>received values</em> as immutable, whether they are
or not. That effort will improve the readability and trustability of your code.</p>
<h2><a class="header" href="#summary-5" id="summary-5">Summary</a></h2>
<p>Value immutability is not about unchanging values. It's about creating and
tracking new values as the state of the program changes, rather than mutating
existing values. This approach leads to more confidence in reading the code,
because we limit the places where our state can change in ways we don't readily
see or expect.</p>
<p><code>const</code> declarations (constants) are commonly mistaken for their ability to
signal intent and enforce immutability. In reality, <code>const</code> has basically
nothing to do with value immutability, and its usage will likely create more
confusion than it solves. Instead, <code>Object.freeze(..)</code> provides a nice built-in
way of setting shallow value immutability on an array or object. In many cases,
this will be sufficient.</p>
<p>For performance-sensitive parts of the program, or in cases where changes happen
frequently, creating a new array or object (especially if it contains lots of
data) is undesirable, for both processing and memory concerns. In these cases,
using immutable data structures from a library like <strong>Immutable.js</strong> is probably
the best idea.</p>
<p>The importance of value immutability on code readability is less in the
inability to change a value, and more in the discipline to treat a value as
immutable.</p>
<h1><a class="header" href="#functional-light-javascript-8" id="functional-light-javascript-8">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-7-closure-vs-object" id="chapter-7-closure-vs-object">Chapter 7: Closure vs. Object</a></h1>
<p>A number of years ago, Anton van Straaten crafted what has become a rather
famous and oft-cited <a href="https://www.merriam-webster.com/dictionary/koan">koan</a> to
illustrate and provoke an important tension between closure and objects:</p>
<blockquote>
<p>The venerable master Qc Na was walking with his student, Anton. Hoping to
prompt the master into a discussion, Anton said &quot;Master, I have heard that
objects are a very good thing - is this true?&quot; Qc Na looked pityingly at his
student and replied, &quot;Foolish pupil - objects are merely a poor man's
closures.&quot;</p>
<p>Chastised, Anton took his leave from his master and returned to his cell,
intent on studying closures. He carefully read the entire &quot;Lambda: The
Ultimate...&quot; series of papers and its cousins, and implemented a small Scheme
interpreter with a closure-based object system. He learned much, and looked
forward to informing his master of his progress.</p>
<p>On his next walk with Qc Na, Anton attempted to impress his master by saying
&quot;Master, I have diligently studied the matter, and now understand that objects
are truly a poor man's closures.&quot; Qc Na responded by hitting Anton with his
stick, saying &quot;When will you learn? Closures are a poor man's object.&quot; At that
moment, Anton became enlightened.</p>
<p>-- Anton van Straaten 6/4/2003</p>
<p>http://people.csail.mit.edu/gregs/ll1-discuss-archive-html/msg03277.html</p>
</blockquote>
<p>The original posting, while brief, has more context to the origin and
motivations, and I strongly suggest you read that post to properly set your
mindset for approaching this chapter.</p>
<p>Many people I've observed read this koan smirk at its clever wit but then move
on without it changing much about their thinking. However, the purpose of a koan
(from the Zen Buddhist perspective) is to prod the reader into wrestling with
the contradictory truths therein. So, go back and read it again. Now read it
again.</p>
<p>Which is it? Is a closure a poor man's object, or is an object a poor man's
closure? Or neither? Or both? Is merely the take-away that closures and objects
are in some way equivalent?</p>
<p>And what does any of this have to do with functional programming? Pull up a
chair and ponder for a while. This chapter will be an interesting detour, an
excursion if you will.</p>
<h2><a class="header" href="#the-same-page" id="the-same-page">The Same Page</a></h2>
<p>First, let's make sure we're all on the same page when we refer to closures and
objects. We're obviously in the context of how JavaScript deals with these two
mechanisms, and specifically talking about simple function closure (see
<a href="chapter_2.html">Chapter 2, &quot;Keeping Scope&quot;</a>) and simple objects
(collections of key-value pairs).</p>
<p>For the record, here's an illustration of a simple function closure:</p>
<pre><code class="language-js">function outer() {
  var one = 1;
  var two = 2;

  return function inner() {
    return one + two;
  };
}

var three = outer();

three(); // 3
</code></pre>
<p>And an illustration of a simple object:</p>
<pre><code class="language-js">var obj = {
  one: 1,
  two: 2
};

function three(outer) {
  return outer.one + outer.two;
}

three(obj); // 3
</code></pre>
<p>Many people conjure lots of extra things when you mention &quot;closure&quot;, such as the
asynchronous callbacks or even the module pattern with encapsulation and
information hiding. Similarly, &quot;object&quot; brings to mind classes, <code>this</code>,
prototypes, and a whole slew of other utilities and patterns.</p>
<p>As we go along, we'll carefully address the parts of this external context that
matter, but for now, try to just stick to the simplest interpretations of
&quot;closure&quot; and &quot;object&quot; as illustrated here; it'll make our exploration less
confusing.</p>
<h2><a class="header" href="#look-alike" id="look-alike">Look Alike</a></h2>
<p>It may not be obvious how closures and objects are related. So let's explore
their similarities first.</p>
<p>To frame this discussion, let me just briefly assert two things:</p>
<ol>
<li>A programming language without closures can simulate them with objects
instead.</li>
<li>A programming language without objects can simulate them with closures
instead.</li>
</ol>
<p>In other words, we can think of closures and objects as two different
representations of a thing.</p>
<h3><a class="header" href="#state" id="state">State</a></h3>
<p>Consider this code from before:</p>
<pre><code class="language-js">function outer() {
  var one = 1;
  var two = 2;

  return function inner() {
    return one + two;
  };
}

var obj = {
  one: 1,
  two: 2
};
</code></pre>
<p>Both the scope closed over by <code>inner()</code> and the object <code>obj</code> contain two
elements of state: <code>one</code> with value <code>1</code> and <code>two</code> with value <code>2</code>. Syntactically
and mechanically, these representations of state are different. But
conceptually, they're actually quite similar.</p>
<p>As a matter of fact, it's fairly straightforward to represent an object as a
closure, or a closure as an object. Go ahead, try it yourself:</p>
<pre><code class="language-js">var point = {
  x: 10,
  y: 12,
  z: 14
};
</code></pre>
<p>Did you come up with something like?</p>
<pre><code class="language-js">function outer() {
  var x = 10;
  var y = 12;
  var z = 14;

  return function inner() {
    return [x, y, z];
  };
}

var point = outer();
</code></pre>
<p><strong>Note:</strong> The <code>inner()</code> function creates and returns a new array (aka, an
object!) each time it's called. That's because JS doesn't afford us any
capability to <code>return</code> multiple values without encapsulating them in an object.
That's not technically a violation of our object-as-closure task, because it's
just an implementation detail of exposing/transporting values; the state
tracking itself is still object-free. With ES6+ array destructuring, we can
declaratively ignore this temporary intermediate array on the other side:
<code>var [x,y,z] = point()</code>. From a developer ergonomics perspective, the values are
stored individually and tracked via closure instead of objects.</p>
<p>What if we have nested objects?</p>
<pre><code class="language-js">var person = {
  name: &quot;Kyle Simpson&quot;,
  address: {
    street: &quot;123 Easy St&quot;,
    city: &quot;JS'ville&quot;,
    state: &quot;ES&quot;
  }
};
</code></pre>
<p>We could represent that same kind of state with nested closures:</p>
<pre><code class="language-js">function outer() {
  var name = &quot;Kyle Simpson&quot;;
  return middle();

  // ********************

  function middle() {
    var street = &quot;123 Easy St&quot;;
    var city = &quot;JS'ville&quot;;
    var state = &quot;ES&quot;;

    return function inner() {
      return [name, street, city, state];
    };
  }
}

var person = outer();
</code></pre>
<p>Let's practice going the other direction, from closure to object:</p>
<pre><code class="language-js">function point(x1, y1) {
  return function distFromPoint(x2, y2) {
    return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
  };
}

var pointDistance = point(1, 1);

pointDistance(4, 5); // 5
</code></pre>
<p><code>distFromPoint(..)</code> is closed over <code>x1</code> and <code>y1</code>, but we could instead
explicitly pass those values as an object:</p>
<pre><code class="language-js">function pointDistance(point, x2, y2) {
  return Math.sqrt(Math.pow(x2 - point.x1, 2) + Math.pow(y2 - point.y1, 2));
}

pointDistance(
  { x1: 1, y1: 1 },
  4, // x2
  5 // y2
);
// 5
</code></pre>
<p>The <code>point</code> object state explicitly passed in replaces the closure that
implicitly held that state.</p>
<h3><a class="header" href="#behavior-too" id="behavior-too">Behavior, Too!</a></h3>
<p>It's not just that objects and closures represent ways to express collections of
state, but also that they can include behavior via functions/methods. Bundling
data with its behavior has a fancy name: encapsulation.</p>
<p>Consider:</p>
<pre><code class="language-js">function person(name,age) {
    return happyBirthday(){
        age++;
        console.log(
            `Happy ${age}th Birthday, ${name}!`
        );
    }
}

var birthdayBoy = person( &quot;Kyle&quot;, 36 );

birthdayBoy();          // Happy 37th Birthday, Kyle!
</code></pre>
<p>The inner function <code>happyBirthday()</code> has closure over <code>name</code> and <code>age</code> so that
the functionality therein is kept with the state.</p>
<p>We can achieve that same capability with a <code>this</code> binding to an object:</p>
<pre><code class="language-js">var birthdayBoy = {
  name: &quot;Kyle&quot;,
  age: 36,
  happyBirthday() {
    this.age++;
    console.log(`Happy ${this.age}th Birthday, ${this.name}!`);
  }
};

birthdayBoy.happyBirthday();
// Happy 37th Birthday, Kyle!
</code></pre>
<p>We're still expressing the encapsulation of state data with the
<code>happyBirthday()</code> function, but with an object instead of a closure. And we
don't have to explicitly pass in an object to a function (as with earlier
examples); JavaScript's <code>this</code> binding easily creates an implicit binding.</p>
<p>Another way to analyze this relationship: a closure associates a single function
with a set of state, whereas an object holding the same state can have any
number of functions to operate on that state.</p>
<p>As a matter of fact, you could even expose multiple methods with a single
closure as the interface. Consider a traditional object with two methods:</p>
<pre><code class="language-js">var person = {
  firstName: &quot;Kyle&quot;,
  lastName: &quot;Simpson&quot;,
  first() {
    return this.firstName;
  },
  last() {
    return this.lastName;
  }
};

person.first() + &quot; &quot; + person.last();
// Kyle Simpson
</code></pre>
<p>Just using closure without objects, we could represent this program as:</p>
<pre><code class="language-js">function createPerson(firstName, lastName) {
  return API;

  // ********************

  function API(methodName) {
    switch (methodName) {
      case &quot;first&quot;:
        return first();
        break;
      case &quot;last&quot;:
        return last();
        break;
    }
  }

  function first() {
    return firstName;
  }

  function last() {
    return lastName;
  }
}

var person = createPerson(&quot;Kyle&quot;, &quot;Simpson&quot;);

person(&quot;first&quot;) + &quot; &quot; + person(&quot;last&quot;);
// Kyle Simpson
</code></pre>
<p>While these programs look and feel a bit different ergonomically, they're
actually just different implementation variations of the same program behavior.</p>
<h3><a class="header" href="#immutability" id="immutability">(Im)mutability</a></h3>
<p>Many people will initially think that closures and objects behave differently
with respect to mutability; closures protect from external mutation while
objects do not. But, it turns out, both forms have identical mutation behavior.</p>
<p>That's because what we care about, as discussed in <a href="chapter_6.html">Chapter 6</a>, is
<strong>value</strong> mutability, and this is a characteristic of the value itself,
regardless of where or how it's assigned:</p>
<pre><code class="language-js">function outer() {
  var x = 1;
  var y = [2, 3];

  return function inner() {
    return [x, y[0], y[1]];
  };
}

var xyPublic = {
  x: 1,
  y: [2, 3]
};
</code></pre>
<p>The value stored in the <code>x</code> lexical variable inside <code>outer()</code> is immutable --
remember, primitives like <code>2</code> are by definition immutable. But the value
referenced by <code>y</code>, an array, is definitely mutable. The exact same goes for the
<code>x</code> and <code>y</code> properties on <code>xyPublic</code>.</p>
<p>We can reinforce the point that objects and closures have no bearing on
mutability by pointing out that <code>y</code> is itself an array, and thus we need to
break this example down further:</p>
<pre><code class="language-js">function outer() {
  var x = 1;
  return middle();

  // ********************

  function middle() {
    var y0 = 2;
    var y1 = 3;

    return function inner() {
      return [x, y0, y1];
    };
  }
}

var xyPublic = {
  x: 1,
  y: {
    0: 2,
    1: 3
  }
};
</code></pre>
<p>If you think about it as &quot;turtles (aka, objects) all the way down&quot;, at the
lowest level, all state data is primitives, and all primitives are
value-immutable.</p>
<p>Whether you represent this state with nested objects, or with nested closures,
the values being held are all immutable.</p>
<h3><a class="header" href="#isomorphic" id="isomorphic">Isomorphic</a></h3>
<p>The term &quot;isomorphic&quot; gets thrown around a lot in JavaScript these days, and
it's usually used to refer to code that can be used/shared in both the server
and the browser. I wrote a blog post a while back that calls bogus on that usage
of this word &quot;isomorphic&quot;, which actually has an explicit and important meaning
that's being clouded.</p>
<p>Here's some selections from a part of that post:</p>
<blockquote>
<p>What does isomorphic mean? Well, we could talk about it in mathematical terms,
or sociology, or biology. The general notion of isomorphism is that you have
two things which are similar in structure but not the same.</p>
<p>In all those usages, isomorphism is differentiated from equality in this way:
two values are equal if they’re exactly identical in all ways, but they are
isomorphic if they are represented differently but still have a 1-to-1,
bi-directional mapping relationship.</p>
<p>In other words, two things A and B would be isomorphic if you could map
(convert) from A to B and then go back to A with the inverse mapping.</p>
</blockquote>
<p>Recall in <a href="chapter_2.html">Chapter 2, &quot;Brief Math Review&quot;</a>, we
discussed the mathematical definition of a function as being a mapping between
inputs and outputs. We pointed out this is technically called a morphism. An
isomorphism is a special case of bijective (aka, 2-way) morphism that requires
not only that the mapping must be able to go in either direction, but also that
the behavior is identical in either form.</p>
<p>But instead of thinking about numbers, let's relate isomorphism to code. Again
quoting my blog post:</p>
<blockquote>
<p>[W]hat would isomorphic JS be if there were such a thing? Well, it could be
that you have one set of JS code that is converted to another set of JS code,
and that (importantly) you could convert from the latter back to the former if
you wanted.</p>
</blockquote>
<p>As we asserted earlier with our examples of closures-as-objects and
objects-as-closures, these representative alternations go either way. In this
respect, they are isomorphisms to each other.</p>
<p>Put simply, closures and objects are isomorphic representations of state (and
its associated functionality).</p>
<p>The next time you hear someone say &quot;X is isomorphic to Y&quot;, what they mean is, &quot;X
and Y can be converted from either one to the other in either direction, and not
lose information.&quot;</p>
<h3><a class="header" href="#under-the-hood" id="under-the-hood">Under the Hood</a></h3>
<p>So, we can think of objects as an isomorphic representation of closures from the
perspective of code we could write. But we can also observe that a closure
system could actually be implemented -- and likely is -- with objects!</p>
<p>Think about it this way: in the following code, how is JS keeping track of the
<code>x</code> variable for <code>inner()</code> to keep referencing, well after <code>outer()</code> has already
run?</p>
<pre><code class="language-js">function outer() {
  var x = 1;

  return function inner() {
    return x;
  };
}
</code></pre>
<p>We could imagine that the scope -- the set of all variables defined -- of
<code>outer()</code> is implemented as an object with properties. So, conceptually,
somewhere in memory, there's something like:</p>
<pre><code class="language-js">scopeOfOuter = {
  x: 1
};
</code></pre>
<p>And then for the <code>inner()</code> function, when created, it gets an (empty) scope
object called <code>scopeOfInner</code>, which is linked via its <code>[[Prototype]]</code> to the
<code>scopeOfOuter</code> object, sorta like this:</p>
<pre><code class="language-js">scopeOfInner = {};
Object.setPrototypeOf(scopeOfInner, scopeOfOuter);
</code></pre>
<p>Then, inside <code>inner()</code>, when it makes reference to the lexical variable <code>x</code>,
it's actually more like:</p>
<pre><code class="language-js">return scopeOfInner.x;
</code></pre>
<p><code>scopeOfInner</code> doesn't have an <code>x</code> property, but it's <code>[[Prototype]]</code>-linked to
<code>scopeOfOuter</code>, which does have an <code>x</code> property. Accessing <code>scopeOfOuter.x</code> via
prototype delegation results in the <code>1</code> value being returned.</p>
<p>In this way, we can sorta see why the scope of <code>outer()</code> is preserved (via
closure) even after it finishes: because the <code>scopeOfInner</code> object is linked to
the <code>scopeOfOuter</code> object, thereby keeping that object and its properties alive
and well.</p>
<p>Now, this is all conceptual. I'm not literally saying the JS engine uses objects
and prototypes. But it's entirely plausible that it <em>could</em> work similarly.</p>
<p>Many languages do in fact implement closures via objects. And other languages
implement objects in terms of closures. But we'll let the reader use their
imagination on how that would work.</p>
<h2><a class="header" href="#two-roads-diverged-in-a-wood" id="two-roads-diverged-in-a-wood">Two Roads Diverged in a Wood...</a></h2>
<p>So closures and objects are equivalent, right? Not quite. I bet they're more
similar than you thought before you started this chapter, but they still have
important differences.</p>
<p>These differences should not be viewed as weaknesses or arguments against usage;
that's the wrong perspective. They should be viewed as features and advantages
that make one or the other more suitable (and readable!) for a given task.</p>
<h3><a class="header" href="#structural-mutability" id="structural-mutability">Structural Mutability</a></h3>
<p>Conceptually, the structure of a closure is not mutable.</p>
<p>In other words, you can never add to or remove state from a closure. Closure is
a characteristic of where variables are declared (fixed at author/compile time),
and is not sensitive to any runtime conditions -- assuming you use strict mode
and/or avoid using cheats like <code>eval(..)</code>, of course!</p>
<p><strong>Note:</strong> The JS engine could technically cull a closure to weed out any
variables in its scope that are no longer going to be used, but this is an
advanced optimization that's transparent to the developer. Whether the engine
actually does these kinds of optimizations, I think it's safest for the
developer to assume that closure is per-scope rather than per-variable. If you
don't want it to stay around, don't close over it!</p>
<p>However, objects by default are quite mutable. You can freely add or remove
(<code>delete</code>) properties/indices from an object, as long as that object hasn't been
frozen (<code>Object.freeze(..)</code>).</p>
<p>It may be an advantage of the code to be able to track more (or less!) state
depending on the runtime conditions in the program.</p>
<p>For example, let's imagine tracking the keypress events in a game. Almost
certainly, you'll think about using an array to do this:</p>
<pre><code class="language-js">function trackEvent(evt, keypresses = []) {
  return [...keypresses, evt];
}

var keypresses = trackEvent(newEvent1);

keypresses = trackEvent(newEvent2, keypresses);
</code></pre>
<p><strong>Note:</strong> Did you spot why I didn't <code>push(..)</code> directly to <code>keypresses</code>? Because
in FP, we typically want to treat arrays as immutable data structures that can
be re-created and added to, but not directly changed. We trade out the evil of
side-effects for an explicit reassignment (more on that later).</p>
<p>Though we're not changing the structure of the array, we could if we wanted to.
More on this in a moment.</p>
<p>But an array is not the only way to track this growing &quot;list&quot; of <code>evt</code> objects.
We could use closure:</p>
<pre><code class="language-js">function trackEvent(evt, keypresses = () =&gt; []) {
  return function newKeypresses() {
    return [...keypresses(), evt];
  };
}

var keypresses = trackEvent(newEvent1);

keypresses = trackEvent(newEvent2, keypresses);
</code></pre>
<p>Do you spot what's happening here?</p>
<p>Each time we add a new event to the &quot;list&quot;, we create a new closure wrapped
around the existing <code>keypresses()</code> function (closure), which captures the
current <code>evt</code>. When we call the <code>keypresses()</code> function, it will successively
call all the nested functions, building up an intermediate array of all the
individually closed-over <code>evt</code> objects. Again, closure is the mechanism that's
tracking all the state; the array you see is only an implementation detail of
needing a way to return multiple values from a function.</p>
<p>So which one is better suited for our task? No surprise here, the array approach
is probably a lot more appropriate. The structural immutability of a closure
means our only option is to wrap more closure around it. Objects are by default
extensible, so we can just grow the array as needed.</p>
<p>By the way, even though I'm presenting this structural (im)mutability as a clear
difference between closure and object, the way we're using the object as an
immutable value is actually more similar than not.</p>
<p>Creating a new array for each addition to the array is treating the array as
structurally immutable, which is conceptually symmetrical to closure being
structurally immutable by its very design.</p>
<h3><a class="header" href="#privacy" id="privacy">Privacy</a></h3>
<p>Probably one of the first differences you think of when analyzing closure vs.
object is that closure offers &quot;privacy&quot; of state through nested lexical scoping,
whereas objects expose everything as public properties. Such privacy has a fancy
name: information hiding.</p>
<p>Consider lexical closure hiding:</p>
<pre><code class="language-js">function outer() {
  var x = 1;

  return function inner() {
    return x;
  };
}

var xHidden = outer();

xHidden(); // 1
</code></pre>
<p>Now the same state in public:</p>
<pre><code class="language-js">var xPublic = {
  x: 1
};

xPublic.x; // 1
</code></pre>
<p>There are some obvious differences around general software engineering
principles -- consider abstraction, the module pattern with public and private
APIs, etc. -- but let's try to constrain our discussion to the perspective of
FP; this is, after all, a book about functional programming!</p>
<h4><a class="header" href="#visibility" id="visibility">Visibility</a></h4>
<p>It may seem that the ability to hide information is a desired characteristic of
state tracking, but I believe the FPer might argue the opposite.</p>
<p>One of the advantages of managing state as public properties on an object is
that it's easier to enumerate (and iterate!) all the data in your state. Imagine
you wanted to process each keypress event (from the earlier example) to save it
to a database, using a utility like:</p>
<pre><code class="language-js">function recordKeypress(keypressEvt) {
  // database utility
  DB.store(&quot;keypress-events&quot;, keypressEvt);
}
</code></pre>
<p>If you already have an array -- just an object with public numerically named
properties -- this is very straightforward using a built-in JS array utility
<code>forEach(..)</code>:</p>
<pre><code class="language-js">keypresses.forEach(recordKeypress);
</code></pre>
<p>But if the list of keypresses is hidden inside closure, you'll have to expose a
utility on the public API of the closure with privileged access to the hidden
data.</p>
<p>For example, we can give our closure-<code>keypresses</code> example its own <code>forEach</code>,
like built-in arrays have:</p>
<pre><code class="language-js">function trackEvent(
  evt,
  keypresses = {
    list() {
      return [];
    },
    forEach() {}
  }
) {
  return {
    list() {
      return [...keypresses.list(), evt];
    },
    forEach(fn) {
      keypresses.forEach(fn);
      fn(evt);
    }
  };
}

// ..

keypresses.list(); // [ evt, evt, .. ]

keypresses.forEach(recordKeypress);
</code></pre>
<p>The visibility of an object's state data makes using it more straightforward,
whereas closure obscures the state making us work harder to process it.</p>
<h4><a class="header" href="#change-control" id="change-control">Change Control</a></h4>
<p>If the lexical variable <code>x</code> is hidden inside a closure, the only code that has
the freedom to reassign it is also inside that closure; it's impossible to
modify <code>x</code> from the outside.</p>
<p>As we saw in <a href="chapter_6.html">Chapter 6</a>, that fact alone improves the readability
of code by reducing the surface area that the reader must consider to predict
the behavior of any given variable.</p>
<p>The local proximity of lexical reassignment is a big reason why I don't find
<code>const</code> as a feature that helpful. Scopes (and thus closures) should in general
be pretty small, and that means there will only be a few lines of code that can
affect reassignment. In <code>outer()</code> above, we can quickly inspect to see that no
line of code reassigns <code>x</code>, so for all intents and purposes it's acting as a
constant.</p>
<p>This kind of guarantee is a powerful contributor to our confidence in the purity
of a function, for example.</p>
<p>On the other hand, <code>xPublic.x</code> is a public property, and any part of the program
that gets a reference to <code>xPublic</code> has the ability, by default, to reassign
<code>xPublic.x</code> to some other value. That's a lot more lines of code to consider!</p>
<p>That's why in
<a href="chapter_6.html">Chapter 6, we looked at <code>Object.freeze(..)</code></a>
as a quick-n-dirty means of making all of an object's properties read-only
(<code>writable: false</code>), so that they can't be reassigned unpredictably.</p>
<p>Unfortunately, <code>Object.freeze(..)</code> is both all-or-nothing and irreversible.</p>
<p>With closure, you have some code with the privilege to change, and the rest of
the program is restricted. When you freeze an object, no part of the code will
be able to reassign. Moreover, once an object is frozen, it can't be thawed out,
so the properties will remain read-only for the duration of the program.</p>
<p>In places where I want to allow reassignment but restrict its surface area,
closures are a more convenient and flexible form than objects. In places where I
want no reassignment, a frozen object is a lot more convenient than repeating
<code>const</code> declarations all over my function.</p>
<p>Many FPers take a hard-line stance on reassignment: it shouldn't be used. They
will tend to use <code>const</code> to make all closure variables read-only, and they'll
use <code>Object.freeze(..)</code> or full immutable data structures to prevent property
reassignment. Moreover, they'll try to reduce the amount of explicitly
declared/tracked variables and properties wherever possible, preferring value
transfer -- function chains, <code>return</code> value passed as argument, etc. -- instead
of intermediate value storage.</p>
<p>This book is about &quot;Functional-Light&quot; programming in JavaScript, and this is one
of those cases where I diverge from the core FP crowd.</p>
<p>I think variable reassignment can be quite useful, and when used appropriately,
quite readable in its explicitness. It's certainly been my experience that
debugging is a lot easier when you can insert a <code>debugger</code> or breakpoint, or
track a watch expression.</p>
<h3><a class="header" href="#cloning-state" id="cloning-state">Cloning State</a></h3>
<p>As we learned in <a href="chapter_6.html">Chapter 6</a>, one of the best ways we prevent side
effects from eroding the predictability of our code is to make sure we treat all
state values as immutable, regardless of whether they are actually immutable
(frozen) or not.</p>
<p>If you're not using a purpose-built library to provide sophisticated immutable
data structures, the simplest approach will suffice: duplicate your
objects/arrays each time before making a change.</p>
<p>Arrays are easy to clone shallowly -- just use <code>...</code> array spread:</p>
<pre><code class="language-js">var a = [1, 2, 3];

var b = [...a];
b.push(4);

a; // [1,2,3]
b; // [1,2,3,4]
</code></pre>
<p>Objects can be shallow-cloned relatively easily too:</p>
<pre><code class="language-js">var o = {
  x: 1,
  y: 2
};

// in ES2018+, using object spread:
var p = { ...o };
p.y = 3;

// in ES6/ES2015+:
var p = Object.assign({}, o);
p.y = 3;
</code></pre>
<p>If the values in an object/array are themselves non-primitives (objects/arrays),
to get deep cloning you'll have to walk each layer manually to clone each nested
object. Otherwise, you'll have copies of shared references to those sub-objects,
and that's likely to create havoc in your program logic.</p>
<p>Did you notice that this cloning is possible only because all these state values
are visible and can thus be easily copied? What about a set of state wrapped up
in a closure; how would you clone that state?</p>
<p>That's much more tedious. Essentially, you'd have to do something similar to our
custom <code>forEach</code> API method earlier: provide a function inside each layer of the
closure with the privilege to extract/copy the hidden values, creating new
equivalent closures along the way.</p>
<p>Even though that's theoretically possible -- another exercise for the reader! --
it's far less practical to implement than you're likely to justify for any real
program.</p>
<p>Objects have a clear advantage when it comes to representing state that we need
to be able to clone.</p>
<h3><a class="header" href="#performance-1" id="performance-1">Performance</a></h3>
<p>One reason objects may be favored over closures, from an implementation
perspective, is that in JavaScript objects are often lighter-weight in terms of
memory and even computation.</p>
<p>But be careful with that as a general assertion: there are plenty of things you
can do with objects that will erase any performance gains you may get from
ignoring closure and moving to object-based state tracking.</p>
<p>Let's consider a scenario with both implementations. First, the closure-style
implementation:</p>
<pre><code class="language-js">function StudentRecord(name, major, gpa) {
  return function printStudent() {
    return `${name}, Major: ${major}, GPA: ${gpa.toFixed(1)}`;
  };
}

var student = StudentRecord(&quot;Kyle Simpson&quot;, &quot;CS&quot;, 4);

// later

student();
// Kyle Simpson, Major: CS, GPA: 4.0
</code></pre>
<p>The inner function <code>printStudent()</code> closes over three variables: <code>name</code>,
<code>major</code>, and <code>gpa</code>. It maintains this state wherever we transfer a reference to
that function -- we call it <code>student()</code> in this example.</p>
<p>Now for the object (and <code>this</code>) approach:</p>
<pre><code class="language-js">function StudentRecord() {
  return `${this.name}, Major: ${this.major}, \
GPA: ${this.gpa.toFixed(1)}`;
}

var student = StudentRecord.bind({
  name: &quot;Kyle Simpson&quot;,
  major: &quot;CS&quot;,
  gpa: 4
});

// later

student();
// Kyle Simpson, Major: CS, GPA: 4.0
</code></pre>
<p>The <code>student()</code> function -- technically referred to as a &quot;bound function&quot; -- has
a hard-bound <code>this</code> reference to the object literal we passed in, such that any
later call to <code>student()</code> will use that object for its <code>this</code>, and thus be able
to access its encapsulated state.</p>
<p>Both implementations have the same outcome: a function with preserved state. But
what about the performance; what differences will there be?</p>
<p><strong>Note:</strong> Accurately and actionably judging performance of a snippet of JS code
is a very dodgy affair. We won't get into all the details here, but I urge you
to read <em>You Don't Know JS: Async &amp; Performance</em>, specifically Chapter 6,
&quot;Benchmarking &amp; Tuning&quot;, for more details.</p>
<p>If you were writing a library that created a pairing of state with its function
-- either the call to <code>StudentRecord(..)</code> in the first snippet or the call to
<code>StudentRecord.bind(..)</code> in the second snippet -- you're likely to care most
about how those two perform. Inspecting the code, we can see that the former has
to create a new function expression each time. The second one uses <code>bind(..)</code>,
which is not as obvious in its implications.</p>
<p>One way to think about what <code>bind(..)</code> does under the covers is that it creates
a closure over a function, like this:</p>
<pre><code class="language-js">function bind(orinFn, thisObj) {
  return function boundFn(...args) {
    return origFn.apply(thisObj, args);
  };
}

var student = bind(StudentRecord, { name: &quot;Kyle..&quot; });
</code></pre>
<p>In this way, it looks like both implementations of our scenario create a
closure, so the performance is likely to be about the same.</p>
<p>However, the built-in <code>bind(..)</code> utility doesn't really have to create a closure
to accomplish the task. It simply creates a function and manually sets its
internal <code>this</code> to the specified object. That's potentially a more efficient
operation than if we did the closure ourselves.</p>
<p>The kind of performance savings we're talking about here is miniscule on an
individual operation. But if your library's critical path is doing this hundreds
or thousands of times or more, that savings can add up quickly. Many libraries
-- Bluebird being one such example -- have ended up optimizing by removing
closures and going with objects, in exactly this means.</p>
<p>Outside of the library use-case, the pairing of the state with its function
usually only happens relatively few times in the critical path of an
application. By contrast, typically the usage of the function+state -- calling
<code>student()</code> in either snippet -- is more common.</p>
<p>If that's the case for some given situation in your code, you should probably
care more about the performance of the latter versus the former.</p>
<p>Bound functions have historically had pretty lousy performance in general, but
have recently been much more highly optimized by JS engines. If you benchmarked
these variations a couple of years ago, it's entirely possible you'd get
different results repeating the same test with the latest engines.</p>
<p>A bound function is now likely to perform at least as good if not better as the
equivalent closed-over function. So that's another tick in favor of objects over
closures.</p>
<p>I just want to reiterate: these performance observations are not absolutes, and
the determination of what's best for a given scenario is very complex. Do not
just casually apply what you've heard from others or even what you've seen on
some other earlier project. Carefully examine whether objects or closures are
appropriately efficient for the task.</p>
<h2><a class="header" href="#summary-6" id="summary-6">Summary</a></h2>
<p>The truth of this chapter cannot be written out. One must read this chapter to
find its truth.</p>
<hr />
<p>Coining some Zen wisdom here was my attempt at being clever. But you deserve a
proper summary of this chapter's message.</p>
<p>Objects and closures are isomorphic to each other, which means that they can be
used somewhat interchangeably to represent state and behavior in your program.</p>
<p>Representation as a closure has certain benefits, like granular change control
and automatic privacy. Representation as an object has other benefits, like
easier cloning of state.</p>
<p>The critically thinking FPer should be able to conceive any segment of state and
behavior in the program with either representation, and pick the representation
that's most appropriate for the task at hand.</p>
<h1><a class="header" href="#functional-light-javascript-9" id="functional-light-javascript-9">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-8-recursion" id="chapter-8-recursion">Chapter 8: Recursion</a></h1>
<p>Did you have fun down our little closures/objects rabbit hole in the previous
chapter? Welcome back!</p>
<p>On the next page, we're going to jump into the topic of recursion.</p>
<hr>
<p><em>(rest of the page intentionally left blank)</em></p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<p>&nbsp;</p>
<div style="page-break-after: always;"></div>
<p>Let's talk about recursion. Before we dive in, consult the previous page for the
formal definition.</p>
<p>Weak joke, I know. :)</p>
<p>Recursion is one of those programming techniques that most developers admit can
be very powerful, but also most of them don't like to use it. I'd put it in the
same category as regular expressions, in that sense. Powerful, but confusing,
and thus seen as <em>not worth the effort</em>.</p>
<p>I'm a big fan of recursion, and you can, too! Unfortunately, many examples of
recursion focus on trivial academic tasks like generating Fibonacci sequences.
If you're needing those kinds of numbers in your program -- and let's face it,
that's not very common! -- you'll likely miss the big picture.</p>
<p>As a matter of fact, recursion is one of the most important ways that FP
developers avoid imperative looping and reassignment, by offloading the
implementation details to the language and engine. When used properly, recursion
is powerfully declarative for complex problems.</p>
<p>Sadly, recursion gets far less attention, especially in JS, than it should, in
large part because of some very real performance (speed and memory) limitations.
Our goal in this chapter is to dig deeper and find practical reasons that
recursion should be front and center in our FP.</p>
<h2><a class="header" href="#definition" id="definition">Definition</a></h2>
<p>Recursion is when a function calls itself, and that call does the same, and this
cycle continues until a base condition is satisfied and the call loop unwinds.</p>
<p><strong>Warning:</strong> If you don't ensure that a base condition is <em>eventually</em> met,
recursion will run forever, and crash or lock up your program; the base
condition is pretty important to get right!</p>
<p>But... that definition is too confusing in its written form. We can do better.
Consider this recursive function:</p>
<pre><code class="language-js">function foo(x) {
  if (x &lt; 5) return x;
  return foo(x / 2);
}
</code></pre>
<p>Let's visualize what happens with this function when we call <code>foo( 16 )</code>:</p>
<p align="center">
    <img alt="figure" src="images/fig13.png">
</p>
<p>In step 2, <code>x / 2</code> produces <code>8</code>, and that's passed in as the argument to a
recursive <code>foo(..)</code> call. In step 3, same thing, <code>x / 2</code> produces <code>4</code>, and
that's passed in as the argument to yet another <code>foo(..)</code> call. That part is
hopefully fairly straightforward.</p>
<p>But where someone may often get tripped up is what happens in step 4. Once we've
satisfied the base condition where <code>x</code> (value <code>4</code>) is <code>&lt; 5</code>, we no longer make
any more recursive calls, and just (effectively) do <code>return 4</code>. Specifically the
dotted line return of <code>4</code> in this figure simplifies what's happening there, so
let's dig into that last step and visualize it as these three sub-steps:</p>
<p align="center">
    <img alt="figure" src="images/fig14.png">
</p>
<p>Once the base condition is satisfied, the returned value cascades back through
all of the current function calls (and thus <code>return</code>s), eventually <code>return</code>ing
the final result out.</p>
<p>Another way to visualize this recursion is by considering the function calls in
the order they happen (commonly referred to as the call stack):</p>
<p align="center">
    <img alt="figure" src="images/fig19.png" width="30%">
</p>
<p>More on the call stack later in this chapter.</p>
<p>Another recursion example:</p>
<pre><code class="language-js">function isPrime(num, divisor = 2) {
  if (num &lt; 2 || (num &gt; 2 &amp;&amp; num % divisor == 0)) {
    return false;
  }
  if (divisor &lt;= Math.sqrt(num)) {
    return isPrime(num, divisor + 1);
  }

  return true;
}
</code></pre>
<p>This prime checking basically works by trying each integer from <code>2</code> up to the
square root of the <code>num</code> being checked, to see if any of them divide evenly (<code>%</code>
mod returning <code>0</code>) into the number. If any do, it's not a prime. Otherwise, it
must be prime. The <code>divisor + 1</code> uses the recursion to iterate through each
possible <code>divisor</code> value.</p>
<p>One of the most famous examples of recursion is calculating a Fibonacci number,
where the sequence is defined as:</p>
<pre><code class="language-txt">fib( 0 ): 0
fib( 1 ): 1
fib( n ):
    fib( n - 2 ) + fib( n - 1 )
</code></pre>
<p><strong>Note:</strong> The first several numbers of this sequence are: 0, 1, 1, 2, 3, 5, 8,
13, 21, 34, ... Each number is the addition of the previous two numbers in the
sequence.</p>
<p>The definition of Fibonacci expressed directly in code:</p>
<pre><code class="language-js">function fib(n) {
  if (n &lt;= 1) return n;
  return fib(n - 2) + fib(n - 1);
}
</code></pre>
<p><code>fib(..)</code> calls itself recursively twice, which is typically referred to as
binary recursion. We'll talk more about binary recursion later.</p>
<p>We'll use <code>fib(..)</code> variously throughout this chapter to illustrate ideas around
recursion, but one downside to this particular form is that there's an awful lot
of duplicated work. <code>fib(n-1)</code> and <code>fib(n-2)</code> don't share any of their work with
each other, but overlap with each other almost entirely, over the entire integer
space down to <code>0</code>.</p>
<p>We briefly touched on memoization in
<a href="chapter_5.html">Chapter 5, &quot;Performance Effects&quot;</a>. Here,
memoization would allow the <code>fib(..)</code> of any given number to be computed only
once, instead of being recomputed many times. We won't go further into that
topic here, but that performance caveat is important to keep in mind with any
algorithm, recursive or not.</p>
<h3><a class="header" href="#mutual-recursion" id="mutual-recursion">Mutual Recursion</a></h3>
<p>When a function calls itself, specifically, this is referred to as direct
recursion. That's what we saw in the previous section with <code>foo(..)</code>,
<code>isPrime(..)</code>, and <code>fib(..)</code>. When two or more functions call each other in a
recursive cycle, this is referred to as mutual recursion.</p>
<p>These two functions are mutually recursive:</p>
<pre><code class="language-js">function isOdd(v) {
  if (v === 0) return false;
  return isEven(Math.abs(v) - 1);
}

function isEven(v) {
  if (v === 0) return true;
  return isOdd(Math.abs(v) - 1);
}
</code></pre>
<p>Yes, this is a silly way to calculate if a number is odd or even. But it
illustrates the idea that certain algorithms can be defined in terms of mutual
recursion.</p>
<p>Recall the binary recursive <code>fib(..)</code> from the previous section; we could
instead have expressed it with mutual recursion:</p>
<pre><code class="language-js">function fib_(n) {
  if (n == 1) return 1;
  else return fib(n - 2);
}

function fib(n) {
  if (n == 0) return 0;
  else return fib(n - 1) + fib_(n);
}
</code></pre>
<p><strong>Note:</strong> This mutually recursive <code>fib(..)</code> implementation is adapted from
research presented in
<a href="https://www.researchgate.net/publication/246180510_Fibonacci_Numbers_Using_Mutual_Recursion">&quot;Fibonacci Numbers Using Mutual Recursion&quot;</a>.</p>
<p>While these mutual recursion examples shown are rather contrived, there are more
complex use cases where mutual recursion can be very helpful. Counting the
number of leaves in a tree data structure is one example, and recursive descent
parsing (of source code, by a compiler) is another.</p>
<h3><a class="header" href="#why-recursion" id="why-recursion">Why Recursion?</a></h3>
<p>Now that we've defined and illustrated recursion, we should examine why it is
useful.</p>
<p>The most commonly cited reason that recursion fits the spirit of FP is because
it trades (much of) the explicit tracking of state with implicit state on the
call stack. Typically, recursion is most useful when the problem requires
conditional branching and back-tracking, and managing that kind of state in a
purely iterative environment can be quite tricky; at a minimum, the code is
highly imperative and harder to read and verify. But tracking each level of
branching as its own scope on the call stack often significantly cleans up the
readability of the code.</p>
<p>Simple iterative algorithms can trivially be expressed as recursion:</p>
<pre><code class="language-js">function sum(total, ...nums) {
  for (let num of nums) {
    total = total + num;
  }

  return total;
}

// vs

function sum(num1, ...nums) {
  if (nums.length == 0) return num1;
  return num1 + sum(...nums);
}
</code></pre>
<p>It's not just that the <code>for</code>-loop is eliminated in favor of the call stack, but
that the incremental partial sums (the intermittent state of <code>total</code>) are
tracked implicitly across the <code>return</code>s of the call stack instead of reassigning
<code>total</code> each iteration. FPers will often prefer to avoid reassignment of local
variables where it's possible to avoid.</p>
<p>In a basic algorithm like this kind of summation, this difference is minor and
nuanced. But the more sophisticated your algorithm, the more you will likely see
the payoff of recursion instead of imperative state tracking.</p>
<h2><a class="header" href="#declarative-recursion" id="declarative-recursion">Declarative Recursion</a></h2>
<p>Mathematicians use the <strong>Σ</strong> symbol as a placeholder to represent the summation
of a list of numbers. The primary reason they do that is because it's more
cumbersome (and less readable!) if they're working with more complex formulas
and they have to write out the summation manually, like
<code>1 + 3 + 5 + 7 + 9 + ..</code>. Using the notation is declarative math!</p>
<p>Recursion is declarative for algorithms in the same sense that <strong>Σ</strong> is
declarative for mathematics. Recursion expresses that a problem solution exists,
but doesn't necessarily require the reader of the code to understand how that
solution works. Let's consider two approaches to finding the highest even number
passed as an argument:</p>
<pre><code class="language-js">function maxEven(...nums) {
  var maxNum = -Infinity;

  for (let num of nums) {
    if (num % 2 == 0 &amp;&amp; num &gt; maxNum) {
      maxNum = num;
    }
  }

  if (maxNum !== -Infinity) {
    return maxNum;
  }
}
</code></pre>
<p>This implementation is not particularly intractable, but it's also not readily
apparent what its nuances are. How obvious is it that <code>maxEven()</code>, <code>maxEven(1)</code>,
and <code>maxEven(1,13)</code> all return <code>undefined</code>? Is it quickly clear why the final
<code>if</code> statement is necessary?</p>
<p>Let's instead consider a recursive approach, to compare. We could notate the
recursion this way:</p>
<pre><code class="language-txt">maxEven( nums ):
    maxEven( nums.0, maxEven( ...nums.1 ) )
</code></pre>
<p>In other words, we can define the max-even of a list of numbers as the max-even
of the first number compared to the max-even of the rest of the numbers. For
example:</p>
<pre><code class="language-txt">maxEven( 1, 10, 3, 2 ):
    maxEven( 1, maxEven( 10, maxEven( 3, maxEven( 2 ) ) )
</code></pre>
<p>To implement this recursive definition in JS, one approach is:</p>
<pre><code class="language-js">function maxEven(num1, ...restNums) {
  var maxRest = restNums.length &gt; 0 ? maxEven(...restNums) : undefined;

  return num1 % 2 != 0 || num1 &lt; maxRest ? maxRest : num1;
}
</code></pre>
<p>So what advantages does this approach have?</p>
<p>First, the signature is a little different than before. I intentionally called
out <code>num1</code> as the first argument name, collecting the rest of the arguments into
<code>restNums</code>. But why? We could just have collected them all into a single <code>nums</code>
array and then referred to <code>nums[0]</code>.</p>
<p>This function signature is an intentional hint at the recursive definition. It
reads like this:</p>
<pre><code class="language-txt">maxEven( num1, ...restNums ):
    maxEven( num1, maxEven( ...restNums ) )
</code></pre>
<p>Do you see the symmetry between the signature and the recursive definition?</p>
<p>When we can make the recursive definition more apparent even in the function
signature, we improve the declarativeness of the function. And if we can then
mirror the recursive definition from the signature to the function body, it gets
even better.</p>
<p>But I'd say the most obvious improvement is that the distraction of the
imperative <code>for</code>-loop is suppressed. All the looping logic is abstracted into
the recursive call stack, so that stuff doesn't clutter the code. We're free
then to focus on the logic of finding a max-even by comparing two numbers at a
time -- the important part anyway!</p>
<p>Mentally, what's happening is similar to when a mathematician uses a <strong>Σ</strong>
summation in a larger equation. We're saying, &quot;the max-even of the rest of the
list is calculated by <code>maxEven(...restNums)</code>, so we'll just assume that part and
move on.&quot;</p>
<p>Additionally, we reinforce that notion with the <code>restNums.length &gt; 0</code> guard,
because if there are no more numbers to consider, the natural result is that
<code>maxRest</code> would have to be <code>undefined</code>. We don't need to devote any extra mental
attention to that part of the reasoning. This base condition (no more numbers to
consider) is clearly evident.</p>
<p>Next, we turn our attention to checking <code>num1</code> against <code>maxRest</code> -- the main
logic of the algorithm is how to determine which of two numbers, if any, is a
max-even. If <code>num1</code> is not even (<code>num1 % 2 != 0</code>), or it's less than <code>maxRest</code>,
then <code>maxRest</code> <em>has</em> to be <code>return</code>ed, even if it's <code>undefined</code>. Otherwise,
<code>num1</code> is the answer.</p>
<p>The case I'm making is that this reasoning while reading an implementation is
more straightforward, with fewer nuances or noise to distract us, than the
imperative approach; it's <strong>more declarative</strong> than the <code>for</code>-loop with
<code>-Infinity</code> version.</p>
<p><strong>Tip:</strong> We should point out that another (likely better!) way to model this
besides manual iteration or recursion would be with list operations (see
<a href="chapter_9.html">Chapter 9</a>), with a <code>filter(..)</code> to include only evens and then a
<code>reduce(..)</code> to find the max. We only used this example to illustrate the more
declarative nature of recursion over manual iteration.</p>
<h3><a class="header" href="#binary-tree-recursion" id="binary-tree-recursion">Binary Tree Recursion</a></h3>
<p>Here's another recursion example: calculating the depth of a binary tree. In
fact, almost every operation you'll do with trees is implemented most easily
with recursion, because manually tracking the stack up and down is highly
imperative and error-prone.</p>
<p>The depth of a binary tree is the longest path down (either left or right)
through the nodes of the tree. Another way to define that is recursively -- the
depth of a tree at any node is 1 (the current node) plus the greater of depths
from either its left or right child trees:</p>
<pre><code class="language-txt">depth( node ):
    1 + max( depth( node.left ), depth( node.right ) )
</code></pre>
<p>Translating that straightforwardly to a binary recursive function:</p>
<pre><code class="language-js">function depth(node) {
  if (node) {
    let depthLeft = depth(node.left);
    let depthRight = depth(node.right);
    return 1 + max(depthLeft, depthRight);
  }

  return 0;
}
</code></pre>
<p>I'm not going to list out the imperative form of this algorithm, but trust me,
it's a lot messier. This recursive approach is nicely and gracefully
declarative. It follows the recursive definition of the algorithm very closely
with very little distraction.</p>
<p>Not all problems are cleanly recursive. This is not some silver bullet that you
should try to apply everywhere. But recursion can be very effective at evolving
the expression of a problem from more imperative to more declarative.</p>
<h2><a class="header" href="#stack" id="stack">Stack</a></h2>
<p>Let's revisit the <code>isOdd(..)</code>/<code>isEven(..)</code> recursion from earlier:</p>
<pre><code class="language-js">function isOdd(v) {
  if (v === 0) return false;
  return isEven(Math.abs(v) - 1);
}

function isEven(v) {
  if (v === 0) return true;
  return isOdd(Math.abs(v) - 1);
}
</code></pre>
<p>In most browsers, if you try this you'll get an error:</p>
<pre><code class="language-js">isOdd(33333); // RangeError: Maximum call stack size exceeded
</code></pre>
<p>What's going on with this error? The engine throws this error because it's
trying to protect your program from running the system out of memory. To explain
that, we need to peek a little below the hood at what's going on in the JS
engine when function calls happen.</p>
<p>Each function call sets aside a small chunk of memory called a stack frame. The
stack frame holds certain important information about the current state of
processing statements in a function, including the values in any variables. The
reason this information needs to be stored in memory (in a stack frame) is
because the function may call out to another function, which pauses the current
function. When the other function finishes, the engine needs to resume the exact
state from when it was paused.</p>
<p>When the second function call starts, it needs a stack frame as well, bringing
the count to 2. If that function calls another, we need a third stack frame. And
so on. The word &quot;stack&quot; speaks to the notion that each time a function is called
from the previous one, the next frame is <em>stacked</em> on top. When a function call
finishes, its frame is popped off the stack.</p>
<p>Consider this program:</p>
<pre><code class="language-js">function foo() {
  var z = &quot;foo!&quot;;
}

function bar() {
  var y = &quot;bar!&quot;;
  foo();
}

function baz() {
  var x = &quot;baz!&quot;;
  bar();
}

baz();
</code></pre>
<p>Visualizing this program's stack frames step by step:</p>
<p align="center">
    <img alt="figure" src="images/fig15.png" width="80%">
</p>
<p><strong>Note:</strong> If these functions didn't call each other, but were just called
sequentially -- like <code>baz(); bar(); foo();</code>, where each one finishes before the
next one starts -- the frames won't stack up; each function call finishes and
removes its frame from the stack before the next one is added.</p>
<p>OK, so a little bit of memory is needed for each function call. No big deal
under most normal program conditions, right? But it quickly becomes a big deal
once you introduce recursion. While you'd almost certainly never manually stack
thousands (or even hundreds!) of calls of different functions together in one
call stack, you'll easily see tens of thousands or more recursive calls stack
up.</p>
<p>The <code>isOdd(..)</code>/<code>isEven(..)</code> pairing throws a <code>RangeError</code> because the engine
steps in at an arbitrary limit when it thinks the call stack has grown too much
and should be stopped. This is not likely a limit based on actual memory levels
nearing zero, but rather a prediction by the engine that if this kind of program
was left running, memory usage would be runaway. It is impossible to know or
prove that a program will eventually stop, so the engine has to make an informed
guess.</p>
<p>This limit is implementation dependent. The specification doesn't say anything
about it at all, so it's not <em>required</em>. But practically all JS engines do have
a limit, because having no limit would create an unstable device that's
susceptible to poorly written or malicious code. Each engine in each different
device environment is going to enforce its own limits, so there's no way to
predict or guarantee how far we can run up the function call stack.</p>
<p>What this limit means to us as developers is that there's a practical limitation
on the usefulness of recursion in solving problems on non-trivially sized data
sets. In fact, I think this kind of limitation might be the single biggest
reason that recursion is a second-class citizen in the developer's toolbox.
Regrettably, recursion is an afterthought rather than a primary technique.</p>
<h3><a class="header" href="#tail-calls" id="tail-calls">Tail Calls</a></h3>
<p>Recursion far predates JS, and so do these memory limitations. Back in the
1960s, developers were wanting to use recursion and running up against hard
limits of device memory of their powerful computers that were far lower than we
have on our watches today.</p>
<p>Fortunately, a powerful observation was made in those early days that still
offers hope. The technique is called <em>tail calls</em>.</p>
<p>The idea is that if a call from function <code>baz()</code> to function <code>bar()</code> happens at
the very end of function <code>baz()</code>'s execution -- referred to as a tail call --
the stack frame for <code>baz()</code> isn't needed anymore. That means that either the
memory can be reclaimed, or even better, simply reused to handle function
<code>bar()</code>'s execution. Visualizing:</p>
<p align="center">
    <img alt="figure" src="images/fig16.png" width="80%">
</p>
<p>Tail calls are not really directly related to recursion, per se; this notion
holds for any function call. But your manual non-recursion call stacks are
unlikely to go beyond maybe 10 levels deep in most cases, so the chances of tail
calls impacting your program's memory footprint are pretty low.</p>
<p>Tail calls really shine in the recursion case, because it means that a recursive
stack could run &quot;forever&quot;, and the only performance concern would be
computation, not fixed memory limitations. Tail call recursion can run in <code>O(1)</code>
fixed memory usage.</p>
<p>These sorts of techniques are often referred to as Tail Call Optimizations
(TCO), but it's important to distinguish the ability to detect a tail call to
run in fixed memory space, from the techniques that optimize this approach.
Technically, tail calls themselves are not a performance optimization as most
people would think, as they might actually run slower than normal calls. TCO is
about optimizing tail calls to run more efficiently.</p>
<h3><a class="header" href="#proper-tail-calls-ptc" id="proper-tail-calls-ptc">Proper Tail Calls (PTC)</a></h3>
<p>JavaScript has never required (nor forbidden) tail calls, until ES6. ES6
mandates recognition of tail calls, of a specific form referred to as Proper
Tail Calls (PTC), and the guarantee that code in PTC form will run without
unbounded stack memory growth. Practically speaking, this means we should not
get <code>RangeError</code>s thrown if we adhere to PTC.</p>
<p>First, PTC in JavaScript requires strict mode. You should already be using
strict mode, but if you aren't, this is yet another reason you should already be
using strict mode. Did I mention, yet, you should already be using strict mode!?</p>
<p>Second, a <em>proper</em> tail call looks like this:</p>
<pre><code class="language-js">return foo( .. );
</code></pre>
<p>In other words, the function call is the last thing to execute in the
surrounding function, and whatever value it returns is explicitly <code>return</code>ed. In
this way, JS can be absolutely guaranteed that the current stack frame won't be
needed anymore.</p>
<p>These <em>are not</em> PTC:</p>
<pre><code class="language-js">foo();
return;

// or

var x = foo( .. );
return x;

// or

return 1 + foo( .. );
</code></pre>
<p><strong>Note:</strong> A JS engine, or a smart transpiler, <em>could</em> do some code
reorganization to treat <code>var x = foo(); return x;</code> effectively the same as
<code>return foo();</code>, which would then make it eligible for PTC. But that is not
required by the specification.</p>
<p>The <code>1 +</code> part is definitely processed <em>after</em> <code>foo(..)</code> finishes, so the stack
frame has to be kept around.</p>
<p>However, this <em>is</em> PTC:</p>
<pre><code class="language-js">return x ? foo( .. ) : bar( .. );
</code></pre>
<p>After the <code>x</code> condition is computed, either <code>foo(..)</code> or <code>bar(..)</code> will run, and
in either case, the return value will always be <code>return</code>ed back. That's PTC
form.</p>
<p>Binary (or multiple) recursion -- as shown earlier, two (or more!) recursive
calls made at each level -- can never be fully PTC as-is, because all the
recursion has to be in tail call position to avoid the stack growth; at most,
only one recursive call can appear in PTC position.</p>
<p>Earlier, we showed an example of refactoring from binary recursion to mutual
recursion. It may be possible to achieve PTC from a multiple-recursive algorithm
by splitting each into separate function calls, where each is expressed
respectively in PTC form. However, that type of intricate refactoring is highly
dependent on the scenario, and beyond the scope of what we can cover in this
text.</p>
<h2><a class="header" href="#rearranging-recursion" id="rearranging-recursion">Rearranging Recursion</a></h2>
<p>If you want to use recursion but your problem set could grow enough eventually
to exceed the stack limit of the JS engine, you're going to need to rearrange
your recursive calls to take advantage of PTC (or avoid nested calls entirely).
There are several refactoring strategies that can help, but there are of course
trade-offs to be aware of.</p>
<p>As a word of caution, always keep in mind that code readability is our overall
most important goal. If recursion along with some combination of the strategies
described here results in code that is harder to read/understand, <strong>don't use
recursion</strong>; find another more readable approach.</p>
<h3><a class="header" href="#replacing-the-stack" id="replacing-the-stack">Replacing the Stack</a></h3>
<p>The main problem with recursion is its memory usage, keeping around the stack
frames to track the state of a function call while it dispatches to the next
recursive call iteration. If we can figure out how to rearrange our usage of
recursion so that the stack frame doesn't need to be kept, then we can express
recursion with PTC and take advantage of the JS engine's optimized handling of
tail calls.</p>
<p>Let's recall the summation example from earlier:</p>
<pre><code class="language-js">function sum(num1, ...nums) {
  if (nums.length == 0) return num1;
  return num1 + sum(...nums);
}
</code></pre>
<p>This isn't in PTC form because after the recursive call to <code>sum(...nums)</code> is
finished, the <code>total</code> variable is added to that result. So, the stack frame has
to be preserved to keep track of the <code>total</code> partial result while the rest of
the recursion proceeds.</p>
<p>The key recognition point for this refactoring strategy is that we could remove
our dependence on the stack by doing the addition <em>now</em> instead of <em>after</em>, and
then forward-passing that partial result as an argument to the recursive call.
In other words, instead of keeping <code>total</code> in the current function's stack
frame, push it into the stack frame of the next recursive call; that frees up
the current stack frame to be removed/reused.</p>
<p>To start, we could alter our <code>sum(..)</code> function's signature to have a new first
parameter as the partial result:</p>
<pre><code class="language-js">function sum(result, num1, ...nums) {
  // ..
}
</code></pre>
<p>Now, we should pre-calculate the addition of <code>result</code> and <code>num1</code>, and pass that
along:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function sum(result, num1, ...nums) {
  result = result + num1;
  if (nums.length == 0) return result;
  return sum(result, ...nums);
}
</code></pre>
<p>Now our <code>sum(..)</code> is in PTC form! Yay!</p>
<p>But the downside is we now have altered the signature of the function that makes
using it stranger. The caller essentially has to pass <code>0</code> as the first argument
ahead of the rest of the numbers they want to sum:</p>
<pre><code class="language-js">sum(/*initialResult=*/ 0, 3, 1, 17, 94, 8); // 123
</code></pre>
<p>That's unfortunate.</p>
<p>Typically, people will solve this by naming their awkward-signature recursive
function differently, then defining an interface function that hides the
awkwardness:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function sumRec(result, num1, ...nums) {
  result = result + num1;
  if (nums.length == 0) return result;
  return sumRec(result, ...nums);
}

function sum(...nums) {
  return sumRec(/*initialResult=*/ 0, ...nums);
}

sum(3, 1, 17, 94, 8); // 123
</code></pre>
<p>That's better. Still unfortunate that we've now created multiple functions
instead of just one. Sometimes you'll see developers &quot;hide&quot; the recursive
function as an inner function, like this:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function sum(...nums) {
  return sumRec(/*initialResult=*/ 0, ...nums);

  function sumRec(result, num1, ...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sumRec(result, ...nums);
  }
}

sum(3, 1, 17, 94, 8); // 123
</code></pre>
<p>The downside here is that we'll re-create that inner <code>sumRec(..)</code> function each
time the outer <code>sum(..)</code> is called. So, we can go back to them being
side-by-side functions, but hide them both inside an IIFE, and expose just the
one we want to:</p>
<pre><code class="language-js">&quot;use strict&quot;;

var sum = (function IIFE() {
  return function sum(...nums) {
    return sumRec(/*initialResult=*/ 0, ...nums);
  };

  function sumRec(result, num1, ...nums) {
    result = result + num1;
    if (nums.length == 0) return result;
    return sumRec(result, ...nums);
  }
})();

sum(3, 1, 17, 94, 8); // 123
</code></pre>
<p>OK, we've got PTC and we've got a nice clean signature for our <code>sum(..)</code> that
doesn't require the caller to know about our implementation details. Yay!</p>
<p>But... wow, our simple recursive function has a lot more noise now. The
readability has definitely been reduced. That's unfortunate to say the least.
Sometimes, that's just the best we can do.</p>
<p>Luckily, in some other cases, like the present one, there's a better way. Let's
reset back to this version:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function sum(result, num1, ...nums) {
  result = result + num1;
  if (nums.length == 0) return result;
  return sum(result, ...nums);
}

sum(/*initialResult=*/ 0, 3, 1, 17, 94, 8); // 123
</code></pre>
<p>What you might observe is that <code>result</code> is a number just like <code>num1</code>, which
means that we can always treat the first number in our list as our running
total; that includes even the first call. All we need is to rename those params
to make this clear:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function sum(num1, num2, ...nums) {
  num1 = num1 + num2;
  if (nums.length == 0) return num1;
  return sum(num1, ...nums);
}

sum(3, 1, 17, 94, 8); // 123
</code></pre>
<p>Awesome. That's much better, huh!? I think this pattern achieves a good balance
between declarative/reasonable and performant.</p>
<p>Let's try refactoring with PTC once more, revisiting our earlier <code>maxEven(..)</code>
(currently not PTC). We'll observe that similar to keeping the sum as the first
argument, we can narrow the list of numbers one at a time, keeping the first
argument as the highest even we've come across thus far.</p>
<p>For clarity, the algorithm strategy (similar to what we discussed earlier) we
might use:</p>
<ol>
<li>Start by comparing the first two numbers, <code>num1</code> and <code>num2</code>.</li>
<li>Is <code>num1</code> even, and is <code>num1</code> greater than <code>num2</code>? If so, keep <code>num1</code>.</li>
<li>If <code>num2</code> is even, keep it (store in <code>num1</code>).</li>
<li>Otherwise, fall back to <code>undefined</code> (store in <code>num1</code>).</li>
<li>If there are more <code>nums</code> to consider, recursively compare them to <code>num1</code>.</li>
<li>Finally, just return whatever value is left in <code>num1</code>.</li>
</ol>
<p>Our code can follow these steps almost exactly:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function maxEven(num1, num2, ...nums) {
  num1 =
    num1 % 2 == 0 &amp;&amp; !(maxEven(num2) &gt; num1)
      ? num1
      : num2 % 2 == 0
      ? num2
      : undefined;

  return nums.length == 0 ? num1 : maxEven(num1, ...nums);
}
</code></pre>
<p><strong>Note:</strong> The first <code>maxEven(..)</code> call is not in PTC position, but because it
only passes in <code>num2</code>, it only recurses just that one level then returns right
back out; this is only a trick to avoid repeating the <code>%</code> logic. As such, this
call won't increase the growth of the recursive stack, any more than if that
call was to an entirely different function. The second <code>maxEven(..)</code> call is the
legitimate recursive call, and it is in fact in PTC position, meaning our stack
won't grow as the recursion proceeds.</p>
<p>It should be repeated that this example is only to illustrate the approach to
moving recursion to the PTC form to optimize the stack (memory) usage. The more
direct way to express a max-even algorithm might indeed be a filtering of the
<code>nums</code> list for evens first, followed then by a max bubbling or even a sort.</p>
<p>Refactoring recursion into PTC is admittedly a little intrusive on the simple
declarative form, but it still gets the job done reasonably. Unfortunately, some
kinds of recursion won't work well even with an interface function, so we'll
need different strategies.</p>
<h3><a class="header" href="#continuation-passing-style-cps" id="continuation-passing-style-cps">Continuation Passing Style (CPS)</a></h3>
<p>In JavaScript, the word <em>continuation</em> is often used to mean a function callback
that specifies the next step(s) to execute after a certain function finishes its
work. Organizing code so that each function receives another function to execute
at its end is referred to as Continuation Passing Style (CPS).</p>
<p>Some forms of recursion cannot practically be refactored to pure PTC, especially
multiple recursion. Recall the <code>fib(..)</code> function earlier, and even the mutual
recursion form we derived. In both cases, there are multiple recursive calls,
which effectively defeats PTC memory optimizations.</p>
<p>However, you can perform the first recursive call, and wrap the subsequent
recursive calls in a continuation function to pass into that first call. Even
though this would mean ultimately many more functions will need to be executed
in the stack, as long all of them, continuations included, are in PTC form,
stack memory usage will not grow unbounded.</p>
<p>We could do this for <code>fib(..)</code>:</p>
<pre><code class="language-js">&quot;use strict&quot;;

function fib(n, cont = identity) {
  if (n &lt;= 1) return cont(n);
  return fib(n - 2, n2 =&gt; fib(n - 1, n1 =&gt; cont(n2 + n1)));
}
</code></pre>
<p>Pay close attention to what's happening here. First, we default the <code>cont(..)</code>
continuation function as our
<a href="chapter_3.html"><code>identity(..)</code> utility from Chapter 3</a>; remember, it
simply returns whatever is passed to it.</p>
<p>Moreover, not just one but two continuation functions are added to the mix. The
first one receives the <code>n2</code> argument, which eventually receives the computation
of the <code>fib(n-2)</code> value. The next inner continuation receives the <code>n1</code> argument,
which eventually is the <code>fib(n-1)</code> value. Once both <code>n2</code> and <code>n1</code> values are
known, they can be added together (<code>n2 + n1</code>), and that value is passed along to
the next <code>cont(..)</code> continuation step.</p>
<p>Perhaps this will help mentally sort out what's going on: just like in the
previous discussion when we passed partial results along instead of returning
them back after the recursive stack, we're doing the same here, but each step
gets wrapped in a continuation, which defers its computation. That trick allows
us to perform multiple steps where each is in PTC form.</p>
<p>In static languages, CPS is often an opportunity for tail calls the compiler can
automatically identify and rearrange recursive code to take advantage of.
Unfortunately, that doesn't really apply to the nature of JS.</p>
<p>In JavaScript, you'd likely need to write the CPS form yourself. It's clunkier,
for sure; the declarative notation-like form has certainly been obscured. But
overall, this form is still more declarative than the <code>for</code>-loop imperative
implementation.</p>
<p><strong>Warning:</strong> One major caveat that should be noted is that in CPS, creating the
extra inner continuation functions still consumes memory, but of a different
sort. Instead of piling up stack frames, the closures just consume free memory
(typically, from the heap). Engines don't seem to apply the <code>RangeError</code> limits
in these cases, but that doesn't mean your memory usage is fixed in scale.</p>
<h3><a class="header" href="#trampolines" id="trampolines">Trampolines</a></h3>
<p>Where CPS creates continuations and passes them along, another technique for
alleviating memory pressure is called trampolines. In this style of code,
CPS-like continuations are created, but instead of passed in, they are shallowly
returned.</p>
<p>Instead of functions calling functions, the stack never goes beyond depth of
one, because each function just returns the next function that should be called.
A loop simply keeps running each returned function until there are no more
functions to run.</p>
<p>One advantage with trampolines is you aren't limited to environments that
support PTC; another is that each function call is regular, not PTC optimized,
so it may run quicker.</p>
<p>Let's sketch out a <code>trampoline(..)</code> utility:</p>
<pre><code class="language-js">function trampoline(fn) {
  return function trampolined(...args) {
    var result = fn(...args);

    while (typeof result == &quot;function&quot;) {
      result = result();
    }

    return result;
  };
}
</code></pre>
<p>As long as a function is returned, the loop keeps going, executing that function
and capturing its return, then checking its type. Once a non-function comes
back, the trampoline assumes the function calling is complete, and just gives
back the value.</p>
<p>Because each continuation needs to return another continuation, we'll need to
use the earlier trick of forward-passing the partial result as an argument.
Here's how we could use this utility with our earlier example of summation of a
list of numbers:</p>
<pre><code class="language-js">var sum = trampoline(function sum(num1, num2, ...nums) {
  num1 = num1 + num2;
  if (nums.length == 0) return num1;
  return () =&gt; sum(num1, ...nums);
});

var xs = [];
for (let i = 0; i &lt; 20000; i++) {
  xs.push(i);
}

sum(...xs); // 199990000
</code></pre>
<p>The downside is that a trampoline requires you to wrap your recursive function
in the trampoline driving function; moreover, just like CPS, closures are
created for each continuation. However, unlike CPS, each continuation function
returned runs and finishes right away, so the engine won't have to accumulate a
growing amount of closure memory while the call stack depth of the problem is
exhausted.</p>
<p>Beyond execution and memory performance, the advantage of trampolines over CPS
is that they're less intrusive on the declarative recursion form, in that you
don't have to change the function signature to receive a continuation function
argument. Trampolines are not ideal, but they can be effective in your balancing
act between imperative looping code and declarative recursion.</p>
<h2><a class="header" href="#summary-7" id="summary-7">Summary</a></h2>
<p>Recursion is when a function recursively calls itself. Heh. A recursive
definition for recursion. Get it!?</p>
<p>Direct recursion is a function that makes at least one call to itself, and it
keeps dispatching to itself until it satisfies a base condition. Multiple
recursion (like binary recursion) is when a function calls itself multiple
times. Mutual recursion is when two or more functions recursively loop by
<em>mutually</em> calling each other.</p>
<p>The upside of recursion is that it's more declarative and thus typically more
readable. The downside is usually performance, but more memory constraints even
than execution speed.</p>
<p>Tail calls alleviate the memory pressure by reusing/discarding stack frames.
JavaScript requires strict mode and proper tail calls (PTC) to take advantage of
this &quot;optimization&quot;. There are several techniques we can mix-n-match to refactor
a non-PTC recursive function to PTC form, or at least avoid the memory
constraints by flattening the stack.</p>
<p>Remember: recursion should be used to make code more readable. If you misuse or
abuse recursion, the readability will end up worse than the imperative form.
Don't do that!</p>
<h1><a class="header" href="#functional-light-javascript-10" id="functional-light-javascript-10">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-9-list-operations" id="chapter-9-list-operations">Chapter 9: List Operations</a></h1>
<blockquote>
<p><em>If you can do something awesome, keep doing it repeatedly.</em></p>
</blockquote>
<p>We've already seen several brief references earlier in the text to some
utilities that we now want to take a very close look at, namely <code>map(..)</code>,
<code>filter(..)</code>, and <code>reduce(..)</code>. In JavaScript, these utilities are typically
used as methods on the array (aka, &quot;list&quot;) prototype, so we would naturally
refer to them as array or list operations.</p>
<p>Before we talk about the specific array methods, we want to examine conceptually
what these operations are used for. It's equally important in this chapter that
you understand <em>why</em> list operations are important as it is to understand <em>how</em>
list operations work. Make sure you approach this chapter with that detail in
mind.</p>
<p>The vast majority of common illustrations of these operations, both outside of
this book and here in this chapter, depict trivial tasks performed on lists of
values (like doubling each number in an array); it's a cheap and easy way to get
the point across.</p>
<p>But don't just gloss over these simple examples and miss the deeper point. Some
of the most important FP value in understanding list operations comes from being
able to model a sequence of tasks -- a series of statements that wouldn't
otherwise <em>look</em> like a list -- as a list operation instead of performing them
individually.</p>
<p>This isn't just a trick to write more terse code. What we're after is to move
from imperative to declarative style, to make the code patterns more readily
recognizable and thus more readable.</p>
<p>But there's something <strong>even more important to grasp</strong>. With imperative code,
each intermediate result in a set of calculations is stored in variable(s)
through assignment. The more of these imperative patterns your code relies on,
the harder it is to verify that there aren't mistakes -- in the logic,
accidental mutation of values, or hidden side causes/effects lurking.</p>
<p>By chaining and/or composing list operations together, the intermediate results
are tracked implicitly and largely protected from these hazards.</p>
<p><strong>Note:</strong> More than previous chapters, to keep the many following code snippets
as brief as possible, we'll rely heavily on the ES6 <code>=&gt;</code> form. However, my
<a href="chapter_2.html">advice on <code>=&gt;</code> from Chapter 2</a> still
applies for general coding.</p>
<h2><a class="header" href="#non-fp-list-processing" id="non-fp-list-processing">Non-FP List Processing</a></h2>
<p>As a quick preamble to our discussion in this chapter, I want to call out a few
operations which may seem related to JavaScript arrays and FP list operations,
but which aren't. These operations will not be covered here, because they are
not consistent with general FP best practices:</p>
<ul>
<li><code>forEach(..)</code></li>
<li><code>some(..)</code></li>
<li><code>every(..)</code></li>
</ul>
<p><code>forEach(..)</code> is an iteration helper, but it's designed for each function call
to operate with side effects; you can probably guess why that's not an endorsed
FP list operation for our discussion!</p>
<p><code>some(..)</code> and <code>every(..)</code> do encourage the use of pure functions (specifically,
predicate functions like <code>filter(..)</code> expects), but they inevitably reduce a
list to a <code>true</code>/<code>false</code> result, essentially like a search or matching. These
two utilities don't really fit the mold of how we want to model our code with
FP, so we're going to skip covering them here.</p>
<h2><a class="header" href="#map" id="map">Map</a></h2>
<p>We'll start our exploration of FP list operations with one of the most basic and
fundamental: <code>map(..)</code>.</p>
<p>A mapping is a transformation from one value to another value. For example, if
you start with the number <code>2</code> and you multiply it by <code>3</code>, you have mapped it to
<code>6</code>. It's important to note that we're not talking about mapping transformation
as implying <em>in-place</em> mutation or reassignment; instead, we're looking at how
mapping transformation projects a new value from one location to the other.</p>
<p>In other words:</p>
<pre><code class="language-js">var x = 2,
  y;

// transformation / projection
y = x * 3;

// mutation / reassignment
x = x * 3;
</code></pre>
<p>If we define a function for this multiplying by <code>3</code>, that function acts as a
mapping (transformer) function:</p>
<pre><code class="language-js">var multipleBy3 = v =&gt; v * 3;

var x = 2,
  y;

// transformation / projection
y = multiplyBy3(x);
</code></pre>
<p>We can naturally extend mapping from a single value transformation to a
collection of values. <code>map(..)</code> is an operation that transforms all the values
of a list as it projects them to a new list:</p>
<p align="center">
    <img alt="figure" src="images/fig9.png" width="50%">
</p>
<p>To implement <code>map(..)</code>:</p>
<pre><code class="language-js">function map(mapperFn, arr) {
  var newList = [];

  for (let [idx, v] of arr.entries()) {
    newList.push(mapperFn(v, idx, arr));
  }

  return newList;
}
</code></pre>
<p><strong>Note:</strong> The parameter order <code>mapperFn, arr</code> may feel backwards at first, but
this convention is much more common in FP libraries because it makes these
utilities easier to compose (with currying).</p>
<p>The <code>mapperFn(..)</code> is naturally passed the list item to map/transform, but also
an <code>idx</code> and <code>arr</code>. We're doing that to keep consistency with the built-in array
<code>map(..)</code>. These extra pieces of information can be very useful in some cases.</p>
<p>But in other cases, you may want to use a <code>mapperFn(..)</code> that only the list item
should be passed to, because the extra arguments might change its behavior. In
<a href="chapter_3.html">Chapter 3, &quot;All For One&quot;</a>, we introduced
<code>unary(..)</code>, which limits a function to only accept a single argument (no matter
how many are passed).</p>
<p>Recall <a href="chapter_3.html">the example from Chapter 3</a> about
limiting <code>parseInt(..)</code> to a single argument to be used safely as a
<code>mapperFn(..)</code>, which we can also utilize with the standalone <code>map(..)</code>:</p>
<pre><code class="language-js">map([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;], unary(parseInt));
// [1,2,3]
</code></pre>
<p><strong>Note:</strong> The JavaScript array prototype operations (<code>map(..)</code>, <code>filter(..)</code>,
and <code>reduce(..)</code>) all accept an optional last argument to use for <code>this</code> binding
of the function. As we discussed in
<a href="chapter_2.html">Chapter 2, &quot;What's This?&quot;</a>, <code>this</code>-based coding
should generally be avoided wherever possible in terms of being consistent with
the best practices of FP. As such, our example implementations in this chapter
do not support such a <code>this</code>-binding feature.</p>
<p>Beyond the obvious numeric or string operations you could perform against a list
of those respective value types, here are some other examples of mapping
operations. We can use <code>map(..)</code> to transform a list of functions into a list of
their return values:</p>
<pre><code class="language-js">var one = () =&gt; 1;
var two = () =&gt; 2;
var three = () =&gt; 3;

[one, two, three].map(fn =&gt; fn());
// [1,2,3]
</code></pre>
<p>Or we can first transform a list of functions by composing each of them with
another function, and then execute them:</p>
<pre><code class="language-js">var increment = v =&gt; ++v;
var decrement = v =&gt; --v;
var square = v =&gt; v * v;

var double = v =&gt; v * 2;

[increment, decrement, square].map(fn =&gt; compose(fn, double)).map(fn =&gt; fn(3));
// [7,5,36]
</code></pre>
<p>Something interesting to observe about <code>map(..)</code>: we typically would assume that
the list is processed left-to-right, but there's nothing about the concept of
<code>map(..)</code> that really requires that. Each transformation is supposed to be
independent of every other transformation.</p>
<p>Mapping in a general sense could even been parallelized in an environment that
supports that, which for a large list could drastically improve performance. We
don't see JavaScript actually doing that because there's nothing that requires
you to pass a pure function as <code>mapperFn(..)</code>, even though you <strong>really ought
to</strong>. If you were to pass an impure function and JS were to run different calls
in different orders, it would quickly cause havoc.</p>
<p>Even though theoretically, individual mapping operations are independent, JS has
to assume that they're not. That's a bummer.</p>
<h3><a class="header" href="#sync-vs-async" id="sync-vs-async">Sync vs. Async</a></h3>
<p>The list operations we're discussing in this chapter all operate synchronously
on a list of values that are all already present; <code>map(..)</code> as conceived here is
an eager operation. But another way of thinking about the mapper function is as
an event handler which is invoked for each new value encountered in the list.</p>
<p>Imagine something fictional like this:</p>
<pre><code class="language-js">var newArr = arr.map();

arr.addEventListener(&quot;value&quot;, multiplyBy3);
</code></pre>
<p>Now, any time a value is added to <code>arr</code>, the <code>multiplyBy3(..)</code> event handler --
mapper function -- is called with the value, and its transformation is added to
<code>newArr</code>.</p>
<p>What we're hinting at is that arrays, and the array operations we perform on
them, are the eager synchronous versions, whereas these same operations can also
be modeled on a &quot;lazy list&quot; (aka, stream) that receives its values over time.
We'll dive into this topic in <a href="chapter_10.html">Chapter 10</a>.</p>
<h3><a class="header" href="#mapping-vs-eaching" id="mapping-vs-eaching">Mapping vs. Eaching</a></h3>
<p>Some advocate using <code>map(..)</code> as a general form of <code>forEach(..)</code>-iteration,
where essentially the value received is passed through untouched, but then some
side effect can be performed:</p>
<pre><code class="language-js">[1,2,3,4,5]
.map( function mapperFn(v){
    console.log( v );           // side effect!
    return v;
} )
..
</code></pre>
<p>The reason this technique can seem useful is that the <code>map(..)</code> returns the
array so you can keep chaining more operations after it; the return value of
<code>forEach(..)</code> is <code>undefined</code>. However, I think you should avoid using <code>map(..)</code>
in this way, because it's a net confusion to use a core FP operation in a
decidedly un-FP way.</p>
<p>You've heard the old adage about using the right tool for the right job, right?
Hammer for a nail, screwdriver for a screw... This is slightly different: it's
use the right tool <em>in the right way</em>.</p>
<p>A hammer is meant to be held in your hand; if you instead hold it in your mouth
and try to hammer the nail, you're not gonna be very effective. <code>map(..)</code> is
intended to map values, not create side effects.</p>
<h3><a class="header" href="#a-word-functors" id="a-word-functors">A Word: Functors</a></h3>
<p>We've mostly tried to stay away from invented terminology in FP as much as
possible in this book. We have used official terms at times, but mostly when we
can derive some sense of meaning from them in regular everyday conversation.</p>
<p>I'm going to very briefly break that pattern and use a word that might be a
little intimidating: functor. The reason I want to talk about functors here is
because we now already understand what they do, and because that term is used
heavily throughout the rest of FP literature; indeed, functors are foundational
ideas in FP that come straight from the mathematical principles (category
theory). You being at least familiar with and not scared by this term will be
beneficial.</p>
<p>A functor is a value that has a utility for using an operator function on that
value, which preserves composition.</p>
<p>If the value in question is compound, meaning it's comprised of individual
values -- as is the case with arrays, for example! -- a functor uses the
operator function on each individual value. Moreover, the functor utility
creates a new compound value holding the results of all the individual operator
function calls.</p>
<p>This is all a fancy way of describing what we just looked at with <code>map(..)</code>. The
<code>map(..)</code> function takes its associated value (an array) and a mapping function
(the operator function), and executes the mapping function for each individual
value in the array. Finally, it returns a new array with all the newly mapped
values in it.</p>
<p>Another example: a string functor would be a string plus a utility that executes
some operator function across all the characters in the string, returning a new
string with the processed letters. Consider this highly contrived example:</p>
<pre><code class="language-js">function uppercaseLetter(c) {
  var code = c.charCodeAt(0);

  // lowercase letter?
  if (code &gt;= 97 &amp;&amp; code &lt;= 122) {
    // uppercase it!
    code = code - 32;
  }

  return String.fromCharCode(code);
}

function stringMap(mapperFn, str) {
  return [...str].map(mapperFn).join(&quot;&quot;);
}

stringMap(uppercaseLetter, &quot;Hello World!&quot;);
// HELLO WORLD!
</code></pre>
<p><code>stringMap(..)</code> allows a string to be a functor. You can define a mapping
function for any data structure; as long as the utility follows these rules, the
data structure is a functor.</p>
<h2><a class="header" href="#filter" id="filter">Filter</a></h2>
<p>Imagine I bring an empty basket with me to the grocery store to visit the fruit
section; there's a big display of fruit (apples, oranges, and bananas). I'm
really hungry so I want to get as much fruit as they have available, but I
really only prefer the round fruits (apples and oranges). So I sift through each
fruit one by one, and I walk away with a basket full of just the apples and
oranges.</p>
<p>Let's say we call this process <em>filtering</em>. Would you more naturally describe my
shopping as starting with an empty basket and <strong>filtering in</strong> (selecting,
including) only the apples and oranges, or starting with the full display of
fruits and <strong>filtering out</strong> (skipping, excluding) the bananas as my basket is
filled with fruit?</p>
<p>If you cook spaghetti in a pot of water, and then pour it into a strainer (aka
filter) over the sink, are you filtering in the spaghetti or filtering out the
water? If you put coffee grounds into a filter and make a cup of coffee, did you
filter in the coffee into your cup, or filter out the coffee grounds?</p>
<p>Does your view of filtering depend on whether the stuff you want is &quot;kept&quot; in
the filter or passes through the filter?</p>
<p>What about on airline/hotel websites, when you specify options to &quot;filter your
results&quot;? Are you filtering in the results that match your criteria, or are you
filtering out everything that doesn't match? Think carefully: this example might
have a different semantic than the previous ones.</p>
<h3><a class="header" href="#filtering-confusion" id="filtering-confusion">Filtering Confusion</a></h3>
<p>Depending on your perspective, filtering is either exclusionary or inclusionary.
This conceptual conflation is unfortunate.</p>
<p>I think the most common interpretation of filtering -- outside of programming,
anyway -- is that you filter out unwanted stuff. Unfortunately, in programming,
we have essentially flipped this semantic to be more like filtering in wanted
stuff.</p>
<p>The <code>filter(..)</code> list operation takes a function to decide if each value in the
original array should be in the new array or not. This function needs to return
<code>true</code> if a value should make it, and <code>false</code> if it should be skipped. A
function that returns <code>true</code>/<code>false</code> for this kind of decision making goes by
the special name: predicate function.</p>
<p>If you think of <code>true</code> as indicating a positive signal, the definition of
<code>filter(..)</code> is that you are saying &quot;keep&quot; (to filter in) a value rather than
saying &quot;discard&quot; (to filter out) a value.</p>
<p>To use <code>filter(..)</code> as an exclusionary action, you have to twist your brain to
think of positively signaling an exclusion by returning <code>false</code>, and passively
letting a value pass through by returning <code>true</code>.</p>
<p>The reason this semantic mismatch matters is because of how you will likely name
the function used as <code>predicateFn(..)</code>, and what that means for the readability
of code. We'll come back to this point shortly.</p>
<p>Here's how to visualize a <code>filter(..)</code> operation across a list of values:</p>
<p align="center">
    <img alt="figure" src="images/fig10.png" width="50%">
</p>
<p>To implement <code>filter(..)</code>:</p>
<pre><code class="language-js">function filter(predicateFn, arr) {
  var newList = [];

  for (let [idx, v] of arr.entries()) {
    if (predicateFn(v, idx, arr)) {
      newList.push(v);
    }
  }

  return newList;
}
</code></pre>
<p>Notice that just like <code>mapperFn(..)</code> before, <code>predicateFn(..)</code> is passed not
only the value but also the <code>idx</code> and <code>arr</code>. Use <code>unary(..)</code> to limit its
arguments as necessary.</p>
<p>Just as with <code>map(..)</code>, <code>filter(..)</code> is provided as a built-in utility on JS
arrays.</p>
<p>Let's consider a predicate function like this:</p>
<pre><code class="language-js">var whatToCallIt = v =&gt; v % 2 == 1;
</code></pre>
<p>This function uses <code>v % 2 == 1</code> to return <code>true</code> or <code>false</code>. The effect here is
that an odd number will return <code>true</code>, and an even number will return <code>false</code>.
So, what should we call this function? A natural name might be:</p>
<pre><code class="language-js">var isOdd = v =&gt; v % 2 == 1;
</code></pre>
<p>Consider how you might use <code>isOdd(..)</code> with a simple value check somewhere in
your code:</p>
<pre><code class="language-js">var midIdx;

if (isOdd(list.length)) {
  midIdx = (list.length + 1) / 2;
} else {
  midIdx = list.length / 2;
}
</code></pre>
<p>Makes sense, right? But, let's consider using it with the built-in array
<code>filter(..)</code> to filter a list of values:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].filter(isOdd);
// [1,3,5]
</code></pre>
<p>If you described the <code>[1,3,5]</code> result, would you say, &quot;I filtered out the even
numbers&quot;, or would you say &quot;I filtered in the odd numbers&quot;? I think the former
is a more natural way of describing it. But the code reads the opposite. The
code reads, almost literally, that we &quot;filtered (in) each number that is odd&quot;.</p>
<p>I personally find this semantic confusing. There's no question there's plenty of
precedent for experienced developers. But if you just start with a fresh slate,
this expression of the logic seems kinda like not speaking without a double
negative -- aka, speaking with a double negative.</p>
<p>We could make this easier by renaming <code>isOdd(..)</code> to <code>isEven(..)</code>:</p>
<pre><code class="language-js">var isEven = v =&gt; v % 2 == 1;

[1, 2, 3, 4, 5].filter(isEven);
// [1,3,5]
</code></pre>
<p>Yay! But that function makes no sense with its name, in that it returns <code>false</code>
when it's even:</p>
<pre><code class="language-js">isEven(2); // false
</code></pre>
<p>Yuck.</p>
<p>Recall that in <a href="chapter_3.html">Chapter 3, &quot;No Points&quot;</a>, we defined a
<code>not(..)</code> operator that negates a predicate function. Consider:</p>
<pre><code class="language-js">var isEven = not(isOdd);

isEven(2); // true
</code></pre>
<p>But we can't use <em>this</em> <code>isEven(..)</code> with <code>filter(..)</code> the way it's currently
defined, because our logic will be reversed; we'll end up with evens, not odds.
We'd need to do:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5].filter(not(isEven));
// [1,3,5]
</code></pre>
<p>That defeats the whole purpose, though, so let's not do that. We're just going
in circles.</p>
<h3><a class="header" href="#filtering-out--filtering-in" id="filtering-out--filtering-in">Filtering-Out &amp; Filtering-In</a></h3>
<p>To clear up all this confusion, let's define a <code>filterOut(..)</code> that actually
<strong>filters out</strong> values by internally negating the predicate check. While we're
at it, we'll alias <code>filterIn(..)</code> to the existing <code>filter(..)</code>:</p>
<pre><code class="language-js">var filterIn = filter;

function filterOut(predicateFn, arr) {
  return filterIn(not(predicateFn), arr);
}
</code></pre>
<p>Now we can use whichever filtering makes most sense at any point in our code:</p>
<pre><code class="language-js">isOdd(3); // true
isEven(2); // true

filterIn(isOdd, [1, 2, 3, 4, 5]); // [1,3,5]
filterOut(isEven, [1, 2, 3, 4, 5]); // [1,3,5]
</code></pre>
<p>I think using <code>filterIn(..)</code> and <code>filterOut(..)</code> (known as <code>reject(..)</code> in
Ramda) will make your code a lot more readable than just using <code>filter(..)</code> and
leaving the semantics conflated and confusing for the reader.</p>
<h2><a class="header" href="#reduce" id="reduce">Reduce</a></h2>
<p>While <code>map(..)</code> and <code>filter(..)</code> produce new lists, typically this third
operator (<code>reduce(..)</code>) combines (aka &quot;reduces&quot;) the values of a list down to a
single finite (non-list) value, like a number or string. However, later in this
chapter, we'll look at how you can push <code>reduce(..)</code> to use it in more advanced
ways. <code>reduce(..)</code> is one of the most important FP tools; it's like a Swiss Army
all-in-one knife with all its usefulness.</p>
<p>A combination/reduction is abstractly defined as taking two values and making
them into one value. Some FP contexts refer to this as &quot;folding&quot;, as if you're
folding two values together into one value. That's a helpful visualization, I
think.</p>
<p>Just like with mapping and filtering, the manner of the combination is entirely
up to you, and generally dependent on the types of values in the list. For
example, numbers will typically be combined through arithmetic, strings through
concatenation, and functions through composition.</p>
<p>Sometimes a reduction will specify an <code>initialValue</code> and start its work by
combining it with the first value in the list, cascading down through each of
the rest of the values in the list. That looks like this:</p>
<p align="center">
    <img alt="figure" src="images/fig11.png" width="50%">
</p>
<p>Alternatively, you can omit the <code>initialValue</code> in which case the first value of
the list will act in place of the <code>initialValue</code> and the combining will start
with the second value in the list, like this:</p>
<p align="center">
    <img alt="figure" src="images/fig12.png" width="50%">
</p>
<p><strong>Warning:</strong> In JavaScript, if there's not at least one value in the reduction
(either in the array or specified as <code>initialValue</code>), an error is thrown. Be
careful not to omit the <code>initialValue</code> if the list for the reduction could
possibly be empty under any circumstance.</p>
<p>The function you pass to <code>reduce(..)</code> to perform the reduction is typically
called a reducer. A reducer has a different signature from the mapper and
predicate functions we looked at earlier. Reducers primarily receive the current
reduction result as well as the next value to reduce it with. The current result
at each step of the reduction is often referred to as the accumulator.</p>
<p>For example, consider the steps involved in multiply-reducing the numbers <code>5</code>,
<code>10</code>, and <code>15</code>, with an <code>initialValue</code> of <code>3</code>:</p>
<ol>
<li><code>3</code> * <code>5</code> = <code>15</code></li>
<li><code>15</code> * <code>10</code> = <code>150</code></li>
<li><code>150</code> * <code>15</code> = <code>2250</code></li>
</ol>
<p>Expressed in JavaScript using the built-in <code>reduce(..)</code> method on arrays:</p>
<pre><code class="language-js">[5, 10, 15].reduce((product, v) =&gt; product * v, 3);
// 2250
</code></pre>
<p>But a standalone implementation of <code>reduce(..)</code> might look like this:</p>
<pre><code class="language-js">function reduce(reducerFn, initialValue, arr) {
  var acc, startIdx;

  if (arguments.length == 3) {
    acc = initialValue;
    startIdx = 0;
  } else if (arr.length &gt; 0) {
    acc = arr[0];
    startIdx = 1;
  } else {
    throw new Error(&quot;Must provide at least one value.&quot;);
  }

  for (let idx = startIdx; idx &lt; arr.length; idx++) {
    acc = reducerFn(acc, arr[idx], idx, arr);
  }

  return acc;
}
</code></pre>
<p>Just as with <code>map(..)</code> and <code>filter(..)</code>, the reducer function is also passed the
lesser-common <code>idx</code> and <code>arr</code> arguments in case that's useful to the reduction.
I would say I don't typically use these, but I guess it's nice to have them
available.</p>
<p>Recall in
<a href="chapter_4.html">Chapter 4, we discussed the <code>compose(..)</code> utility</a>
and showed an implementation with <code>reduce(..)</code>:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    return [...fns].reverse().reduce(function reducer(result, fn) {
      return fn(result);
    }, result);
  };
}
</code></pre>
<p>To illustrate <code>reduce(..)</code>-based composition differently, consider a reducer
that will compose functions left-to-right (like <code>pipe(..)</code> does), to use in an
array chain:</p>
<pre><code class="language-js">var pipeReducer = (composedFn, fn) =&gt; pipe(composedFn, fn);

var fn = [3, 17, 6, 4].map(v =&gt; n =&gt; v * n).reduce(pipeReducer);

fn(9); // 11016  (9 * 3 * 17 * 6 * 4)
fn(10); // 12240  (10 * 3 * 17 * 6 * 4)
</code></pre>
<p><code>pipeReducer(..)</code> is unfortunately not point-free (see
<a href="chapter_3.html">Chapter 3, &quot;No Points&quot;</a>), but we can't just pass
<code>pipe(..)</code> as the reducer itself, because it's variadic; the extra arguments
(<code>idx</code> and <code>arr</code>) that <code>reduce(..)</code> passes to its reducer function would be
problematic.</p>
<p>Earlier we talked about using <code>unary(..)</code> to limit a <code>mapperFn(..)</code> or
<code>predicateFn(..)</code> to just a single argument. It might be handy to have a
<code>binary(..)</code> that does something similar but limits to two arguments, for a
<code>reducerFn(..)</code> function:</p>
<pre><code class="language-js">var binary = fn =&gt; (arg1, arg2) =&gt; fn(arg1, arg2);
</code></pre>
<p>Using <code>binary(..)</code>, our previous example is a little cleaner:</p>
<pre><code class="language-js">var pipeReducer = binary(pipe);

var fn = [3, 17, 6, 4].map(v =&gt; n =&gt; v * n).reduce(pipeReducer);

fn(9); // 11016  (9 * 3 * 17 * 6 * 4)
fn(10); // 12240  (10 * 3 * 17 * 6 * 4)
</code></pre>
<p>Unlike <code>map(..)</code> and <code>filter(..)</code> whose order of passing through the array
wouldn't actually matter, <code>reduce(..)</code> definitely uses left-to-right processing.
If you want to reduce right-to-left, JavaScript provides a <code>reduceRight(..)</code>,
with all other behaviors the same as <code>reduce(..)</code>:</p>
<pre><code class="language-js">var hyphenate = (str, char) =&gt; `${str}-${char}`;

[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].reduce(hyphenate);
// &quot;a-b-c&quot;

[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].reduceRight(hyphenate);
// &quot;c-b-a&quot;
</code></pre>
<p><a name="composereduceright"></a></p>
<p>Where <code>reduce(..)</code> works left-to-right and thus acts naturally like <code>pipe(..)</code>
in composing functions, <code>reduceRight(..)</code>'s right-to-left ordering is natural
for performing a <code>compose(..)</code>-like operation. So, let's revisit
<a href="chapter_4.html"><code>compose(..)</code> from Chapter 4</a>, but
implement it using <code>reduceRight(..)</code>:</p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    return fns.reduceRight(function reducer(result, fn) {
      return fn(result);
    }, result);
  };
}
</code></pre>
<p>Now, we don't need to do <code>[...fns].reverse()</code>; we just reduce from the other
direction!</p>
<h3><a class="header" href="#map-as-reduce" id="map-as-reduce">Map as Reduce</a></h3>
<p>The <code>map(..)</code> operation is iterative in its nature, so it can also be
represented as a reduction (<code>reduce(..)</code>). The trick is to realize that the
<code>initialValue</code> of <code>reduce(..)</code> can be itself an (empty) array, in which case the
result of a reduction can be another list!</p>
<pre><code class="language-js">var double = v =&gt; v * 2;

[1, 2, 3, 4, 5].map(double);
// [2,4,6,8,10]

[1, 2, 3, 4, 5].reduce((list, v) =&gt; (list.push(double(v)), list), []);
// [2,4,6,8,10]
</code></pre>
<p><a name="reducecheating"></a></p>
<p><strong>Note:</strong> We're cheating with this reducer: using a side effect by allowing
<code>list.push(..)</code> to mutate the list that was passed in. In general, that's not a
good idea, obviously, but since we know the <code>[]</code> list is being created and
passed in, it's less dangerous. You could be more formal -- yet less performant!
-- by creating a new list with the val <code>concat(..)</code>d onto the end. We'll come
back to <a href="apA.html">this cheat in Appendix A</a>.</p>
<p>Implementing <code>map(..)</code> with <code>reduce(..)</code> is not on its surface an obvious step
or even an improvement. However, this ability will be a crucial recognition for
more advanced techniques like those we'll cover in <a href="apA.html">Appendix A</a>.</p>
<h3><a class="header" href="#filter-as-reduce" id="filter-as-reduce">Filter as Reduce</a></h3>
<p>Just as <code>map(..)</code> can be done with <code>reduce(..)</code>, so can <code>filter(..)</code>:</p>
<pre><code class="language-js">var isOdd = v =&gt; v % 2 == 1;

[1, 2, 3, 4, 5].filter(isOdd);
// [1,3,5]

[1, 2, 3, 4, 5].reduce(
  (list, v) =&gt; (isOdd(v) ? list.push(v) : undefined, list),
  []
);
// [1,3,5]
</code></pre>
<p><strong>Note:</strong> More impure reducer cheating here. Instead of <code>list.push(..)</code>, we
could have done <code>list.concat(..)</code> and returned the new list. We'll come back to
this <a href="apA.html">cheat in Appendix A</a>.</p>
<h2><a class="header" href="#advanced-list-operations" id="advanced-list-operations">Advanced List Operations</a></h2>
<p>Now that we feel somewhat comfortable with the foundational list operations
<code>map(..)</code>, <code>filter(..)</code>, and <code>reduce(..)</code>, let's look at a few
more-sophisticated operations you may find useful in various situations. These
are generally utilities you'll find in various FP libraries.</p>
<h3><a class="header" href="#unique" id="unique">Unique</a></h3>
<p>Filtering a list to include only unique values, based on <code>indexOf(..)</code> searching
(which uses <code>===</code> strict equality comparison):</p>
<pre><code class="language-js">var unique = arr =&gt; arr.filter((v, idx) =&gt; arr.indexOf(v) == idx);
</code></pre>
<p>This technique works by observing that we should only include the first
occurrence of an item from <code>arr</code> into the new list; when running left-to-right,
this will only be true if its <code>idx</code> position is the same as the <code>indexOf(..)</code>
found position.</p>
<p>Another way to implement <code>unique(..)</code> is to run through <code>arr</code> and include an
item into a new (initially empty) list if that item cannot already be found in
the new list. For that processing, we use <code>reduce(..)</code>:</p>
<pre><code class="language-js">var unique = arr =&gt;
  arr.reduce(
    (list, v) =&gt; (list.indexOf(v) == -1 ? (list.push(v), list) : list),
    []
  );
</code></pre>
<p><strong>Note:</strong> There are many other ways to implement this algorithm using more
imperative approaches like loops, and many of them are likely &quot;more efficient&quot;
performance-wise. However, the advantage of either of these presented approaches
is that they use existing built-in list operations, which makes them easier to
chain/compose alongside other list operations. We'll talk more about those
concerns later in this chapter.</p>
<p><code>unique(..)</code> nicely produces a new list with no duplicates:</p>
<pre><code class="language-js">unique([1, 4, 7, 1, 3, 1, 7, 9, 2, 6, 4, 0, 5, 3]);
// [1, 4, 7, 3, 9, 2, 6, 0, 5]
</code></pre>
<h3><a class="header" href="#flatten" id="flatten">Flatten</a></h3>
<p>From time to time, you may have (or produce through some other operations) an
array that's not just a flat list of values -- for instance, it might include
nested arrays, as shown here:</p>
<pre><code class="language-js">[[1, 2, 3], 4, 5, [6, [7, 8]]];
</code></pre>
<p>What if you'd like to transform it as follows?</p>
<pre><code class="language-js">[1, 2, 3, 4, 5, 6, 7, 8];
</code></pre>
<p>The operation we're looking for is typically called <code>flatten(..)</code>, and it could
be implemented like this using our Swiss Army knife <code>reduce(..)</code>:</p>
<pre><code class="language-js">var flatten = arr =&gt;
  arr.reduce((list, v) =&gt; list.concat(Array.isArray(v) ? flatten(v) : v), []);
</code></pre>
<p><strong>Note:</strong> This implementation choice relies on recursion as we saw in
<a href="chapter_8.html">Chapter 8</a>.</p>
<p>To use <code>flatten(..)</code> with an array of arrays (of any nested depth):</p>
<pre><code class="language-js">flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]]);
// [0,1,2,3,4,5,6,7,8,9,10,11,12,13]
</code></pre>
<p>You might like to limit the recursive flattening to a certain depth. We can
handle this by adding an optional <code>depth</code> limit argument to the implementation:</p>
<pre><code class="language-js">var flatten = (arr, depth = Infinity) =&gt;
  arr.reduce(
    (list, v) =&gt;
      list.concat(
        depth &gt; 0
          ? depth &gt; 1 &amp;&amp; Array.isArray(v)
            ? flatten(v, depth - 1)
            : v
          : [v]
      ),
    []
  );
</code></pre>
<p>Illustrating the results with different flattening depths:</p>
<pre><code class="language-js">flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 0);
// [[0,1],2,3,[4,[5,6,7],[8,[9,[10,[11,12],13]]]]]

flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 1);
// [0,1,2,3,4,[5,6,7],[8,[9,[10,[11,12],13]]]]

flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 2);
// [0,1,2,3,4,5,6,7,8,[9,[10,[11,12],13]]]

flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 3);
// [0,1,2,3,4,5,6,7,8,9,[10,[11,12],13]]

flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 4);
// [0,1,2,3,4,5,6,7,8,9,10,[11,12],13]

flatten([[0, 1], 2, 3, [4, [5, 6, 7], [8, [9, [10, [11, 12], 13]]]]], 5);
// [0,1,2,3,4,5,6,7,8,9,10,11,12,13]
</code></pre>
<h4><a class="header" href="#mapping-then-flattening" id="mapping-then-flattening">Mapping, Then Flattening</a></h4>
<p>One of the most common usages of <code>flatten(..)</code> behavior is when you've mapped a
list of elements where each transformed value from the original list is now
itself a list of values. For example:</p>
<pre><code class="language-js">var firstNames = [
  { name: &quot;Jonathan&quot;, variations: [&quot;John&quot;, &quot;Jon&quot;, &quot;Jonny&quot;] },
  { name: &quot;Stephanie&quot;, variations: [&quot;Steph&quot;, &quot;Stephy&quot;] },
  { name: &quot;Frederick&quot;, variations: [&quot;Fred&quot;, &quot;Freddy&quot;] }
];

firstNames.map(entry =&gt; [entry.name, ...entry.variations]);
// [ [&quot;Jonathan&quot;,&quot;John&quot;,&quot;Jon&quot;,&quot;Jonny&quot;], [&quot;Stephanie&quot;,&quot;Steph&quot;,&quot;Stephy&quot;],
//   [&quot;Frederick&quot;,&quot;Fred&quot;,&quot;Freddy&quot;] ]
</code></pre>
<p>The return value is an array of arrays, which might be more awkward to work
with. If we want a single dimension list with all the names, we can then
<code>flatten(..)</code> that result:</p>
<pre><code class="language-js">flatten(firstNames.map(entry =&gt; [entry.name, ...entry.variations]));
// [&quot;Jonathan&quot;,&quot;John&quot;,&quot;Jon&quot;,&quot;Jonny&quot;,&quot;Stephanie&quot;,&quot;Steph&quot;,&quot;Stephy&quot;,
//  &quot;Frederick&quot;,&quot;Fred&quot;,&quot;Freddy&quot;]
</code></pre>
<p>Besides being slightly more verbose, the disadvantage of doing the <code>map(..)</code> and
<code>flatten(..)</code> as separate steps is primarily around performance; this approach
processes the list twice, and creates an intermediate list that's then thrown
away.</p>
<p>FP libraries typically define a <code>flatMap(..)</code> (often also called <code>chain(..)</code>)
that does the mapping-then-flattening combined. For consistency and ease of
composition (via currying), the <code>flatMap(..)</code> (aka <code>chain(..)</code>) utility
typically matches the <code>mapperFn, arr</code> parameter order that we saw earlier with
the standalone <code>map(..)</code>, <code>filter(..)</code>, and <code>reduce(..)</code> utilities:</p>
<pre><code class="language-js">flatMap(entry =&gt; [entry.name, ...entry.variations], firstNames);
// [&quot;Jonathan&quot;,&quot;John&quot;,&quot;Jon&quot;,&quot;Jonny&quot;,&quot;Stephanie&quot;,&quot;Steph&quot;,&quot;Stephy&quot;,
//  &quot;Frederick&quot;,&quot;Fred&quot;,&quot;Freddy&quot;]
</code></pre>
<p>The naive implementation of <code>flatMap(..)</code> with both steps done separately:</p>
<p><a name="flatmap"></a></p>
<pre><code class="language-js">var flatMap = (mapperFn, arr) =&gt; flatten(arr.map(mapperFn), 1);
</code></pre>
<p><strong>Note:</strong> We use <code>1</code> for the flattening-depth because the typical definition of
<code>flatMap(..)</code> is that the flattening is shallow on just the first level.</p>
<p>Since this approach still processes the list twice resulting in worse
performance, we can combine the operations manually, using <code>reduce(..)</code>:</p>
<pre><code class="language-js">var flatMap = (mapperFn, arr) =&gt;
  arr.reduce(
    (list, v) =&gt;
      // note: concat(..) used here since it automatically
      // flattens an array into the concatenation
      list.concat(mapperFn(v)),
    []
  );
</code></pre>
<p>While there's some convenience and performance gained with a <code>flatMap(..)</code>
utility, there may very well be times when you need other operations like
<code>filter(..)</code>ing mixed in. If that's the case, doing the <code>map(..)</code> and
<code>flatten(..)</code> separately might still be more appropriate.</p>
<h3><a class="header" href="#zip" id="zip">Zip</a></h3>
<p>So far, the list operations we've examined have operated on a single list. But
some cases will need to process multiple lists. One well-known operation
alternates selection of values from each of two input lists into sub-lists,
called <code>zip(..)</code>:</p>
<pre><code class="language-js">zip([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]);
// [ [1,2], [3,4], [5,6], [7,8], [9,10] ]
</code></pre>
<p>Values <code>1</code> and <code>2</code> were selected into the sub-list <code>[1,2]</code>, then <code>3</code> and <code>4</code>
into <code>[3,4]</code>, and so on. The definition of <code>zip(..)</code> requires a value from each
of the two lists. If the two lists are of different lengths, the selection of
values will continue until the shorter list has been exhausted, with the extra
values in the other list ignored.</p>
<p>An implementation of <code>zip(..)</code>:</p>
<pre><code class="language-js">function zip(arr1, arr2) {
  var zipped = [];
  arr1 = [...arr1];
  arr2 = [...arr2];

  while (arr1.length &gt; 0 &amp;&amp; arr2.length &gt; 0) {
    zipped.push([arr1.shift(), arr2.shift()]);
  }

  return zipped;
}
</code></pre>
<p>The <code>[...arr1]</code> and <code>[...arr2]</code> copies ensure <code>zip(..)</code> is pure by not causing
side effects on the received array references.</p>
<p><strong>Note:</strong> There are some decidedly un-FP things going on in this implementation.
There's an imperative <code>while</code>-loop and mutations of lists with both <code>shift()</code>
and <code>push(..)</code>. Earlier in the book, I asserted that it's reasonable for pure
functions to use impure behavior inside them (usually for performance), as long
as the effects are fully self-contained. This implementation is safely pure.</p>
<h3><a class="header" href="#merge" id="merge">Merge</a></h3>
<p>Merging two lists by interleaving values from each source looks like this:</p>
<pre><code class="language-js">mergeLists([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]);
// [1,2,3,4,5,6,7,8,9,10]
</code></pre>
<p>It may not be obvious, but this result seems similar to what we get if we
compose <code>flatten(..)</code> and <code>zip(..)</code>:</p>
<pre><code class="language-js">zip([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]);
// [ [1,2], [3,4], [5,6], [7,8], [9,10] ]

flatten([
  [1, 2],
  [3, 4],
  [5, 6],
  [7, 8],
  [9, 10]
]);
// [1,2,3,4,5,6,7,8,9,10]

// composed:
flatten(zip([1, 3, 5, 7, 9], [2, 4, 6, 8, 10]));
// [1,2,3,4,5,6,7,8,9,10]
</code></pre>
<p>However, recall that <code>zip(..)</code> only selects values until the shorter of two
lists is exhausted, ignoring the leftover values; merging two lists would most
naturally retain those extra values. Also, <code>flatten(..)</code> works recursively on
nested lists, but you might expect list-merging to only work shallowly, keeping
nested lists.</p>
<p>So, let's define a <code>mergeLists(..)</code> that works more like we'd expect:</p>
<pre><code class="language-js">function mergeLists(arr1, arr2) {
  var merged = [];
  arr1 = [...arr1];
  arr2 = [...arr2];

  while (arr1.length &gt; 0 || arr2.length &gt; 0) {
    if (arr1.length &gt; 0) {
      merged.push(arr1.shift());
    }
    if (arr2.length &gt; 0) {
      merged.push(arr2.shift());
    }
  }

  return merged;
}
</code></pre>
<p><strong>Note:</strong> Various FP libraries don't define a <code>mergeLists(..)</code> but instead
define a <code>merge(..)</code> that merges properties of two objects; the results of such
a <code>merge(..)</code> will differ from our <code>mergeLists(..)</code>.</p>
<p>Alternatively, here are a couple of options to implement the list merging as a
reducer:</p>
<pre><code class="language-js">// via @rwaldron
var mergeReducer = (merged, v, idx) =&gt; (merged.splice(idx * 2, 0, v), merged);

// via @WebReflection
var mergeReducer = (merged, v, idx) =&gt;
  merged.slice(0, idx * 2).concat(v, merged.slice(idx * 2));
</code></pre>
<p>And using a <code>mergeReducer(..)</code>:</p>
<pre><code class="language-js">[1, 3, 5, 7, 9].reduce(mergeReducer, [2, 4, 6, 8, 10]);
// [1,2,3,4,5,6,7,8,9,10]
</code></pre>
<p><strong>Tip:</strong> We'll use the <code>mergeReducer(..)</code> trick later in the chapter.</p>
<h2><a class="header" href="#method-vs-standalone" id="method-vs-standalone">Method vs. Standalone</a></h2>
<p>A common source of frustration for FPers in JavaScript is unifying their
strategy for working with utilities when some of them are provided as standalone
functions (think about the various FP utilities we've derived in previous
chapters) and others are methods of the array prototype (like the ones we've
seen in this chapter).</p>
<p>The pain of this problem becomes more evident when you consider combining
multiple operations:</p>
<pre><code class="language-js">[1, 2, 3, 4, 5]
  .filter(isOdd)
  .map(double)
  .reduce(sum, 0); // 18

// vs.

reduce(map(filter([1, 2, 3, 4, 5], isOdd), double), sum, 0); // 18
</code></pre>
<p>Both API styles accomplish the same task, but they have very different
ergonomics. Many FPers will prefer the latter to the former, but the former is
unquestionably more common in JavaScript. One thing specifically that's disliked
about the latter is the nesting of the calls. The preference for the method
chain style -- typically called a fluent API style, as in jQuery and other tools
-- is that it's compact/concise and it reads in declarative top-down order.</p>
<p>The visual order for that manual composition of the standalone style is neither
strictly left-to-right (top-to-bottom) nor right-to-left (bottom-to-top); it's
inner-to-outer, which harms the readability.</p>
<p>Automatic composition normalizes the reading order as right-to-left
(bottom-to-top) for both styles. So, to explore the implications of the style
differences, let's examine composition specifically; it seems like it should be
straightforward, but it's a little awkward in both cases.</p>
<h3><a class="header" href="#composing-method-chains" id="composing-method-chains">Composing Method Chains</a></h3>
<p>The array methods receive the implicit <code>this</code> argument, so despite their
appearance, they can't be treated as unary; that makes composition more awkward.
To cope, we'll first need a <code>this</code>-aware version of <code>partial(..)</code>:</p>
<pre><code class="language-js">var partialThis = (fn, ...presetArgs) =&gt;
  // intentionally `function` to allow `this`-binding
  function partiallyApplied(...laterArgs) {
    return fn.apply(this, [...presetArgs, ...laterArgs]);
  };
</code></pre>
<p>We'll also need a version of <code>compose(..)</code> that calls each of the partially
applied methods in the context of the chain -- the input value it's being
&quot;passed&quot; (via implicit <code>this</code>) from the previous step:</p>
<pre><code class="language-js">var composeChainedMethods = (...fns) =&gt; result =&gt;
  fns.reduceRight((result, fn) =&gt; fn.call(result), result);
</code></pre>
<p>And using these two <code>this</code>-aware utilities together:</p>
<pre><code class="language-js">composeChainedMethods(
  partialThis(Array.prototype.reduce, sum, 0),
  partialThis(Array.prototype.map, double),
  partialThis(Array.prototype.filter, isOdd)
)([1, 2, 3, 4, 5]); // 18
</code></pre>
<p><strong>Note:</strong> The three <code>Array.prototype.XXX</code>-style references are grabbing
references to the built-in <code>Array.prototype.*</code> methods so that we can reuse them
with our own arrays.</p>
<h3><a class="header" href="#composing-standalone-utilities" id="composing-standalone-utilities">Composing Standalone Utilities</a></h3>
<p>Standalone <code>compose(..)</code>-style composition of these utilities doesn't need all
the <code>this</code> contortions, which is its most favorable argument. For example, we
could define standalones as:</p>
<pre><code class="language-js">var filter = (arr, predicateFn) =&gt; arr.filter(predicateFn);

var map = (arr, mapperFn) =&gt; arr.map(mapperFn);

var reduce = (arr, reducerFn, initialValue) =&gt;
  arr.reduce(reducerFn, initialValue);
</code></pre>
<p>But this particular standalone approach, with the <code>arr</code> as the first parameter,
suffers from its own awkwardness; the cascading array context is the first
argument rather than the last, so we have to use right-partial application to
compose them:</p>
<pre><code class="language-js">compose(
  partialRight(reduce, sum, 0),
  partialRight(map, double),
  partialRight(filter, isOdd)
)([1, 2, 3, 4, 5]); // 18
</code></pre>
<p>That's why FP libraries typically define <code>filter(..)</code>, <code>map(..)</code>, and
<code>reduce(..)</code> to instead receive the array last, not first. They also typically
automatically curry the utilities:</p>
<pre><code class="language-js">var filter = curry((predicateFn, arr) =&gt; arr.filter(predicateFn));

var map = curry((mapperFn, arr) =&gt; arr.map(mapperFn));

var reduce = curry((reducerFn, initialValue, arr) =&gt;
  arr.reduce(reducerFn, initialValue)
);
</code></pre>
<p>Working with the utilities defined in this way, the composition flow is a bit
nicer:</p>
<pre><code class="language-js">compose(reduce(sum)(0), map(double), filter(isOdd))([1, 2, 3, 4, 5]); // 18
</code></pre>
<p>The cleanliness of this approach is in part why FPers prefer the standalone
utility style instead of instance methods. But your mileage may vary.</p>
<h3><a class="header" href="#adapting-methods-to-standalones" id="adapting-methods-to-standalones">Adapting Methods to Standalones</a></h3>
<p>In the previous definition of <code>filter(..)</code>/<code>map(..)</code>/<code>reduce(..)</code>, you might
have spotted the common pattern across all three: they all dispatch to the
corresponding native array method. So, can we generate these standalone
adaptations with a utility? Yes! Let's make a utility called <code>unboundMethod(..)</code>
to do just that:</p>
<pre><code class="language-js">var unboundMethod = (methodName, argCount = 2) =&gt;
  curry((...args) =&gt; {
    var obj = args.pop();
    return obj[methodName](...args);
  }, argCount);
</code></pre>
<p>And to use this utility:</p>
<pre><code class="language-js">var filter = unboundMethod(&quot;filter&quot;, 2);
var map = unboundMethod(&quot;map&quot;, 2);
var reduce = unboundMethod(&quot;reduce&quot;, 3);

compose(reduce(sum)(0), map(double), filter(isOdd))([1, 2, 3, 4, 5]); // 18
</code></pre>
<p><strong>Note:</strong> <code>unboundMethod(..)</code> is called <code>invoker(..)</code> in Ramda.</p>
<h3><a class="header" href="#adapting-standalones-to-methods" id="adapting-standalones-to-methods">Adapting Standalones to Methods</a></h3>
<p>If you prefer to work with only array methods (fluent chain style), you have two
choices. You can:</p>
<ol>
<li>Extend the built-in <code>Array.prototype</code> with additional methods.</li>
<li>Adapt a standalone utility to work as a reducer function and pass it to the
<code>reduce(..)</code> instance method.</li>
</ol>
<p><strong>Don't do (1).</strong> It's never a good idea to extend built-in natives like
<code>Array.prototype</code> -- unless you define a subclass of <code>Array</code>, but that's beyond
our discussion scope here. In an effort to discourage bad practices, we won't go
any further into this approach.</p>
<p>Let's <strong>focus on (2)</strong> instead. To illustrate this point, we'll convert the
recursive <code>flatten(..)</code> standalone utility from earlier:</p>
<pre><code class="language-js">var flatten = arr =&gt;
  arr.reduce(
    (list, v) =&gt;
      // note: concat(..) used here since it automatically
      // flattens an array into the concatenation
      list.concat(Array.isArray(v) ? flatten(v) : v),
    []
  );
</code></pre>
<p>Let's pull out the inner <code>reducer(..)</code> function as the standalone utility (and
adapt it to work without the outer <code>flatten(..)</code>):</p>
<pre><code class="language-js">// intentionally a function to allow recursion by name
function flattenReducer(list, v) {
  // note: concat(..) used here since it automatically
  // flattens an array into the concatenation
  return list.concat(Array.isArray(v) ? v.reduce(flattenReducer, []) : v);
}
</code></pre>
<p>Now, we can use this utility in an array method chain via <code>reduce(..)</code>:</p>
<pre><code class="language-js">[[1, 2, 3], 4, 5, [6, [7, 8]]].reduce(flattenReducer, []);
// ..
</code></pre>
<h2><a class="header" href="#looking-for-lists" id="looking-for-lists">Looking for Lists</a></h2>
<p>So far, most of the examples have been rather trivial, based on simple lists of
numbers or strings. Let's now talk about where list operations can start to
shine: modeling an imperative series of statements declaratively.</p>
<p>Consider this base example:</p>
<pre><code class="language-js">var getSessionId = partial(prop, &quot;sessId&quot;);
var getUserId = partial(prop, &quot;uId&quot;);

var session, sessionId, user, userId, orders;

session = getCurrentSession();
if (session != null) sessionId = getSessionId(session);
if (sessionId != null) user = lookupUser(sessionId);
if (user != null) userId = getUserId(user);
if (userId != null) orders = lookupOrders(userId);
if (orders != null) processOrders(orders);
</code></pre>
<p>First, let's observe that the five variable declarations and the running series
of <code>if</code> conditionals guarding the function calls are effectively one big
composition of these six calls <code>getCurrentSession()</code>, <code>getSessionId(..)</code>,
<code>lookupUser(..)</code>, <code>getUserId(..)</code>, <code>lookupOrders(..)</code>, and <code>processOrders(..)</code>.
Ideally, we'd like to get rid of all these variable declarations and imperative
conditionals.</p>
<p>Unfortunately, the <code>compose(..)</code>/<code>pipe(..)</code> utilities we explored in
<a href="chapter_4.html">Chapter 4</a> don't by themselves offer a convenient way to express
the <code>!= null</code> conditionals in the composition. Let's define a utility to help:</p>
<pre><code class="language-js">var guard = fn =&gt; arg =&gt; (arg != null ? fn(arg) : arg);
</code></pre>
<p>This <code>guard(..)</code> utility lets us map the five conditional-guarded functions:</p>
<pre><code class="language-js">[getSessionId, lookupUser, getUserId, lookupOrders, processOrders].map(guard);
</code></pre>
<p>The result of this mapping is an array of functions that are ready to compose
(actually, pipe, in this listed order). We could spread this array to
<code>pipe(..)</code>, but because we're already doing list operations, let's do it with a
<code>reduce(..)</code>, using the session value from <code>getCurrentSession()</code> as the initial
value:</p>
<pre><code class="language-js">.reduce(
    (result,nextFn) =&gt; nextFn( result )
    , getCurrentSession()
)
</code></pre>
<p>Next, let's observe that <code>getSessionId(..)</code> and <code>getUserId(..)</code> can be expressed
as a mapping from the respective values <code>&quot;sessId&quot;</code> and <code>&quot;uId&quot;</code>:</p>
<pre><code class="language-js">[&quot;sessId&quot;, &quot;uId&quot;].map(propName =&gt; partial(prop, propName));
</code></pre>
<p>But to use these, we'll need to interleave them with the other three functions
(<code>lookupUser(..)</code>, <code>lookupOrders(..)</code>, and <code>processOrders(..)</code>) to get the array
of five functions to guard/compose as discussed before.</p>
<p>To do the interleaving, we can model this as list merging. Recall
<code>mergeReducer(..)</code> from earlier in the chapter:</p>
<pre><code class="language-js">var mergeReducer = (merged, v, idx) =&gt; (merged.splice(idx * 2, 0, v), merged);
</code></pre>
<p>We can use <code>reduce(..)</code> (our Swiss Army knife, remember!?) to &quot;insert&quot;
<code>lookupUser(..)</code> in the array between the generated functions <code>getSessionId(..)</code>
and <code>getUserId(..)</code>, by merging two lists:</p>
<pre><code class="language-js">.reduce( mergeReducer, [ lookupUser ] )
</code></pre>
<p>Then we'll concatenate <code>lookupOrders(..)</code> and <code>processOrders(..)</code> onto the end
of the running functions array:</p>
<pre><code class="language-js">.concat( lookupOrders, processOrders )
</code></pre>
<p>To review, the generated list of five functions is expressed as:</p>
<pre><code class="language-js">[&quot;sessId&quot;, &quot;uId&quot;]
  .map(propName =&gt; partial(prop, propName))
  .reduce(mergeReducer, [lookupUser])
  .concat(lookupOrders, processOrders);
</code></pre>
<p>Finally, to put it all together, take this list of functions and tack on the
guarding and composition from earlier:</p>
<pre><code class="language-js">[&quot;sessId&quot;, &quot;uId&quot;]
  .map(propName =&gt; partial(prop, propName))
  .reduce(mergeReducer, [lookupUser])
  .concat(lookupOrders, processOrders)
  .map(guard)
  .reduce((result, nextFn) =&gt; nextFn(result), getCurrentSession());
</code></pre>
<p>Gone are all the imperative variable declarations and conditionals, and in their
place we have clean and declarative list operations chained together.</p>
<p>I know this version is likely harder for most readers to understand right now
than the original. Don't worry, that's natural. The original imperative form is
one you're probably much more familiar with.</p>
<p>Part of your evolution to become a functional programmer is to develop a
recognition of FP patterns such as list operations, and that takes lots of
exposure and practice. Over time, these will jump out of the code more readily
as your sense of code readability shifts to declarative style.</p>
<p>Before we move on from this topic, let's take a reality check: the example here
is heavily contrived. Not all code segments will be straightforwardly modeled as
list operations. The pragmatic take-away is to develop the instinct to look for
these opportunities, but not get too hung up on code acrobatics; some
improvement is better than none. Always step back and ask if you're <strong>improving
or harming</strong> code readability.</p>
<h2><a class="header" href="#fusion" id="fusion">Fusion</a></h2>
<p>As FP list operations permeate the way you think about code, you'll very likely
start recognizing chains of combined behavior, like:</p>
<pre><code class="language-js">..
.filter(..)
.map(..)
.reduce(..);
</code></pre>
<p>And more often than not, you're also probably going to end up with chains with
multiple adjacent instances of each operation, like:</p>
<pre><code class="language-js">someList
.filter(..)
.filter(..)
.map(..)
.map(..)
.map(..)
.reduce(..);
</code></pre>
<p>The good news is the chain-style is declarative and it's easy to read the
specific steps that will happen, in order. The downside is that each of these
operations loops over the entire list, meaning performance can suffer
unnecessarily, especially if the list is longer.</p>
<p>With the alternative standalone style, you might see code like this:</p>
<pre><code class="language-js">map(fn3, map(fn2, map(fn1, someList)));
</code></pre>
<p>With this style, the operations are listed from bottom-to-top, and we still loop
over the list three times.</p>
<p>Fusion deals with combining adjacent operators to reduce the number of times the
list is iterated over. We'll focus here on collapsing adjacent <code>map(..)</code>s as
it's the most straightforward to explain.</p>
<p>Imagine this scenario:</p>
<pre><code class="language-js">var removeInvalidChars = str =&gt; str.replace(/[^\w]*/g, &quot;&quot;);

var upper = str =&gt; str.toUpperCase();

var elide = str =&gt; (str.length &gt; 10 ? str.substr(0, 7) + &quot;...&quot; : str);

var words = &quot;Mr. Jones isn't responsible for this disaster!&quot;.split(/\s/);

words;
// [&quot;Mr.&quot;,&quot;Jones&quot;,&quot;isn't&quot;,&quot;responsible&quot;,&quot;for&quot;,&quot;this&quot;,&quot;disaster!&quot;]

words
  .map(removeInvalidChars)
  .map(upper)
  .map(elide);
// [&quot;MR&quot;,&quot;JONES&quot;,&quot;ISNT&quot;,&quot;RESPONS...&quot;,&quot;FOR&quot;,&quot;THIS&quot;,&quot;DISASTER&quot;]
</code></pre>
<p>Think about each value that goes through this flow of transformations. The first
value in the <code>words</code> list starts out as <code>&quot;Mr.&quot;</code>, becomes <code>&quot;Mr&quot;</code>, then <code>&quot;MR&quot;</code>,
and then passes through <code>elide(..)</code> unchanged. Another piece of data flows:
<code>&quot;responsible&quot;</code> -&gt; <code>&quot;responsible&quot;</code> -&gt; <code>&quot;RESPONSIBLE&quot;</code> -&gt; <code>&quot;RESPONS...&quot;</code>.</p>
<p>In other words, you could think of these data transformations like this:</p>
<pre><code class="language-js">elide(upper(removeInvalidChars(&quot;Mr.&quot;)));
// &quot;MR&quot;

elide(upper(removeInvalidChars(&quot;responsible&quot;)));
// &quot;RESPONS...&quot;
</code></pre>
<p>Did you catch the point? We can express the three separate steps of the adjacent
<code>map(..)</code> calls as a composition of the transformers, since they are all unary
functions and each returns the value that's suitable as input to the next. We
can fuse the mapper functions using <code>compose(..)</code>, and then pass the composed
function to a single <code>map(..)</code> call:</p>
<pre><code class="language-js">words.map(compose(elide, upper, removeInvalidChars));
// [&quot;MR&quot;,&quot;JONES&quot;,&quot;ISNT&quot;,&quot;RESPONS...&quot;,&quot;FOR&quot;,&quot;THIS&quot;,&quot;DISASTER&quot;]
</code></pre>
<p>This is another case where <code>pipe(..)</code> can be a more convenient form of
composition, for its ordering readability:</p>
<pre><code class="language-js">words.map(pipe(removeInvalidChars, upper, elide));
// [&quot;MR&quot;,&quot;JONES&quot;,&quot;ISNT&quot;,&quot;RESPONS...&quot;,&quot;FOR&quot;,&quot;THIS&quot;,&quot;DISASTER&quot;]
</code></pre>
<p>What about fusing two or more <code>filter(..)</code> predicate functions? Typically
treated as unary functions, they seem suitable for composition. But the wrinkle
is they each return a different kind of value (<code>boolean</code>) than the next one
would want as input. Fusing adjacent <code>reduce(..)</code> calls is also possible, but
reducers are not unary so that's a bit more challenging; we need more
sophisticated tricks to pull this kind of fusion off. We'll cover these advanced
techniques in <a href="apA.html">Appendix A</a>.</p>
<h2><a class="header" href="#beyond-lists" id="beyond-lists">Beyond Lists</a></h2>
<p>So far we've been discussing operations in the context of the list (array) data
structure; it's by far the most common scenario where you'll encounter them. But
in a more general sense, these operations can be performed against any
collection of values.</p>
<p>Just as we said earlier that array's <code>map(..)</code> adapts a single-value operation
to all its values, any data structure can provide a <code>map(..)</code> operation to do
the same. Likewise, it can implement <code>filter(..)</code>, <code>reduce(..)</code>, or any other
operation that makes sense for working with the data structure's values.</p>
<p>The important part to maintain in the spirit of FP is that these operators must
behave according to value immutability, meaning that they must return a new data
structure rather than mutating the existing one.</p>
<img alt="figure" src="images/fig7.png" align="left" width="20%" hspace="20" vspace="20">
<p>Let's illustrate with a well-known data structure: the binary tree. A binary
tree is a node (just an object!) that has at most two references to other nodes
(themselves binary trees), typically referred to as <em>left</em> and <em>right</em> child
trees. Each node in the tree holds one value of the overall data structure.</p>
<p>For ease of illustration, we'll make our binary tree a binary search tree (BST).
However, the operations we'll identify work the same for any regular non-BST
binary tree.</p>
<p><strong>Note:</strong> A binary search tree is a general binary tree with a special
constraint on the relationship of values in the tree to each other. Each value
of nodes on the left side of a tree is less than the value of the node at the
root of that tree, which in turn is less than each value of nodes in the right
side of the tree. The notion of &quot;less than&quot; is relative to the kind of data
stored; it can be numerical for numbers, lexicographic for strings, and so on.
BSTs by definition must remain balanced, which makes searching for a value in
the tree more efficient, using a recursive binary search algorithm.</p>
<p>To make a binary tree node object, let's use this factory function:</p>
<pre><code class="language-js">var BinaryTree = (value, parent, left, right) =&gt; ({
  value,
  parent,
  left,
  right
});
</code></pre>
<p>For convenience, we make each node store the <code>left</code> and <code>right</code> child trees as
well as a reference to its own <code>parent</code> node.</p>
<p>Let's now define a BST of names of common produce (fruits, vegetables):</p>
<pre><code class="language-js">var banana = BinaryTree(&quot;banana&quot;);
var apple = (banana.left = BinaryTree(&quot;apple&quot;, banana));
var cherry = (banana.right = BinaryTree(&quot;cherry&quot;, banana));
var apricot = (apple.right = BinaryTree(&quot;apricot&quot;, apple));
var avocado = (apricot.right = BinaryTree(&quot;avocado&quot;, apricot));
var cantaloupe = (cherry.left = BinaryTree(&quot;cantaloupe&quot;, cherry));
var cucumber = (cherry.right = BinaryTree(&quot;cucumber&quot;, cherry));
var grape = (cucumber.right = BinaryTree(&quot;grape&quot;, cucumber));
</code></pre>
<p>In this particular tree structure, <code>banana</code> is the root node; this tree could
have been set up with nodes in different locations, but still had a BST with the
same traversal.</p>
<p>Our tree looks like:</p>
<p align="center">
    <img alt="figure" src="images/fig8.png" width="60%">
</p>
<p>There are multiple ways to traverse a binary tree to process its values. If it's
a BST (ours is!) and we do an <em>in-order</em> traversal -- always visit the left
child tree first, then the node itself, then the right child tree -- we'll visit
the values in ascending (sorted) order.</p>
<p>Because you can't just easily <code>console.log(..)</code> a binary tree like you can with
an array, let's first define a convenience method, mostly to use for printing.
<code>forEach(..)</code> will visit the nodes of a binary tree in the same manner as an
array:</p>
<pre><code class="language-js">// in-order traversal
BinaryTree.forEach = function forEach(visitFn, node) {
  if (node) {
    if (node.left) {
      forEach(visitFn, node.left);
    }

    visitFn(node);

    if (node.right) {
      forEach(visitFn, node.right);
    }
  }
};
</code></pre>
<p><strong>Note:</strong> Working with binary trees lends itself most naturally to recursive
processing. Our <code>forEach(..)</code> utility recursively calls itself to process both
the left and right child trees. We already discussed recursion in
<a href="chapter_8.html">Chapter 8</a>, where we covered recursion in the chapter on
recursion.</p>
<p>Recall <code>forEach(..)</code> was described at the beginning of this chapter as only
being useful for side effects, which is not very typically desired in FP. In
this case, we'll use <code>forEach(..)</code> only for the side effect of I/O, so it's
perfectly reasonable as a helper.</p>
<p>Use <code>forEach(..)</code> to print out values from the tree:</p>
<pre><code class="language-js">BinaryTree.forEach(node =&gt; console.log(node.value), banana);
// apple apricot avocado banana cantaloupe cherry cucumber grape

// visit only the `cherry`-rooted subtree
BinaryTree.forEach(node =&gt; console.log(node.value), cherry);
// cantaloupe cherry cucumber grape
</code></pre>
<p>To operate on our binary tree data structure using FP patterns, let's start by
defining a <code>map(..)</code>:</p>
<pre><code class="language-js">BinaryTree.map = function map(mapperFn, node) {
  if (node) {
    let newNode = mapperFn(node);
    newNode.parent = node.parent;
    newNode.left = node.left ? map(mapperFn, node.left) : undefined;
    newNode.right = node.right ? map(mapperFn, node.right) : undefined;

    if (newNode.left) {
      newNode.left.parent = newNode;
    }
    if (newNode.right) {
      newNode.right.parent = newNode;
    }

    return newNode;
  }
};
</code></pre>
<p>You might have assumed we'd <code>map(..)</code> only the node <code>value</code> properties, but in
general we might actually want to map the tree nodes themselves. So, the
<code>mapperFn(..)</code> is passed the whole node being visited, and it expects to receive
a new <code>BinaryTree(..)</code> node back, with the transformation applied. If you just
return the same node, this operation will mutate your tree and quite possibly
cause unexpected results!</p>
<p>Let's map our tree to a list of produce with all uppercase names:</p>
<pre><code class="language-js">var BANANA = BinaryTree.map(
  node =&gt; BinaryTree(node.value.toUpperCase()),
  banana
);

BinaryTree.forEach(node =&gt; console.log(node.value), BANANA);
// APPLE APRICOT AVOCADO BANANA CANTALOUPE CHERRY CUCUMBER GRAPE
</code></pre>
<p><code>BANANA</code> is a different tree (with all different nodes) than <code>banana</code>, just like
calling <code>map(..)</code> on an array returns a new array. Just like arrays of other
objects/arrays, if <code>node.value</code> itself references some object/array, you'll also
need to handle manually copying it in the mapper function if you want deeper
immutability.</p>
<p>How about <code>reduce(..)</code>? Same basic process: do an in-order traversal of the tree
nodes. One usage would be to <code>reduce(..)</code> our tree to an array of its values,
which would be useful in further adapting other typical list operations. Or we
can <code>reduce(..)</code> our tree to a string concatenation of all its produce names.</p>
<p>We'll mimic the behavior of the array <code>reduce(..)</code>, which makes passing the
<code>initialValue</code> argument optional. This algorithm is a little trickier, but still
manageable:</p>
<pre><code class="language-js">BinaryTree.reduce = function reduce(reducerFn, initialValue, node) {
  if (arguments.length &lt; 3) {
    // shift the parameters since `initialValue` was omitted
    node = initialValue;
  }

  if (node) {
    let result;

    if (arguments.length &lt; 3) {
      if (node.left) {
        result = reduce(reducerFn, node.left);
      } else {
        return node.right ? reduce(reducerFn, node, node.right) : node;
      }
    } else {
      result = node.left
        ? reduce(reducerFn, initialValue, node.left)
        : initialValue;
    }

    result = reducerFn(result, node);
    result = node.right ? reduce(reducerFn, result, node.right) : result;
    return result;
  }

  return initialValue;
};
</code></pre>
<p>Let's use <code>reduce(..)</code> to make our shopping list (an array):</p>
<pre><code class="language-js">BinaryTree.reduce((result, node) =&gt; [...result, node.value], [], banana);
// [&quot;apple&quot;,&quot;apricot&quot;,&quot;avocado&quot;,&quot;banana&quot;,&quot;cantaloupe&quot;
//   &quot;cherry&quot;,&quot;cucumber&quot;,&quot;grape&quot;]
</code></pre>
<p>Finally, let's consider <code>filter(..)</code> for our tree. This algorithm is trickiest
so far because it effectively (not actually) involves removing nodes from the
tree, which requires handling several corner cases. Don't get intimidated by the
implementation, though. Just skip over it for now, if you prefer, and focus on
how we use it instead.</p>
<pre><code class="language-js">BinaryTree.filter = function filter(predicateFn, node) {
  if (node) {
    let newNode;
    let newLeft = node.left ? filter(predicateFn, node.left) : undefined;
    let newRight = node.right ? filter(predicateFn, node.right) : undefined;

    if (predicateFn(node)) {
      newNode = BinaryTree(node.value, node.parent, newLeft, newRight);
      if (newLeft) {
        newLeft.parent = newNode;
      }
      if (newRight) {
        newRight.parent = newNode;
      }
    } else {
      if (newLeft) {
        if (newRight) {
          newNode = BinaryTree(undefined, node.parent, newLeft, newRight);
          newLeft.parent = newRight.parent = newNode;

          if (newRight.left) {
            let minRightNode = newRight;
            while (minRightNode.left) {
              minRightNode = minRightNode.left;
            }

            newNode.value = minRightNode.value;

            if (minRightNode.right) {
              minRightNode.parent.left = minRightNode.right;
              minRightNode.right.parent = minRightNode.parent;
            } else {
              minRightNode.parent.left = undefined;
            }

            minRightNode.right = minRightNode.parent = undefined;
          } else {
            newNode.value = newRight.value;
            newNode.right = newRight.right;
            if (newRight.right) {
              newRight.right.parent = newNode;
            }
          }
        } else {
          return newLeft;
        }
      } else {
        return newRight;
      }
    }

    return newNode;
  }
};
</code></pre>
<p>The majority of this code listing is dedicated to handling the shifting of a
node's parent/child references if it's &quot;removed&quot; (filtered out) of the
duplicated tree structure.</p>
<p>As an example to illustrate using <code>filter(..)</code>, let's narrow our produce tree
down to only vegetables:</p>
<pre><code class="language-js">var vegetables = [
  &quot;asparagus&quot;,
  &quot;avocado&quot;,
  &quot;broccoli&quot;,
  &quot;carrot&quot;,
  &quot;celery&quot;,
  &quot;corn&quot;,
  &quot;cucumber&quot;,
  &quot;lettuce&quot;,
  &quot;potato&quot;,
  &quot;squash&quot;,
  &quot;zucchini&quot;
];

var whatToBuy = BinaryTree.filter(
  // filter the produce list only for vegetables
  node =&gt; vegetables.indexOf(node.value) != -1,
  banana
);

// shopping list
BinaryTree.reduce((result, node) =&gt; [...result, node.value], [], whatToBuy);
// [&quot;avocado&quot;,&quot;cucumber&quot;]
</code></pre>
<p><strong>Note:</strong> We aren't making any effort to rebalance a tree after any of the
<code>map</code>/<code>reduce</code>/<code>filter</code> operations on BSTs. Technically, this means the results
are not themselves binary <em>search</em> trees. Most JS values have a reasonable
less-than comparison operation (<code>&lt;</code>) by which we could rebalance such a tree,
but some values (like promises) wouldn't have any such definition. For the sake
of keeping this chapter practical in length, we'll punt on handling this
complication.</p>
<p>You will likely use most of the list operations from this chapter in the context
of simple arrays. But now we've seen that the concepts apply to whatever data
structures and operations you might need. That's a powerful expression of how FP
can be widely applied to many different application scenarios!</p>
<h2><a class="header" href="#summary-8" id="summary-8">Summary</a></h2>
<p>Three common and powerful list operations we looked at:</p>
<ul>
<li><code>map(..)</code>: Transforms values as it projects them to a new list.</li>
<li><code>filter(..)</code>: Selects or excludes values as it projects them to a new list.</li>
<li><code>reduce(..)</code>: Combines values in a list to produce some other (usually but not
always non-list) value.</li>
</ul>
<p>Other more advanced operations that are useful in processing lists:
<code>unique(..)</code>, <code>flatten(..)</code>, and <code>merge(..)</code>.</p>
<p>Fusion uses function composition to consolidate multiple adjacent <code>map(..)</code>
calls. This is mostly a performance optimization, but it also improves the
declarative nature of your list operations.</p>
<p>Lists are typically visualized as arrays, but can be generalized as any data
structure that represents/produces an ordered collection of values. As such, all
these &quot;list operations&quot; are actually &quot;data structure operations&quot;.</p>
<h1><a class="header" href="#functional-light-javascript-11" id="functional-light-javascript-11">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-10-functional-async" id="chapter-10-functional-async">Chapter 10: Functional Async</a></h1>
<p>At this point of the book, you now have all the raw concepts in place for the
foundations of FP that I call &quot;Functional-Light Programming&quot;. In this chapter,
we're going to apply these concepts to a different context, but we won't really
present particularly new ideas.</p>
<p>So far, almost everything we've done is synchronous, meaning that we call
functions with immediate inputs and immediately get back output values. A lot of
work can be done this way, but it's not nearly sufficient for the entirety of a
modern JS application. To be truly ready for FP in the real world of JS, we need
to understand async FP.</p>
<p>Our goal in this chapter is to expand our thinking about managing values with
FP, to spread out such operations over time. We'll see that Observables (and
Promises!) are one great way to do that.</p>
<h2><a class="header" href="#time-as-state" id="time-as-state">Time as State</a></h2>
<p>The most complicated state in your entire application is time. That is, it's far
easier to manage state when the transition from one state to another is
immediate and affirmatively in your control. When the state of your application
changes implicitly in response to events spread out over time, management
becomes exponentially more difficult.</p>
<p>Every part of how we've presented FP in this text has been about making code
easier to read by making it more trustable and more predictable. When you
introduce asynchrony to your program, those efforts take a big hit.</p>
<p>But let's be more explicit: it's not the mere fact that some operations don't
finish synchronously that is concerning; firing off asynchronous behavior is
easy. It's the coordination of the responses to these actions, each of which has
the potential to change the state of your application, that requires so much
extra effort.</p>
<p>So, is it better for you the author to take that effort, or should you just
leave it to the reader of your code to figure out what the state of the program
will be if A finishes before B, or vice versa? That's a rhetorical question but
one with a pretty concrete answer from my perspective: to have any hope of
making such complex code more readable, the author has to take a lot more care
than they normally would.</p>
<h3><a class="header" href="#reducing-time" id="reducing-time">Reducing Time</a></h3>
<p>One of the most important outcomes of async programming patterns is simplifying
state change management by abstracting out time from our sphere of concern. To
illustrate, let's first look at a scenario where a race condition (aka, time
complexity) exists, and must be manually managed:</p>
<pre><code class="language-js">var customerId = 42;
var customer;

lookupCustomer(customerId, function onCustomer(customerRecord) {
  var orders = customer ? customer.orders : null;
  customer = customerRecord;
  if (orders) {
    customer.orders = orders;
  }
});

lookupOrders(customerId, function onOrders(customerOrders) {
  if (!customer) {
    customer = {};
  }
  customer.orders = customerOrders;
});
</code></pre>
<p>The <code>onCustomer(..)</code> and <code>onOrders(..)</code> callbacks are in a binary race
condition. Assuming they both run, it's possible that either might run first,
and it's impossible to predict which will happen.</p>
<p>If we could embed the call to <code>lookupOrders(..)</code> inside of <code>onCustomer(..)</code>,
we'd be sure that <code>onOrders(..)</code> was running after <code>onCustomer(..)</code>. But we
can't do that, because we need the two lookups to occur concurrently.</p>
<p>So to normalize this time-based state complexity, we use a pairing of
<code>if</code>-statement checks in the respective callbacks, along with an outer lexically
closed over variable <code>customer</code>. When each callback runs, it checks the state of
<code>customer</code>, and thus determines its own relative ordering; if <code>customer</code> is
unset for a callback, it's the first to run, otherwise it's the second.</p>
<p>This code works, but it's far from ideal in terms of readability. The time
complexity makes this code harder to read. Let's instead use a JS Promise to
factor time out of the picture:</p>
<pre><code class="language-js">var customerId = 42;

var customerPromise = lookupCustomer(customerId);
var ordersPromise = lookupOrders(customerId);

customerPromise.then(function onCustomer(customer) {
  ordersPromise.then(function onOrders(orders) {
    customer.orders = orders;
  });
});
</code></pre>
<p>The <code>onOrders(..)</code> callback is now inside of the <code>onCustomer(..)</code> callback, so
their relative ordering is guaranteed. The concurrency of the lookups is
accomplished by making the <code>lookupCustomer(..)</code> and <code>lookupOrders(..)</code> calls
separately before specifying the <code>then(..)</code> response handling.</p>
<p>It may not be obvious, but there would otherwise inherently be a race condition
in this snippet, were it not for how Promises are defined to behave. If the
lookup of the <code>orders</code> finishes before the <code>ordersPromise.then(..)</code> is called to
provide an <code>onOrders(..)</code> callback, <em>something</em> needs to be smart enough to keep
that <code>orders</code> list around until <code>onOrders(..)</code> can be called. In fact, the same
concern could apply to <code>customer</code> being present before <code>onCustomer(..)</code> is
specified to receive it.</p>
<p>That <em>something</em> is the same kind of time complexity logic we discussed with the
previous snippet. But we don't have to worry about any of that complexity,
either in the writing of this code or -- more importantly -- in the reading of
it, because the promises take care of that time normalization for us.</p>
<p>A Promise represents a single (future) value in a time-independent manner.
Moreover, extracting the value from a promise is the asynchronous form of the
synchronous assignment (via <code>=</code>) of an immediate value. In other words, a
promise spreads an <code>=</code> assignment operation out over time, but in a trustable
(time-independent) fashion.</p>
<p>We'll now explore how we similarly can spread various synchronous FP operations
from earlier in this book asynchronously over time.</p>
<h2><a class="header" href="#eager-vs-lazy" id="eager-vs-lazy">Eager vs. Lazy</a></h2>
<p>Eager and lazy in the realm of computer science aren't compliments or insults,
but rather ways to describe whether an operation will finish right away or
progress over time.</p>
<p>The FP operations that we've seen in this text can be characterized as eager
because they operate synchronously (right now) on a discrete immediate value or
list/structure of values.</p>
<p>Recall:</p>
<pre><code class="language-js">var a = [1, 2, 3];

var b = a.map(v =&gt; v * 2);

b; // [2,4,6]
</code></pre>
<p>This mapping from <code>a</code> to <code>b</code> is eager because it operates on all the values in
the <code>a</code> array at that moment, and produces a new <code>b</code> array. If you later modify
<code>a</code> (for example, by adding a new value to the end of it) nothing will change
about the contents of <code>b</code>. That's eager FP.</p>
<p>But what would it look like to have a lazy FP operation? Consider something like
this:</p>
<pre><code class="language-js">var a = [];

var b = mapLazy(a, v =&gt; v * 2);

a.push(1);

a[0]; // 1
b[0]; // 2

a.push(2);

a[1]; // 2
b[1]; // 4
</code></pre>
<p>The <code>mapLazy(..)</code> we've imagined here essentially &quot;listens&quot; to the <code>a</code> array,
and every time a new value is added to the end of it (with <code>push(..)</code>), it runs
the <code>v =&gt; v * 2</code> mapping function and pushes the transformed value to the <code>b</code>
array.</p>
<p><strong>Note:</strong> The implementation of <code>mapLazy(..)</code> has not been shown because this is
a fictional illustration, not a real operation. To accomplish this kind of lazy
operation pairing between <code>a</code> and <code>b</code>, we'll need something smarter than basic
arrays.</p>
<p>Consider the benefits of being able to pair an <code>a</code> and <code>b</code> together, where any
time (even asynchronously!) you put a value into <code>a</code>, it's transformed and
projected to <code>b</code>. That's the same kind of declarative FP power from of a
<code>map(..)</code> operation, but now it can be stretched over time; you don't have to
know all the values of <code>a</code> <em>right now</em> to set up the mapping from <code>a</code> to <code>b</code>.</p>
<h2><a class="header" href="#reactive-fp" id="reactive-fp">Reactive FP</a></h2>
<p>To understand how we could create and use a lazy mapping between two sets of
values, we need to abstract our idea of list (array) a bit. Let's imagine a
smarter kind of array, not one which simply holds values but one which lazily
receives and responds (aka &quot;reacts&quot;) to values. Consider:</p>
<pre><code class="language-js">var a = new LazyArray();

var b = a.map(function double(v) {
  return v * 2;
});

setInterval(function everySecond() {
  a.push(Math.random());
}, 1000);
</code></pre>
<p>So far, this snippet doesn't look any different than a normal array. The only
unusual thing is that we're used to the <code>map(..)</code> running eagerly and
immediately producing a <code>b</code> array with all the currently mapped values from <code>a</code>.
The timer pushing random values into <code>a</code> is strange, since all those values are
coming <em>after</em> the <code>map(..)</code> call.</p>
<p>But this fictional <code>LazyArray</code> is different; it assumes that values will come
one at a time, over time; just <code>push(..)</code> values in whenever you want. <code>b</code> will
be a lazy mapping of whatever values eventually end up in <code>a</code>.</p>
<p>Also, we don't really need to keep values in <code>a</code> or <code>b</code> once they've been
handled; this special kind of array only holds a value as long as it's needed.
So these arrays don't strictly grow in memory usage over time, an important
characteristic of lazy data structures and operations. In fact, it's less like
an array and more like a buffer.</p>
<p>A normal array is eager in that it holds all of its values right now. A &quot;lazy
array&quot; is an array where the values will come in over time.</p>
<p>Since we won't necessarily know when a new value has arrived in <code>a</code>, another key
thing we need is to be able to listen to <code>b</code> to be notified when new values are
made available. We could imagine a listener like this:</p>
<pre><code class="language-js">b.listen(function onValue(v) {
  console.log(v);
});
</code></pre>
<p><code>b</code> is <em>reactive</em> in that it's set up to <em>react</em> to values as they come into
<code>a</code>. There's an FP operation <code>map(..)</code> that describes how each value transfers
from the origin <code>a</code> to the target <code>b</code>. Each discrete mapping operation is
exactly how we modeled single-value operations with normal synchronous FP, but
here we're spreading out the sourcing of values over time.</p>
<p><strong>Note:</strong> The term most commonly applied to these concepts is Functional
Reactive Programming (FRP). I'm deliberately avoiding that term because there's
some debate as to whether FP + Reactive genuinely constitutes FRP. We're not
going to fully dive into all the implications of FRP here, so I'll just keep
calling it reactive FP. Alternatively, you could call it evented-FP if that
feels less confusing.</p>
<p>We can think of <code>a</code> as producing values and <code>b</code> as consuming them. So for
readability, let's reorganize this snippet to separate the concerns into
<em>producer</em> and <em>consumer</em> roles:</p>
<pre><code class="language-js">// producer:

var a = new LazyArray();

setInterval(function everySecond() {
  a.push(Math.random());
}, 1000);

// **************************
// consumer:

var b = a.map(function double(v) {
  return v * 2;
});

b.listen(function onValue(v) {
  console.log(v);
});
</code></pre>
<p><code>a</code> is the producer, which acts essentially like a stream of values. We can
think of each value arriving in <code>a</code> as an <em>event</em>. The <code>map(..)</code> operation then
triggers a corresponding event on <code>b</code>, which we <code>listen(..)</code> to so we can
consume the new value.</p>
<p>The reason we separate the <em>producer</em> and <em>consumer</em> concerns is so that
different parts of our application can be responsible for each concern. This
code organization can drastically improve both code readability and maintenance.</p>
<h3><a class="header" href="#declarative-time" id="declarative-time">Declarative Time</a></h3>
<p>We're being very careful about how we introduce time into the discussion.
Specifically, just as promises abstract time away from our concern for a single
asynchronous operation, reactive FP abstracts (separates) time away from a
series of values/operations.</p>
<p>From the perspective of <code>a</code> (the producer), the only evident time concern is our
manual <code>setInterval(..)</code> loop. But that's only for demonstration purposes.</p>
<p>Imagine <code>a</code> could actually be attached to some other event source, like the
user's mouse clicks or keystrokes, websocket messages from a server, etc. In
that scenario, <code>a</code> doesn't actually have to concern itself with time. It's
merely a time-independent conduit for values, whenever they are ready.</p>
<p>From the perspective of <code>b</code> (the consumer), we do not know or care when/where
the values in <code>a</code> come from. As a matter of fact, all the values could already
be present. All we care about is that we want those values, whenever they are
ready. Again, this is a time-independent (aka lazy) modeling of the <code>map(..)</code>
transformation operation.</p>
<p>The <em>time</em> relationship between <code>a</code> and <code>b</code> is declarative (and implicit!), not
imperative (or explicit).</p>
<p>The value of organizing such operations-over-time this way may not feel
particularly effective yet. Let's compare to how this same sort of functionality
could have been expressed imperatively:</p>
<pre><code class="language-js">// producer:

var a = {
  onValue(v) {
    b.onValue(v);
  }
};

setInterval(function everySecond() {
  a.onValue(Math.random());
}, 1000);

// **************************
// consumer:

var b = {
  map(v) {
    return v * 2;
  },
  onValue(v) {
    v = this.map(v);
    console.log(v);
  }
};
</code></pre>
<p>It may seem rather subtle, but there's an important difference between this
more-imperative version of the code and the previous more-declarative version,
aside from just <code>b.onValue(..)</code> needing to call <code>this.map(..)</code> itself. In the
former snippet, <code>b</code> pulls from <code>a</code>, but in the latter snippet, <code>a</code> pushes to
<code>b</code>. In other words, compare <code>b = a.map(..)</code> to <code>b.onValue(v)</code>.</p>
<p>In the latter imperative snippet, it's not clear (readability wise) from the
consumer's perspective where the <code>v</code> values are coming from. Moreover, the
imperative hard coding of <code>b.onValue(..)</code> in the middle of producer <code>a</code>'s logic
is a violation of separation-of-concerns. That can make it harder to reason
about producer and consumer independently.</p>
<p>By contrast, in the former snippet, <code>b = a.map(..)</code> declares that <code>b</code>'s values
are sourced from <code>a</code>, and treats <code>a</code> as an abstract event stream data source
that we don't have to concern ourselves with at that moment. We <em>declare</em> that
any value that comes from <code>a</code> into <code>b</code> will go through the <code>map(..)</code> operation
as specified.</p>
<h3><a class="header" href="#more-than-map" id="more-than-map">More Than Map</a></h3>
<p>For convenience, we've illustrated this notion of pairing <code>a</code> and <code>b</code> together
over time via a one-to-one <code>map(..)</code>ing. But many of our other FP operations
could be modeled over time as well.</p>
<p>Consider:</p>
<pre><code class="language-js">var b = a.filter(function isOdd(v) {
  return v % 2 == 1;
});

b.listen(function onlyOdds(v) {
  console.log(&quot;Odd:&quot;, v);
});
</code></pre>
<p>Here, a value from <code>a</code> only comes into <code>b</code> if it passes the <code>isOdd(..)</code>
predicate.</p>
<p>Even <code>reduce(..)</code> can be modeled over time:</p>
<pre><code class="language-js">var b = a.reduce(function sum(total, v) {
  return total + v;
});

b.listen(function runningTotal(v) {
  console.log(&quot;New current total:&quot;, v);
});
</code></pre>
<p>Since we don't specify an <code>initialValue</code> to the <code>reduce(..)</code> call, neither the
<code>sum(..)</code> reducer nor the <code>runningTotal(..)</code> event callback will be invoked
until at least two values have come through from <code>a</code>.</p>
<p>This snippet implies that the reduction has a <em>memory</em> of sorts, in that each
time a future value comes in, the <code>sum(..)</code> reducer will be invoked with
whatever the previous <code>total</code> was as well as the new next value <code>v</code>.</p>
<p>Other FP operations extended over time could even involve an internal buffer,
like for example <code>unique(..)</code> keeping track of every value it's seen so far.</p>
<h3><a class="header" href="#observables" id="observables">Observables</a></h3>
<p>Hopefully by now you can see the importance of a reactive, evented, array-like
data structure like the fictional <code>LazyArray</code> we've conjured. The good news is,
this kind of data structure already exists, and it's called an Observable.</p>
<p><strong>Note:</strong> Just to set some expectation: the following discussion is only a brief
intro to the world of Observables. This is a far more in-depth topic than we
have space to fully explore. But if you've understood Functional-Light
Programming in this text, and now grasped how asynchronous-time can be modeled
via FP principles, Observables should follow very naturally for your continued
learning.</p>
<p>Observables have been implemented by a variety of userland libraries, most
notably <a href="https://github.com/Reactive-Extensions/RxJS">RxJS</a> and
<a href="https://github.com/cujojs/most">Most</a>. At the time of this writing, there's an
in-progress proposal to add Observables natively to JS, just like Promises were
added in ES6. For the sake of demonstration, we'll use RxJS-flavored Observables
for these next examples.</p>
<p>Here's our earlier reactive example, expressed with observables instead of
<code>LazyArray</code>:</p>
<pre><code class="language-js">// producer:

var a = new Rx.Subject();

setInterval(function everySecond() {
  a.next(Math.random());
}, 1000);

// **************************
// consumer:

var b = a.map(function double(v) {
  return v * 2;
});

b.subscribe(function onValue(v) {
  console.log(v);
});
</code></pre>
<p>In the RxJS universe, an Observer subscribes to an Observable. If you combine
the functionality of an Observer and an Observable, you get a Subject. So, to
keep our snippet simpler, we construct <code>a</code> as a Subject, so that we can call
<code>next(..)</code> on it to push values (events) into its stream.</p>
<p>If we want to keep the Observer and Observable separate:</p>
<pre><code class="language-js">// producer:

var a = Rx.Observable.create(function onObserve(observer) {
  setInterval(function everySecond() {
    observer.next(Math.random());
  }, 1000);
});
</code></pre>
<p>In this snippet, <code>a</code> is the observable, and unsurprisingly, the separate
observer is called <code>observer</code>; it's able to &quot;observe&quot; some events (like our
<code>setInterval(..)</code> loop); we use its <code>next(..)</code> method to feed events into the
<code>a</code> observable stream.</p>
<p>In addition to <code>map(..)</code>, RxJS defines well over a hundred operators that are
invoked lazily as each new value comes in. Just like with arrays, each operator
on an Observable returns a new Observable, meaning they are chainable. If an
invocation of operator function determines a value should be passed along from
the input Observable, it will be fired on the output Observable; otherwise it's
discarded.</p>
<p>Example of a declarative observable chain:</p>
<pre><code class="language-js">var b = a
  .filter(v =&gt; v % 2 == 1) // only odd numbers
  .distinctUntilChanged() // only consecutive-distinct
  .throttle(100) // slow it down a bit
  .map((v = v * 2)); // double them

b.subscribe(function onValue(v) {
  console.log(&quot;Next:&quot;, v);
});
</code></pre>
<p><strong>Note:</strong> It's not necessary to assign the observable to <code>b</code> and then call
<code>b.subscribe(..)</code> separately from the chain; that's done here to reinforce that
each operator returns a new observable from the previous one. In many coding
examples you'll find, the <code>subscribe(..)</code> call is just the final method in the
chain. Because <code>subscribe(..)</code> is technically mutating the internal state of the
observable, FPers generally prefer these two steps separated, to mark the side
effect more obviously.</p>
<h2><a class="header" href="#summary-9" id="summary-9">Summary</a></h2>
<p>This book has detailed a wide variety of FP operations that take a single value
(or an immediate list of values) and transform them into another value/values.</p>
<p>For operations that will be proceed over time, all of these foundational FP
principles can be applied time-independently. Exactly like promises model single
future values, we can model eager lists of values instead as lazy Observable
(event) streams of values that may come in one-at-a-time.</p>
<p>A <code>map(..)</code> on an array runs its mapping function once for each value currently
in the array, putting all the mapped values in the outcome array. A <code>map(..)</code> on
an Observable runs its mapping function once for each value, whenever it comes
in, and pushes all the mapped values to the output Observable.</p>
<p>In other words, if an array is an eager data structure for FP operations, an
Observable is its lazy-over-time counterpart.</p>
<p><strong>Note:</strong> For a different twist on asynchronous FP, check out a library called
<a href="apC.html"><strong>fasy</strong>, which is discussed in Appendix C</a>.</p>
<h1><a class="header" href="#functional-light-javascript-12" id="functional-light-javascript-12">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-11-putting-it-all-together" id="chapter-11-putting-it-all-together">Chapter 11: Putting It All Together</a></h1>
<p>By now, you have everything you need to understand Functional-Light JavaScript.
There's no more new concepts to introduce.</p>
<p>In this final chapter, our main goal is conceptual cohesiveness. We'll look at
code that brings many of the major themes from this book together -- application
of what we've learned. Above all, this example code is intended to illustrate
the &quot;Functional Light&quot; approach to JavaScript -- that is, balance and pragmatism
over dogma.</p>
<p>You'll want to practice these techniques yourself, extensively. Digesting this
chapter is critical to helping you apply FP principles to your real-world code.</p>
<h2><a class="header" href="#setup" id="setup">Setup</a></h2>
<p>Let's build a simple stock ticker widget.</p>
<p><strong>Note:</strong> For reference, the entirety of the code for this example resides in
the <code>ch11-code/</code> sub-directory -- see the
<a href="https://github.com/getify/Functional-Light-JS">GitHub repository for this book</a>.
Also, selected FP helpers we've discussed throughout this book that we need for
this example are included in <code>ch11-code/fp-helpers.js</code>. In this chapter we will
only focus on the relevant parts of the code for our discussion.</p>
<p>First, let's talk about the markup for this widget, so we have somewhere to
display our information. We start out with an empty <code>&lt;ul ..&gt;</code> element in our
<code>ch11-code/index.html</code> file, but while running, the DOM will be populated to
look like:</p>
<pre><code class="language-html">&lt;ul id=&quot;stock-ticker&quot;&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;AAPL&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;AAPL&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$121.95&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;+0.01&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;MSFT&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;MSFT&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$65.78&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;+1.51&lt;/span&gt;
  &lt;/li&gt;
  &lt;li class=&quot;stock&quot; data-stock-id=&quot;GOOG&quot;&gt;
    &lt;span class=&quot;stock-name&quot;&gt;GOOG&lt;/span&gt;
    &lt;span class=&quot;stock-price&quot;&gt;$821.31&lt;/span&gt;
    &lt;span class=&quot;stock-change&quot;&gt;-8.84&lt;/span&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</code></pre>
<p>Before we go any further, let me remind you: interacting with the DOM is I/O,
and that means side effects. We can't eliminate these side effects, but we can
limit and control them. We'll want to be really intentional about minimizing the
surface area of our application that deals with the DOM. We learned all about
these techniques in <a href="chapter_5.html">Chapter 5</a>.</p>
<p>Summarizing our widget's functionality: the code will add the <code>&lt;li ..&gt;</code> elements
each time a new-stock event is &quot;received&quot;, and will update the price and change
as stock-update events come through.</p>
<p>In the Chapter 11 example code, in <code>ch11-code/mock-server.js</code>, we set up some
timers to push out randomly generated fake stock data to a simple event emitter,
to simulate as if we were getting messages of stock information from a server.
We expose a <code>connectToServer()</code> function which pretends to do so, but really
just returns the faked event emitter instance.</p>
<p><strong>Note:</strong> This file is all fake/mock behavior, so I didn't spend much effort
trying to make it very FP-adherent. I wouldn't suggest spending too much time
concerned with the code in this file. If you wrote a real server -- a very
interesting extra credit exercise for the ambitious reader! -- you'd clearly
want to give that code the FP attention it deserves.</p>
<p>In <code>ch11-code/stock-ticker-events.js</code>, we create some observables (via RxJS)
hooked up to an event emitter object. We call the <code>connectToServer()</code> to get
this event emitter, then listen to the event names <code>&quot;stock&quot;</code> (adding a new stock
to our ticker) and <code>&quot;stock-update&quot;</code> (updating the stock's listed price and
change amount). Finally, we define transformations on the incoming data of these
observables, formatting the data as needed.</p>
<p>In <code>ch11-code/stock-ticker.js</code>, we define our UI (DOM side effect) behavior as
methods on the <code>stockTickerUI</code> object. We also define a variety of helpers,
including <code>getElemAttr(..)</code>, <code>stripPrefix(..)</code>, and others. Finally, we
<code>subscribe(..)</code> to the two observables that provide us formatted data to render
to the DOM.</p>
<h2><a class="header" href="#stock-events" id="stock-events">Stock Events</a></h2>
<p>Let's look at the code in <code>ch11-code/stock-ticker-events.js</code>. We'll start with
some basic helpers:</p>
<pre><code class="language-js">function addStockName(stock) {
  return setProp(&quot;name&quot;, stock, stock.id);
}
function formatSign(val) {
  if (Number(val) &gt; 0) {
    return `+${val}`;
  }
  return val;
}
function formatCurrency(val) {
  return `$${val}`;
}
</code></pre>
<p>These pure functions should be pretty straightforward to interpret. Recall
<a href="chapter_4.html"><code>setProp(..)</code> from Chapter 4</a> actually
clones the object before setting the new property. That exercises the principle
we saw in Chapter 6: avoiding side effects by treating values as immutable even
if they're not.</p>
<p><code>addStockName(..)</code> is used to add a <code>name</code> property to a stock message object
that's equal to its <code>id</code>. The <code>name</code> value is later used as the visible stock
name in the widget.</p>
<p>When a stock message is received from the &quot;server&quot;, it'll look like:</p>
<pre><code class="language-js">{ id: &quot;AAPL&quot;, price: 121.7, change: 0.01 }
</code></pre>
<p>Prior to display in the DOM, the <code>price</code> needs to be formatted with
<code>formatCurrency(..)</code> (to look like <code>&quot;$121.70&quot;</code>), and the <code>change</code> needs to be
formatted with <code>formatChange(..)</code> (to look like <code>&quot;+0.01&quot;</code>). But we don't want to
mutate the message object, so we need a helper that formats both the numbers and
gives us a new stock object:</p>
<pre><code class="language-js">function formatStockNumbers(stock) {
  var stockDataUpdates = [
    [&quot;price&quot;, formatPrice(stock.price)],
    [&quot;change&quot;, formatChange(stock.change)]
  ];

  return reduce(function formatter(stock, [propName, val]) {
    return setProp(propName, stock, val);
  })(stock)(stockDataUpdates);
}
</code></pre>
<p>We create the <code>stockDataUpdates</code> array to hold tuples (just arrays) of the
property name and the new formatted value, for <code>price</code> and <code>change</code>
respectively. We <code>reduce(..)</code> (see <a href="chapter_9.html">Chapter 9</a>) over that
array, with the <code>stock</code> object as the <code>initialValue</code>. We destructure the tuple
into <code>propName</code> and <code>val</code>, and then return the <code>setProp(..)</code> call, which returns
a new cloned object with the property having been set.</p>
<p>Now let's define some more helpers:</p>
<pre><code class="language-js">var formatDecimal = unboundMethod(&quot;toFixed&quot;)(2);
var formatPrice = pipe(formatDecimal, formatCurrency);
var formatChange = pipe(formatDecimal, formatSign);
var processNewStock = pipe(addStockName, formatStockNumbers);
</code></pre>
<p>The <code>formatDecimal(..)</code> function takes a number (like <code>2.1</code>) and calls its
<code>toFixed( 2 )</code> method call. We use
<a href="chapter_9.html">Chapter 9's <code>unboundMethod(..)</code></a>
to create a standalone late-bound method.</p>
<p><code>formatPrice(..)</code>, <code>formatChange(..)</code>, and <code>processNewStock(..)</code> are all
compositions with <code>pipe(..)</code>, each composing a couple of operations
left-to-right (see <a href="chapter_4.html">Chapter 4</a>).</p>
<p>For creating our observables (see <a href="chapter_10.html">Chapter 10</a>) from
our event emitter, we're going to want a helper that's a curried (see
<a href="chapter_3.html">Chapter 3</a>) standalone of RxJS's
<code>Rx.Observable.fromEvent(..)</code>:</p>
<pre><code class="language-js">var makeObservableFromEvent = curry(Rx.Observable.fromEvent, 2)(server);
</code></pre>
<p>This function is specified to listen to the <code>server</code> (event emitter), and is
just waiting for an event name string to produce its observable. We have all the
pieces in place now to create observers for our two events, and to map-transform
those observers to format the incoming data:</p>
<pre><code class="language-js">var observableMapperFns = [processNewStock, formatStockNumbers];

var stockEventNames = [&quot;stock&quot;, &quot;stock-update&quot;];

var [newStocks, stockUpdates] = pipe(
  map(makeObservableFromEvent),
  curry(zip)(observableMapperFns),
  map(spreadArgs(mapObservable))
)(stockEventNames);
</code></pre>
<p>We start with <code>stockEventNames</code>, an array of event names
(<code>[&quot;stock&quot;,&quot;stock-update&quot;]</code>), then <code>map(..)</code> (see
<a href="chapter_9.html">Chapter 9</a>) that to a list of two observables, and <code>zip(..)</code>
(see <a href="chapter_9.html">Chapter 9</a>) that to a list of observable-mapper
functions, producing a list of tuples like <code>[ observable, mapperFn ]</code>. Finally,
we <code>map(..)</code> those tuples with <code>mapObservable(..)</code>, spreading out each tuple as
individual arguments using <code>spreadArgs(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>).</p>
<p>The final result is a list of two mapped observables, which we array-destructure
into the assignments for <code>newStocks</code> and <code>stockUpdates</code>, respectively.</p>
<p>That's it; that's our FP-Light approach to setting up our stock ticker event
observables! We'll subscribe to these two observables in
<code>ch11-code/stock-ticker.js</code>.</p>
<p>Take a step back and reflect on our usage of FP principles here. Did it make
sense? Can you see how we applied various concepts covered across the previous
chapters from this book? Can you think of other ways to accomplish these tasks?</p>
<p>More importantly, how would you have done it imperatively, and how do you think
those two approaches would have compared, broadly? Try that exercise. Write the
equivalent using well-established imperative approaches. If you're like me, the
imperative form will still feel more natural.</p>
<p>What you need to <em>get</em> before moving on is that you can <em>also</em> understand and
reason about the FP-style we just presented. Think about the shape (the inputs
and output) of each function and piece. Do you see how they fit together?</p>
<p>Keep practicing until this stuff clicks for you.</p>
<h2><a class="header" href="#stock-ticker-ui" id="stock-ticker-ui">Stock Ticker UI</a></h2>
<p>If you felt pretty comfortable with the FP of the last section, you're ready to
dig into <code>ch11-code/stock-ticker.js</code>. It's considerably more involved, so we'll
take our time to look at each piece in its entirety.</p>
<p>Let's start by defining some helpers that will assist in our DOM tasks:</p>
<pre><code class="language-js">function isTextNode(node) {
  return node &amp;&amp; node.nodeType == 3;
}
function getElemAttr(prop, elem) {
  return elem.getAttribute(prop);
}
function setElemAttr(elem, prop, val) {
  // !!SIDE EFFECTS!!
  return elem.setAttribute(prop, val);
}
function matchingStockId(id, node) {
  return getStockId(node) == id;
}
function isStockInfoChildElem(elem) {
  return /\bstock-/i.test(getClassName(elem));
}
function appendDOMChild(parentNode, childNode) {
  // !!SIDE EFFECTS!!
  parentNode.appendChild(childNode);
  return parentNode;
}
function setDOMContent(elem, html) {
  // !!SIDE EFFECTS!!
  elem.innerHTML = html;
  return elem;
}

var createElement = document.createElement.bind(document);

var getElemAttrByName = curry(getElemAttr, 2);
var getStockId = getElemAttrByName(&quot;data-stock-id&quot;);
var getClassName = getElemAttrByName(&quot;class&quot;);
var isMatchingStock = curry(matchingStockId, 2);
</code></pre>
<p>These should be mostly self-explanatory.</p>
<p>Notice that I called out the side effects of mutating a DOM element's state. We
can't as easily clone a DOM object and replace it, so we settle here for a side
effect of changing an existing one. At least if we have a bug in our DOM
rendering, we can easily search for those code comments to narrow in on likely
suspects.</p>
<p>Here are some other miscellaneous helpers:</p>
<pre><code class="language-js">function stripPrefix(prefixRegex, val) {
  return val.replace(prefixRegex, &quot;&quot;);
}

function listify(listOrItem) {
  if (!Array.isArray(listOrItem)) {
    return [listOrItem];
  }
  return listOrItem;
}
</code></pre>
<p>Let's define a helper to get the child nodes of a DOM element:</p>
<pre><code class="language-js">var getDOMChildren = pipe(
  listify,
  flatMap(pipe(curry(prop)(&quot;childNodes&quot;), Array.from))
);
</code></pre>
<p>First, we use <code>listify(..)</code> to ensure we have a list of elements (even if it's
only a single item in length). Recall
<a href="chapter_9.html"><code>flatMap(..)</code> from Chapter 9</a>, which maps a
list and then flattens a list-of-lists into a shallower list.</p>
<p>Our mapping function here maps from an element to its <code>childNodes</code> list, which
we make into a real array (instead of a live NodeList) with <code>Array.from(..)</code>.
These two functions are composed (via <code>pipe(..)</code>) into a single mapper function,
which is fusion (see <a href="chapter_9.html">Chapter 9</a>).</p>
<p>Now, let's use this <code>getDOMChildren(..)</code> helper to define utilities for
retrieving specific DOM elements in our widget:</p>
<pre><code class="language-js">function getStockElem(tickerElem, stockId) {
  return pipe(
    getDOMChildren,
    filterOut(isTextNode),
    filterIn(isMatchingStock(stockId))
  )(tickerElem);
}
function getStockInfoChildElems(stockElem) {
  return pipe(
    getDOMChildren,
    filterOut(isTextNode),
    filterIn(isStockInfoChildElem)
  )(stockElem);
}
</code></pre>
<p><code>getStockElem(..)</code> starts with the <code>tickerElem</code> DOM element for our widget,
retrieves its child elements, then filters to make sure we have the element
matching the specified stock identifier. <code>getStockInfoChildElems(..)</code> does
almost the same thing, except it starts with a stock element, and narrows with
different filters.</p>
<p>Both utilities filter out text nodes (since they don't work the same as real DOM
nodes), and both utilities return an array of DOM elements, even if it's just a
single element.</p>
<h3><a class="header" href="#main-api" id="main-api">Main API</a></h3>
<p>We'll use a <code>stockTickerUI</code> object to organize our three main UI manipulation
methods, like this:</p>
<pre><code class="language-js">var stockTickerUI = {
  updateStockElems(stockInfoChildElemList, data) {
    // ..
  },

  updateStock(tickerElem, data) {
    // ..
  },

  addStock(tickerElem, data) {
    // ..
  }
};
</code></pre>
<p>Let's first examine <code>updateStock(..)</code>, as it's the simplest of the three:</p>
<pre><code class="language-js">updateStock(tickerElem,data) {
    var getStockElemFromId = curry( getStockElem )( tickerElem );
    var stockInfoChildElemList = pipe(
        getStockElemFromId,
        getStockInfoChildElems
    )
    ( data.id );

    return stockTickerUI.updateStockElems(
        stockInfoChildElemList,
        data
    );
},
</code></pre>
<p>Currying the earlier helper <code>getStockElem(..)</code> with <code>tickerElem</code> gives us
<code>getStockElemFromId(..)</code>, which will receive <code>data.id</code>.</p>
<p>Via <code>pipe(..)</code>, the return value <code>getStockElemFromId(data.id)</code> is an <code>&lt;li&gt;</code>
element (actually, a list containing only that element), which is passed to
<code>getStockInfoChildElems(..)</code>.</p>
<p>The result is a list (<code>stockInfoChildElemList</code>) with the three child <code>&lt;span&gt;</code>
elements for the stock display info. We pass that list and the stock's <code>data</code>
message object along to <code>stockTickerUI.updateStockElems(..)</code> for actually
updating those three <code>&lt;span&gt;</code> elements with the new data.</p>
<p>Now let's look at how <code>stockTickerUI.updateStockElems(..)</code> is defined:</p>
<pre><code class="language-js">updateStockElems(stockInfoChildElemList,data) {
    var getDataVal = curry( reverseArgs( prop ), 2 )( data );
    var extractInfoChildElemVal = pipe(
        getClassName,
        curry( stripPrefix )( /\bstock-/i ),
        getDataVal
    );
    var orderedDataVals =
        map( extractInfoChildElemVal )( stockInfoChildElemList );
    var elemsValsTuples =
        filterOut( function updateValueMissing([infoChildElem,val]){
            return val === undefined;
        } )
        ( zip( stockInfoChildElemList, orderedDataVals ) );

    // !!SIDE EFFECTS!!
    compose( each, spreadArgs )
    ( setDOMContent )
    ( elemsValsTuples );
},
</code></pre>
<p>That's a fair bit to take in, I know. But we'll break it down statement by
statement.</p>
<p><code>getDataVal(..)</code> is bound to the <code>data</code> message object, having been curried
after argument-reversing, so it's now waiting for a property name to extract
from <code>data</code>.</p>
<p>Next, let's look at how <code>extractInfoChildElemVal(..)</code> is defined:</p>
<pre><code class="language-js">var extractInfoChildElemVal = pipe(
  getClassName,
  curry(stripPrefix)(/\bstock-/i),
  getDataVal
);
</code></pre>
<p>This function takes a DOM element, retrieves it DOM class, strips the <code>&quot;stock-&quot;</code>
prefix from that value, then uses that resulting value (<code>&quot;name&quot;</code>, <code>&quot;price&quot;</code>, or
<code>&quot;change&quot;</code>) as a property name to extract from the <code>data</code> object via
<code>getDataVal(..)</code>.</p>
<p>This may seem like a convoluted way to retrieve values from the <code>data</code> object.
But the purpose is to be able to extract those values from <code>data</code> in the same
order as the <code>&lt;span&gt;</code> elements appear in the <code>stockInfoChildElemList</code> list; we
accomplish this by using <code>extractInfoChildElem(..)</code> as the mapping function over
that list of DOM elements, calling the resulting list <code>orderedDataVals</code>.</p>
<p>Next, we're going to zip the list of <code>&lt;span&gt;</code>s back with the ordered data
values, producing tuples where the DOM element and the value to update it with
are paired up:</p>
<pre><code class="language-js">zip(stockInfoChildElemList, orderedDataVals);
</code></pre>
<p>An interesting wrinkle that wasn't at all obvious up to this point is that
because of how we defined the observable's transforms, new-stock message objects
will have a <code>name</code> property in <code>data</code> to match up with the
<code>&lt;span class=&quot;stock-name&quot;&gt;</code> element, but <code>name</code> will be absent on stock-update
message objects.</p>
<p>If the data message object doesn't have a property, we shouldn't update that
corresponding DOM element. So, we need to <code>filterOut(..)</code> any tuples where the
second position (the data value, in this case) is <code>undefined</code>:</p>
<pre><code class="language-js">var elemsValsTuples = filterOut(function updateValueMissing([
  infoChildElem,
  val
]) {
  return val === undefined;
})(zip(stockInfoChildElemList, orderedDataVals));
</code></pre>
<p>The result after this filtering is a list of tuples (like <code>[ &lt;span&gt;, &quot;..&quot; ]</code>)
ready for DOM content updating, which we assign to <code>elemsValsTuples</code>.</p>
<p><strong>Note:</strong> Since the <code>updateValueMissing(..)</code> predicate is specified inline here,
we're in control of its signature. Instead of using <code>spreadArgs(..)</code> to adapt it
to spread out a single array argument as two individual named parameters, we use
parameter array-destructuring in the function declaration
(<code>function updateValueMissing([infoChildElem,val]){ ..</code>); see
<a href="chapter_2.html">Chapter 2</a> for more information.</p>
<p>Finally, we need to update the DOM content of our <code>&lt;span&gt;</code> elements:</p>
<pre><code class="language-js">// !!SIDE EFFECTS!!
compose(each, spreadArgs)(setDOMContent)(elemsValsTuples);
</code></pre>
<p>We iterate this <code>elemsValsTuples</code> list with <code>each(..)</code> (see
<a href="chapter_9.html"><code>forEach(..)</code> discussion in Chapter 9</a>).</p>
<p>Instead of using <code>pipe(..)</code> as elsewhere, this composition uses <code>compose(..)</code>
(see <a href="chapter_4.html">Chapter 4</a>) to pass
<code>setDomContent(..)</code> into <code>spreadArgs(..)</code>, and then that is passed as the
iterator-function to <code>each(..)</code>. Each tuple is spread out as the arguments to
<code>setDOMContent(..)</code>, which then updates the DOM element accordingly.</p>
<p>That's two of the main UI methods down, one to go: <code>addStock(..)</code>. Let's define
it in its entirety, then we'll examine it step by step as before:</p>
<pre><code class="language-js">addStock(tickerElem,data) {
    var [stockElem, ...infoChildElems] = map(
        createElement
    )
    ( [ &quot;li&quot;, &quot;span&quot;, &quot;span&quot;, &quot;span&quot; ] );
    var attrValTuples = [
        [ [&quot;class&quot;,&quot;stock&quot;], [&quot;data-stock-id&quot;,data.id] ],
        [ [&quot;class&quot;,&quot;stock-name&quot;] ],
        [ [&quot;class&quot;,&quot;stock-price&quot;] ],
        [ [&quot;class&quot;,&quot;stock-change&quot;] ]
    ];
    var elemsAttrsTuples =
        zip( [stockElem, ...infoChildElems], attrValTuples );

    // !!SIDE EFFECTS!!
    each( function setElemAttrs([elem,attrValTupleList]){
        each(
            spreadArgs( partial( setElemAttr, elem ) )
        )
        ( attrValTupleList );
    } )
    ( elemsAttrsTuples );

    // !!SIDE EFFECTS!!
    stockTickerUI.updateStockElems( infoChildElems, data );
    reduce( appendDOMChild )( stockElem )( infoChildElems );
    appendDOMChild( tickerElem, stockElem );
}
</code></pre>
<p>This UI method needs to create the bare DOM structure for a new stock element,
and then use <code>stockTickerUI.updateStockElems(..)</code> to update its content. First:</p>
<pre><code class="language-js">var [stockElem, ...infoChildElems] = map(createElement)([
  &quot;li&quot;,
  &quot;span&quot;,
  &quot;span&quot;,
  &quot;span&quot;
]);
</code></pre>
<p>We create the parent <code>&lt;li&gt;</code> and the three children <code>&lt;span&gt;</code> elements, assigning
them respectively to <code>stockElem</code> and the <code>infoChildElems</code> list.</p>
<p>To initialize these elements with the appropriate DOM attributes, we create a
list of lists-of-tuples. Each item in the main list corresponds to the four DOM
elements, in order. Each sub-list contains tuples that represent attribute-value
pairs to be set on each corresponding DOM element, respectively:</p>
<pre><code class="language-js">var attrValTuples = [
  [
    [&quot;class&quot;, &quot;stock&quot;],
    [&quot;data-stock-id&quot;, data.id]
  ],
  [[&quot;class&quot;, &quot;stock-name&quot;]],
  [[&quot;class&quot;, &quot;stock-price&quot;]],
  [[&quot;class&quot;, &quot;stock-change&quot;]]
];
</code></pre>
<p>We now want to <code>zip(..)</code> a list of the four DOM elements with this
<code>attrValTuples</code> list:</p>
<pre><code class="language-js">var elemsAttrsTuples = zip([stockElem, ...infoChildElems], attrValTuples);
</code></pre>
<p>The structure of this list would now look like:</p>
<pre><code class="language-txt">[
    [ &lt;li&gt;, [ [&quot;class&quot;,&quot;stock&quot;], [&quot;data-stock-id&quot;,data.id] ] ],
    [ &lt;span&gt;, [ [&quot;class&quot;,&quot;stock-name&quot;] ] ],
    ..
]
</code></pre>
<p>If we wanted to imperatively process this kind of data structure to assign the
attribute-value tuples into each DOM element, we'd probably use nested
<code>for</code>-loops. Our FP approach will be similar, but with nested <code>each(..)</code>
iterations:</p>
<pre><code class="language-js">// !!SIDE EFFECTS!!
each(function setElemAttrs([elem, attrValTupleList]) {
  each(spreadArgs(partial(setElemAttr, elem)))(attrValTupleList);
})(elemsAttrsTuples);
</code></pre>
<p>The outer <code>each(..)</code> iterates the list of tuples, with each <code>elem</code> and its
associated <code>attrValTupleList</code> spread out as named parameters to
<code>setElemAttrs(..)</code> via parameter array-destructuring as explained earlier.</p>
<p>Inside this outer iteration &quot;loop&quot;, the sub-list of attribute-value tuples is
iterated with an inner <code>each(..)</code>. The inner iterator-function is an
arguments-spread (of each attribute-value tuple) for the partial-application of
<code>setElemAttr(..)</code> with <code>elem</code> as its first argument.</p>
<p>At this point, we have a list of <code>&lt;span&gt;</code> elements, each filled out with
attributes, but no <code>innerHTML</code> content. We set the <code>data</code> in the <code>&lt;span&gt;</code>
elements with <code>stockTickerUI.updateStockElems(..)</code>, the same as for a
stock-update event.</p>
<p>Now, we need to append these <code>&lt;span&gt;</code>s to the parent <code>&lt;li&gt;</code>, and we do that with
a <code>reduce(..)</code> (see <a href="chapter_9.html">Chapter 9</a>):</p>
<pre><code class="language-js">reduce(appendDOMChild)(stockElem)(infoChildElems);
</code></pre>
<p>Finally, a plain ol' DOM mutation side effect to append the new stock element to
the widget's DOM:</p>
<pre><code class="language-js">appendDOMChild(tickerElem, stockElem);
</code></pre>
<p>Phew! Did you follow all that? I recommend re-reading that discussion a few
times, and practicing with the code, before you move on.</p>
<h3><a class="header" href="#subscribing-to-observables" id="subscribing-to-observables">Subscribing to Observables</a></h3>
<p>Our last major task is to subscribe to the observables defined in
<code>ch11-code/stock-ticker-events.js</code>, attaching these subscriptions to the
appropriate main UI methods (<code>addStock(..)</code> and <code>updateStock(..)</code>).</p>
<p>First, we notice that those methods each expect <code>tickerElem</code> as first parameter.
Let's make a list (<code>stockTickerUIMethodsWithDOMContext</code>) that encapsulates the
ticker widget's DOM element with each of these two methods, via partial
application (aka, <a href="chapter_2.html">closure; see Chapter 2</a>):</p>
<pre><code class="language-js">var ticker = document.getElementById(&quot;stock-ticker&quot;);

var stockTickerUIMethodsWithDOMContext = map(
  pipe(partialRight, unary)(partial, ticker)
)([stockTickerUI.addStock, stockTickerUI.updateStock]);
</code></pre>
<p>First, we use <code>partialRight(..)</code> (right-partial application) on the
<code>partial(..)</code> utility, presetting its right-most argument to be <code>ticker</code>. Then
we pass this right-partially-applied <code>partial(..)</code> function through <code>unary(..)</code>
to protect it from receiving undesired extra arguments from <code>map(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>), via <code>pipe(..)</code>. The result is
a mapper function which is expecting a function to partially-apply (with one
argument: <code>ticker</code>). We use that mapper function to <code>map(..)</code> the
<code>stockTickerUI.addStock(..)</code> and <code>stockTickerUI.updateStock(..)</code> functions,
respectively.</p>
<p>The result of <code>map(..)</code> is the array <code>stockTickerUIMethodsWithDOMContext</code>, which
holds the two partially applied functions; these two functions are now suitable
as observable-subscription handlers.</p>
<p>Though we're using closure to preserve the <code>ticker</code> state with these two
functions, in <a href="chapter_7.html">Chapter 7</a> we saw that we could have &quot;kept&quot; this
<code>ticker</code> value as a property on an object, perhaps via <code>this</code>-binding each
function to <code>stockTickerUI</code>. Because <code>this</code> is an implicit input (see
<a href="chapter_2.html">Chapter 2</a>) and that's generally not as preferable, I
chose the closure form over the object form.</p>
<p>To subscribe to the observables, let's make an unbound-method helper:</p>
<pre><code class="language-js">var subscribeToObservable = pipe(unboundMethod, uncurry)(&quot;subscribe&quot;);
</code></pre>
<p><code>unboundMethod(&quot;subscribe&quot;)</code> is curried so we <code>uncurry(..)</code> it (see
<a href="chapter_3.html">Chapter 3</a>).</p>
<p>Now, we just need a list of the observables, so we can <code>zip(..)</code> that with the
list of DOM-bound UI methods; the resulting tuples will then include both the
observable and the listener function to subscribe to it. We process each tuple
with <code>each(..)</code> and use <code>spreadArgs(..)</code> (see
<a href="chapter_3.html">Chapter 3</a>) to spread the tuple's
contents out as the two arguments to <code>subscribeToObservable(..)</code>:</p>
<pre><code class="language-js">var stockTickerObservables = [newStocks, stockUpdates];

// !!SIDE EFFECTS!!
each(spreadArgs(subscribeToObservable))(
  zip(stockTickerUIMethodsWithDOMContext, stockTickerObservables)
);
</code></pre>
<p>We're technically mutating the state of those observables to subscribe to them,
and moreover, we're using <code>each(..)</code> -- pretty much always associated with side
effects! -- so we call that out with our code comment.</p>
<p>That's it! Spend the same time reviewing and comparing this code to its
imperative alternatives as we did with the stock ticker events discussion
earlier. Really, take your time. I know it's been a lot to read, but your whole
journey through this book comes down to being able to digest and understand this
kind of code.</p>
<p>How do you feel now about using FP in a balanced way in your JavaScript? Keep
practicing just like we did here!</p>
<h2><a class="header" href="#summary-10" id="summary-10">Summary</a></h2>
<p>The example code we discussed in this chapter should be viewed in its entirety,
not just in the broken-out snippets as presented in this chapter. Stop right now
and go read through the full files. Make sure you understand them in full
context.</p>
<p>This example code is not meant to be prescriptive of exactly how you should
write your code. It's meant to be more descriptive of how to think about and
begin approaching such tasks with FP-Light techniques. It's meant to draw as
many correlations between the different concepts of this book as possible. It's
meant to explore FP in the context of more &quot;real&quot; code than we typically afford
for a single snippet.</p>
<p>I am quite sure that as I learn FP better on my own journey, I will continue to
improve how I would write this example code. What you see now is just a snapshot
on my curve. I hope it will just be such for you, as well.</p>
<p>As we draw the main text of this book to a close, I want to remind you of that
readability curve that I <a href="chapter_1.html">shared back in Chapter 1</a>:</p>
<p align="center">
    <img alt="figure" src="images/fig17.png" width="50%">
</p>
<p>It's so important that you internalize the truth of that graph and set realistic
expectations for yourself on this journey to learn and apply FP principles to
your JavaScript. You've made it this far, and that's quite an accomplishment.</p>
<p>But don't stop when you dip toward that trough of despair and disenchantment.
What's waiting on the other side is a way of thinking about and communicating
with your code that's more readable, understandable, verifiable, and ultimately,
more reliable.</p>
<p>I can't think of any more noble goal for us as developers to strive toward.
Thanks for sharing in my journey to learn FP principles in JavaScript. I hope
your experience is as rich and hopeful as mine!</p>
<h1><a class="header" href="#functional-light-javascript-13" id="functional-light-javascript-13">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#appendix-a-transducing" id="appendix-a-transducing">Appendix A: Transducing</a></h1>
<p>Transducing is a more advanced technique than we've covered in this book. It
extends many of the concepts from <a href="chapter_9.html">Chapter 9</a> on list operations.</p>
<p>I wouldn't necessarily call this topic strictly &quot;Functional-Light&quot;, but more
like a bonus on top. I've presented this as an appendix because you might very
well need to skip the discussion for now and come back to it once you feel
fairly comfortable with -- and make sure you've practiced! -- the main book
concepts.</p>
<p>To be honest, even after teaching transducing many times, and writing this
chapter, I am still trying to fully wrap my brain around this technique. So
don't feel bad if it twists you up. Bookmark this appendix and come back when
you're ready.</p>
<p>Transducing means transforming with reduction.</p>
<p>I know that may sound like a jumble of words that confuses more than it
clarifies. But let's take a look at how powerful it can be. I actually think
it's one of the best illustrations of what you can do once you grasp the
principles of Functional-Light Programming.</p>
<p>As with the rest of this book, my approach is to first explain <em>why</em>, then
<em>how</em>, then finally boil it down to a simplified, repeatable <em>what</em>. That's
often the reverse of how many teach, but I think you'll learn the topic more
deeply this way.</p>
<h2><a class="header" href="#why-first" id="why-first">Why, First</a></h2>
<p>Let's start by extending a
<a href="chapter_3.html">scenario we covered back in Chapter 3</a>,
testing words to see if they're short enough and/or long enough:</p>
<pre><code class="language-js">function isLongEnough(str) {
  return str.length &gt;= 5;
}

function isShortEnough(str) {
  return str.length &lt;= 10;
}
</code></pre>
<p>In
<a href="chapter_3.html">Chapter 3, we used these predicate functions</a>
to test a single word. Then in Chapter 9, we learned how to repeat such tests
<a href="chapter_9.html">using list operations like <code>filter(..)</code></a>. For example:</p>
<pre><code class="language-js">var words = [&quot;You&quot;, &quot;have&quot;, &quot;written&quot;, &quot;something&quot;, &quot;very&quot;, &quot;interesting&quot;];

words.filter(isLongEnough).filter(isShortEnough);
// [&quot;written&quot;,&quot;something&quot;]
</code></pre>
<p>It may not be obvious, but this pattern of separate adjacent list operations has
some non-ideal characteristics. When we're dealing with only a single array of a
small number of values, everything is fine. But if there were lots of values in
the array, each <code>filter(..)</code> processing the list separately can slow down a bit
more than we'd like.</p>
<p>A similar performance problem arises when our arrays are async/lazy (aka
Observables), processing values over time in response to events (see
<a href="chapter_10.html">Chapter 10</a>). In this scenario, only a single value comes down
the event stream at a time, so processing that discrete value with two separate
<code>filter(..)</code>s function calls isn't really such a big deal.</p>
<p>But what's not obvious is that each <code>filter(..)</code> method produces a separate
observable. The overhead of pumping a value out of one observable into another
can really add up. That's especially true since in these cases, it's not
uncommon for thousands or millions of values to be processed; even such small
overhead costs add up quickly.</p>
<p>The other downside is readability, especially when we need to repeat the same
series of operations against multiple lists (or Observables). For example:</p>
<pre><code class="language-js">zip(
  list1.filter(isLongEnough).filter(isShortEnough),
  list2.filter(isLongEnough).filter(isShortEnough),
  list3.filter(isLongEnough).filter(isShortEnough)
);
</code></pre>
<p>Repetitive, right?</p>
<p>Wouldn't it be better (both for readability and performance) if we could combine
the <code>isLongEnough(..)</code> predicate with the <code>isShortEnough(..)</code> predicate? You
could do so manually:</p>
<pre><code class="language-js">function isCorrectLength(str) {
  return isLongEnough(str) &amp;&amp; isShortEnough(str);
}
</code></pre>
<p>But that's not the FP way!</p>
<p>In <a href="chapter_9.html">Chapter 9, we talked about fusion</a> -- composing
adjacent mapping functions. Recall:</p>
<pre><code class="language-js">words.map(pipe(removeInvalidChars, upper, elide));
</code></pre>
<p>Unfortunately, combining adjacent predicate functions doesn't work as easily as
combining adjacent mapping functions. To understand why, think about the &quot;shape&quot;
of the predicate function -- a sort of academic way of describing the signature
of inputs and output. It takes a single value in, and it returns a <code>true</code> or a
<code>false</code>.</p>
<p>If you tried <code>isShortEnough(isLongEnough(str))</code>, it wouldn't work properly.
<code>isLongEnough(..)</code> will return <code>true</code>/<code>false</code>, not the string value that
<code>isShortEnough(..)</code> is expecting. Bummer.</p>
<p>A similar frustration exists trying to compose two adjacent reducer functions.
The &quot;shape&quot; of a reducer is a function that receives two values as input, and
returns a single combined value. The output of a reducer as a single value is
not suitable for input to another reducer expecting two inputs.</p>
<p>Moreover, the <code>reduce(..)</code> helper takes an optional <code>initialValue</code> input.
Sometimes this can be omitted, but sometimes it has to be passed in. That even
further complicates composition, since one reduction might need one
<code>initialValue</code> and the other reduction might seem like it needs a different
<code>initialValue</code>. How can we possibly do that if we only make one <code>reduce(..)</code>
call with some sort of composed reducer?</p>
<p>Consider a chain like this:</p>
<pre><code class="language-js">words
  .map(strUppercase)
  .filter(isLongEnough)
  .filter(isShortEnough)
  .reduce(strConcat, &quot;&quot;);
// &quot;WRITTENSOMETHING&quot;
</code></pre>
<p>Can you envision a composition that includes all of these steps:
<code>map(strUppercase)</code>, <code>filter(isLongEnough)</code>, <code>filter(isShortEnough)</code>,
<code>reduce(strConcat)</code>? The shape of each operator is different, so they won't
directly compose together. We need to bend their shapes a little bit to fit them
together.</p>
<p>Hopefully these observations have illustrated why simple fusion-style
composition isn't up to the task. We need a more powerful technique, and
transducing is that tool.</p>
<h2><a class="header" href="#how-next" id="how-next">How, Next</a></h2>
<p>Let's talk about how we might derive a composition of mappers, predicates,
and/or reducers.</p>
<p>Don't get too overwhelmed: you won't have to go through all these mental steps
we're about to explore in your own programming. Once you understand and can
recognize the problem transducing solves, you'll be able to just jump straight
to using a <code>transduce(..)</code> utility from a FP library and move on with the rest
of your application!</p>
<p>Let's jump in.</p>
<h3><a class="header" href="#expressing-mapfilter-as-reduce" id="expressing-mapfilter-as-reduce">Expressing Map/Filter as Reduce</a></h3>
<p>The first trick we need to perform is expressing our <code>filter(..)</code> and <code>map(..)</code>
calls as <code>reduce(..)</code> calls. Recall
<a href="chapter_9.html">how we did that in Chapter 9</a>:</p>
<pre><code class="language-js">function strUppercase(str) {
  return str.toUpperCase();
}
function strConcat(str1, str2) {
  return str1 + str2;
}

function strUppercaseReducer(list, str) {
  list.push(strUppercase(str));
  return list;
}

function isLongEnoughReducer(list, str) {
  if (isLongEnough(str)) list.push(str);
  return list;
}

function isShortEnoughReducer(list, str) {
  if (isShortEnough(str)) list.push(str);
  return list;
}

words
  .reduce(strUppercaseReducer, [])
  .reduce(isLongEnoughReducer, [])
  .reduce(isShortEnoughReducer, [])
  .reduce(strConcat, &quot;&quot;);
// &quot;WRITTENSOMETHING&quot;
</code></pre>
<p>That's a decent improvement. We now have four adjacent <code>reduce(..)</code> calls
instead of a mixture of three different methods all with different shapes. We
still can't just <code>compose(..)</code> those four reducers, however, because they accept
two arguments instead of one.</p>
<p><a name="cheating"></a></p>
<p>In <a href="chapter_9.html">Chapter 9, we sort of cheated</a>
and used <code>list.push(..)</code> to mutate as a side effect rather than creating a whole
new array to concatenate onto. Let's step back and be a bit more formal for now:</p>
<pre><code class="language-js">function strUppercaseReducer(list, str) {
  return [...list, strUppercase(str)];
}

function isLongEnoughReducer(list, str) {
  if (isLongEnough(str)) return [...list, str];
  return list;
}

function isShortEnoughReducer(list, str) {
  if (isShortEnough(str)) return [...list, str];
  return list;
}
</code></pre>
<p>Later, we'll revisit whether creating a new array (e.g., <code>[...list,str]</code>) to
concatenate onto is necessary here or not.</p>
<h3><a class="header" href="#parameterizing-the-reducers" id="parameterizing-the-reducers">Parameterizing the Reducers</a></h3>
<p>Both filter reducers are almost identical, except they use a different predicate
function. Let's parameterize that so we get one utility that can define any
filter-reducer:</p>
<pre><code class="language-js">function filterReducer(predicateFn) {
  return function reducer(list, val) {
    if (predicateFn(val)) return [...list, val];
    return list;
  };
}

var isLongEnoughReducer = filterReducer(isLongEnough);
var isShortEnoughReducer = filterReducer(isShortEnough);
</code></pre>
<p>Let's do the same parameterization of the <code>mapperFn(..)</code> for a utility to
produce any map-reducer:</p>
<pre><code class="language-js">function mapReducer(mapperFn) {
  return function reducer(list, val) {
    return [...list, mapperFn(val)];
  };
}

var strToUppercaseReducer = mapReducer(strUppercase);
</code></pre>
<p>Our chain still looks the same:</p>
<pre><code class="language-js">words
  .reduce(strUppercaseReducer, [])
  .reduce(isLongEnoughReducer, [])
  .reduce(isShortEnoughReducer, [])
  .reduce(strConcat, &quot;&quot;);
</code></pre>
<h3><a class="header" href="#extracting-common-combination-logic" id="extracting-common-combination-logic">Extracting Common Combination Logic</a></h3>
<p>Look very closely at the preceding <code>mapReducer(..)</code> and <code>filterReducer(..)</code>
functions. Do you spot the common functionality shared in each?</p>
<p>This part:</p>
<pre><code class="language-js">return [ ...list, .. ];

// or
return list;
</code></pre>
<p>Let's define a helper for that common logic. But what shall we call it?</p>
<pre><code class="language-js">function WHATSITCALLED(list, val) {
  return [...list, val];
}
</code></pre>
<p>If you examine what that <code>WHATSITCALLED(..)</code> function does, it takes two values
(an array and another value) and it &quot;combines&quot; them by creating a new array and
concatenating the value onto the end of it. Very uncreatively, we could name
this <code>listCombine(..)</code>:</p>
<pre><code class="language-js">function listCombine(list, val) {
  return [...list, val];
}
</code></pre>
<p>Let's now re-define our reducer helpers to use <code>listCombine(..)</code>:</p>
<pre><code class="language-js">function mapReducer(mapperFn) {
  return function reducer(list, val) {
    return listCombine(list, mapperFn(val));
  };
}

function filterReducer(predicateFn) {
  return function reducer(list, val) {
    if (predicateFn(val)) return listCombine(list, val);
    return list;
  };
}
</code></pre>
<p>Our chain still looks the same (so we won't repeat it).</p>
<h3><a class="header" href="#parameterizing-the-combination" id="parameterizing-the-combination">Parameterizing the Combination</a></h3>
<p>Our simple <code>listCombine(..)</code> utility is only one possible way that we might
combine two values. Let's parameterize the use of it to make our reducers more
generalized:</p>
<pre><code class="language-js">function mapReducer(mapperFn, combinerFn) {
  return function reducer(list, val) {
    return combinerFn(list, mapperFn(val));
  };
}

function filterReducer(predicateFn, combinerFn) {
  return function reducer(list, val) {
    if (predicateFn(val)) return combinerFn(list, val);
    return list;
  };
}
</code></pre>
<p>To use this form of our helpers:</p>
<pre><code class="language-js">var strToUppercaseReducer = mapReducer(strUppercase, listCombine);
var isLongEnoughReducer = filterReducer(isLongEnough, listCombine);
var isShortEnoughReducer = filterReducer(isShortEnough, listCombine);
</code></pre>
<p>Defining these utilities to take two arguments instead of one is less convenient
for composition, so let's use our <code>curry(..)</code> approach:</p>
<pre><code class="language-js">var curriedMapReducer = curry(function mapReducer(mapperFn, combinerFn) {
  return function reducer(list, val) {
    return combinerFn(list, mapperFn(val));
  };
});

var curriedFilterReducer = curry(function filterReducer(
  predicateFn,
  combinerFn
) {
  return function reducer(list, val) {
    if (predicateFn(val)) return combinerFn(list, val);
    return list;
  };
});

var strToUppercaseReducer = curriedMapReducer(strUppercase)(listCombine);
var isLongEnoughReducer = curriedFilterReducer(isLongEnough)(listCombine);
var isShortEnoughReducer = curriedFilterReducer(isShortEnough)(listCombine);
</code></pre>
<p>That looks a bit more verbose, and probably doesn't seem very useful.</p>
<p>But this is actually necessary to get to the next step of our derivation.
Remember, our ultimate goal here is to be able to <code>compose(..)</code> these reducers.
We're almost there.</p>
<h3><a class="header" href="#composing-curried" id="composing-curried">Composing Curried</a></h3>
<p>This step is the trickiest of all to visualize. So read slowly and pay close
attention here.</p>
<p>Let's consider the curried functions from earlier, but without the
<code>listCombine(..)</code> function having been passed in to each:</p>
<pre><code class="language-js">var x = curriedMapReducer(strUppercase);
var y = curriedFilterReducer(isLongEnough);
var z = curriedFilterReducer(isShortEnough);
</code></pre>
<p>Think about the shape of all three of these intermediate functions, <code>x(..)</code>,
<code>y(..)</code>, and <code>z(..)</code>. Each one expects a single combination function, and
produces a reducer function with it.</p>
<p>Remember, if we wanted the independent reducers from all these, we could do:</p>
<pre><code class="language-js">var upperReducer = x(listCombine);
var longEnoughReducer = y(listCombine);
var shortEnoughReducer = z(listCombine);
</code></pre>
<p>But what would you get back if you called <code>y(z)</code>, instead of <code>y(listCombine)</code>?
Basically, what happens when passing <code>z</code> in as the <code>combinerFn(..)</code> for the
<code>y(..)</code> call? That returned reducer function internally looks kinda like this:</p>
<pre><code class="language-js">function reducer(list, val) {
  if (isLongEnough(val)) return z(list, val);
  return list;
}
</code></pre>
<p>See the <code>z(..)</code> call inside? That should look wrong to you, because the <code>z(..)</code>
function is supposed to receive only a single argument (a <code>combinerFn(..)</code>), not
two arguments (<code>list</code> and <code>val</code>). The shapes don't match. That won't work.</p>
<p>Let's instead look at the composition <code>y(z(listCombine))</code>. We'll break that down
into two separate steps:</p>
<pre><code class="language-js">var shortEnoughReducer = z(listCombine);
var longAndShortEnoughReducer = y(shortEnoughReducer);
</code></pre>
<p>We create <code>shortEnoughReducer(..)</code>, then we pass <em>it</em> in as the <code>combinerFn(..)</code>
to <code>y(..)</code> instead of calling <code>y(listCombine)</code>; this new call produces
<code>longAndShortEnoughReducer(..)</code>. Re-read that a few times until it clicks.</p>
<p>Now consider: what do <code>shortEnoughReducer(..)</code> and
<code>longAndShortEnoughReducer(..)</code> look like internally? Can you see them in your
mind?</p>
<pre><code class="language-js">// shortEnoughReducer, from calling z(..):
function reducer(list, val) {
  if (isShortEnough(val)) return listCombine(list, val);
  return list;
}

// longAndShortEnoughReducer, from calling y(..):
function reducer(list, val) {
  if (isLongEnough(val)) return shortEnoughReducer(list, val);
  return list;
}
</code></pre>
<p>Do you see how <code>shortEnoughReducer(..)</code> has taken the place of <code>listCombine(..)</code>
inside <code>longAndShortEnoughReducer(..)</code>? Why does that work?</p>
<p>Because <strong>the shape of a <code>reducer(..)</code> and the shape of <code>listCombine(..)</code> are
the same.</strong> In other words, a reducer can be used as a combination function for
another reducer; that's how they compose! The <code>listCombine(..)</code> function makes
the first reducer, then <em>that reducer</em> can be used as the combination function
to make the next reducer, and so on.</p>
<p>Let's test out our <code>longAndShortEnoughReducer(..)</code> with a few different values:</p>
<pre><code class="language-js">longAndShortEnoughReducer([], &quot;nope&quot;);
// []

longAndShortEnoughReducer([], &quot;hello&quot;);
// [&quot;hello&quot;]

longAndShortEnoughReducer([], &quot;hello world&quot;);
// []
</code></pre>
<p>The <code>longAndShortEnoughReducer(..)</code> utility is filtering out both values that
are not long enough and values that are not short enough, and it's doing both
these filterings in the same step. It's a composed reducer!</p>
<p>Take another moment to let that sink in. It still kinda blows my mind.</p>
<p>Now, to bring <code>x(..)</code> (the uppercase reducer producer) into the composition:</p>
<pre><code class="language-js">var longAndShortEnoughReducer = y(z(listCombine));
var upperLongAndShortEnoughReducer = x(longAndShortEnoughReducer);
</code></pre>
<p>As the name <code>upperLongAndShortEnoughReducer(..)</code> implies, it does all three
steps at once -- a mapping and two filters! What it kinda look likes internally:</p>
<pre><code class="language-js">// upperLongAndShortEnoughReducer:
function reducer(list, val) {
  return longAndShortEnoughReducer(list, strUppercase(val));
}
</code></pre>
<p>A string <code>val</code> is passed in, uppercased by <code>strUppercase(..)</code> and then passed
along to <code>longAndShortEnoughReducer(..)</code>. <em>That</em> function only conditionally
adds this uppercased string to the <code>list</code> if it's both long enough and short
enough. Otherwise, <code>list</code> will remain unchanged.</p>
<p>It took my brain weeks to fully understand the implications of that juggling. So
don't worry if you need to stop here and re-read a few (dozen!) times to get it.
Take your time.</p>
<p>Now let's verify:</p>
<pre><code class="language-js">upperLongAndShortEnoughReducer([], &quot;nope&quot;);
// []

upperLongAndShortEnoughReducer([], &quot;hello&quot;);
// [&quot;HELLO&quot;]

upperLongAndShortEnoughReducer([], &quot;hello world&quot;);
// []
</code></pre>
<p>This reducer is the composition of the map and both filters! That's amazing!</p>
<p>Let's recap where we're at so far:</p>
<pre><code class="language-js">var x = curriedMapReducer(strUppercase);
var y = curriedFilterReducer(isLongEnough);
var z = curriedFilterReducer(isShortEnough);

var upperLongAndShortEnoughReducer = x(y(z(listCombine)));

words.reduce(upperLongAndShortEnoughReducer, []);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]
</code></pre>
<p>That's pretty cool. But let's make it even better.</p>
<p><code>x(y(z( .. )))</code> is a composition. Let's skip the intermediate <code>x</code> / <code>y</code> / <code>z</code>
variable names, and just express that composition directly:</p>
<pre><code class="language-js">var composition = compose(
  curriedMapReducer(strUppercase),
  curriedFilterReducer(isLongEnough),
  curriedFilterReducer(isShortEnough)
);

var upperLongAndShortEnoughReducer = composition(listCombine);

words.reduce(upperLongAndShortEnoughReducer, []);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]
</code></pre>
<p>Think about the flow of &quot;data&quot; in that composed function:</p>
<ol>
<li><code>listCombine(..)</code> flows in as the combination function to make the
filter-reducer for <code>isShortEnough(..)</code>.</li>
<li><em>That</em> resulting reducer function then flows in as the combination function
to make the filter-reducer for <code>isLongEnough(..)</code>.</li>
<li>Finally, <em>that</em> resulting reducer function flows in as the combination
function to make the map-reducer for <code>strUppercase(..)</code>.</li>
</ol>
<p>In the previous snippet, <code>composition(..)</code> is a composed function expecting a
combination function to make a reducer; <code>composition(..)</code> here has a special
name: transducer. Providing the combination function to a transducer produces
the composed reducer:</p>
<pre><code class="language-js">var transducer = compose(
  curriedMapReducer(strUppercase),
  curriedFilterReducer(isLongEnough),
  curriedFilterReducer(isShortEnough)
);

words.reduce(transducer(listCombine), []);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]
</code></pre>
<p><strong>Note:</strong> We should make an observation about the <code>compose(..)</code> order in the
previous two snippets, which may be confusing. Recall that in our original
example chain, we <code>map(strUppercase)</code> and then <code>filter(isLongEnough)</code> and
finally <code>filter(isShortEnough)</code>; those operations indeed happen in that order.
But in <a href="chapter_4.html">Chapter 4</a>, we learned that
<code>compose(..)</code> typically has the effect of running its functions in reverse order
of listing. So why don't we need to reverse the order <em>here</em> to get the same
desired outcome? The abstraction of the <code>combinerFn(..)</code> from each reducer
reverses the effective applied order of operations under the hood. So
counter-intuitively, when composing a transducer, you actually want to list them
in desired order of execution!</p>
<h4><a class="header" href="#list-combination-pure-vs-impure" id="list-combination-pure-vs-impure">List Combination: Pure vs. Impure</a></h4>
<p>As a quick aside, let's revisit our <code>listCombine(..)</code> combination function
implementation:</p>
<pre><code class="language-js">function listCombine(list, val) {
  return [...list, val];
}
</code></pre>
<p>While this approach is pure, it has negative consequences for performance: for
each step in the reduction, we're creating a whole new array to append the value
onto, effectively throwing away the previous array. That's a lot of arrays being
created and thrown away, which is not only bad for CPU but also GC memory churn.</p>
<p>By contrast, look again at the better-performing but impure version:</p>
<pre><code class="language-js">function listCombine(list, val) {
  list.push(val);
  return list;
}
</code></pre>
<p>Thinking about <code>listCombine(..)</code> in isolation, there's no question it's impure
and that's usually something we'd want to avoid. However, there's a bigger
context we should consider.</p>
<p><code>listCombine(..)</code> is not a function we interact with at all. We don't directly
use it anywhere in the program; instead, we let the transducing process use it.</p>
<p>Back in <a href="chapter_5.html">Chapter 5</a>, we asserted that our goal with reducing side
effects and defining pure functions was only that we expose pure functions to
the API level of functions we'll use throughout our program. We observed that
under the covers, inside a pure function, it can cheat for performance sake all
it wants, as long as it doesn't violate the external contract of purity.</p>
<p><code>listCombine(..)</code> is more an internal implementation detail of the transducing
-- in fact, it'll often be provided by the transducing library for you! --
rather than a top-level method you'd interact with on a normal basis throughout
your program.</p>
<p>Bottom line: I think it's perfectly acceptable, and advisable even, to use the
performance-optimal impure version of <code>listCombine(..)</code>. Just make sure you
document that it's impure with a code comment!</p>
<h3><a class="header" href="#alternative-combination" id="alternative-combination">Alternative Combination</a></h3>
<p>So far, this is what we've derived with transducing:</p>
<pre><code class="language-js">words.reduce(transducer(listCombine), []).reduce(strConcat, &quot;&quot;);
// WRITTENSOMETHING
</code></pre>
<p>That's pretty good, but we have one final trick up our sleeve with transducing.
And frankly, I think this part is what makes all this mental effort you've
expended thus far, actually worth it.</p>
<p>Can we somehow &quot;compose&quot; these two <code>reduce(..)</code> calls to get it down to just one
<code>reduce(..)</code>? Unfortunately, we can't just add <code>strConcat(..)</code> into the
<code>compose(..)</code> call; because it's a reducer and not a combination-expecting
function, its shape is not correct for the composition.</p>
<p>But let's look at these two functions side by side:</p>
<pre><code class="language-js">function strConcat(str1, str2) {
  return str1 + str2;
}

function listCombine(list, val) {
  list.push(val);
  return list;
}
</code></pre>
<p>If you squint your eyes, you can almost see how these two functions are
interchangeable. They operate with different data types, but conceptually they
do the same thing: combine two values into one.</p>
<p>In other words, <code>strConcat(..)</code> is a combination function!</p>
<p>That means we can use <em>it</em> instead of <code>listCombine(..)</code> if our end goal is to
get a string concatenation rather than a list:</p>
<pre><code class="language-js">words.reduce(transducer(strConcat), &quot;&quot;);
// WRITTENSOMETHING
</code></pre>
<p>Boom! That's transducing for you. I won't actually drop the mic here, but just
gently set it down...</p>
<h2><a class="header" href="#what-finally" id="what-finally">What, Finally</a></h2>
<p>Take a deep breath. That was a lot to digest.</p>
<p>Clearing our brains for a minute, let's turn our attention back to just using
transducing in our applications without jumping through all those mental hoops
to derive how it works.</p>
<p>Recall the helpers we defined earlier; let's rename them for clarity:</p>
<pre><code class="language-js">var transduceMap = curry(function mapReducer(mapperFn, combinerFn) {
  return function reducer(list, v) {
    return combinerFn(list, mapperFn(v));
  };
});

var transduceFilter = curry(function filterReducer(predicateFn, combinerFn) {
  return function reducer(list, v) {
    if (predicateFn(v)) return combinerFn(list, v);
    return list;
  };
});
</code></pre>
<p>Also recall that we use them like this:</p>
<pre><code class="language-js">var transducer = compose(
  transduceMap(strUppercase),
  transduceFilter(isLongEnough),
  transduceFilter(isShortEnough)
);
</code></pre>
<p><code>transducer(..)</code> still needs a combination function (like <code>listCombine(..)</code> or
<code>strConcat(..)</code>) passed to it to produce a transduce-reducer function, which can
then be used (along with an initial value) in <code>reduce(..)</code>.</p>
<p>But to express all these transducing steps more declaratively, let's make a
<code>transduce(..)</code> utility that does these steps for us:</p>
<pre><code class="language-js">function transduce(transducer, combinerFn, initialValue, list) {
  var reducer = transducer(combinerFn);
  return list.reduce(reducer, initialValue);
}
</code></pre>
<p>Here's our running example, cleaned up:</p>
<pre><code class="language-js">var transducer = compose(
  transduceMap(strUppercase),
  transduceFilter(isLongEnough),
  transduceFilter(isShortEnough)
);

transduce(transducer, listCombine, [], words);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]

transduce(transducer, strConcat, &quot;&quot;, words);
// WRITTENSOMETHING
</code></pre>
<p>Not bad, huh!? See the <code>listCombine(..)</code> and <code>strConcat(..)</code> functions used
interchangeably as combination functions?</p>
<h3><a class="header" href="#transducersjs" id="transducersjs">Transducers.js</a></h3>
<p>Finally, let's illustrate our running example using the
<a href="https://github.com/cognitect-labs/transducers-js"><code>transducers-js</code> library</a>:</p>
<pre><code class="language-js">var transformer = transducers.comp(
  transducers.map(strUppercase),
  transducers.filter(isLongEnough),
  transducers.filter(isShortEnough)
);

transducers.transduce(transformer, listCombine, [], words);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]

transducers.transduce(transformer, strConcat, &quot;&quot;, words);
// WRITTENSOMETHING
</code></pre>
<p>Looks almost identical to above.</p>
<p><strong>Note:</strong> The preceding snippet uses <code>transformers.comp(..)</code> because the library
provides it, but in this case our
<a href="chapter_4.html"><code>compose(..)</code> from Chapter 4</a> would
produce the same outcome. In other words, composition itself isn't a
transducing-sensitive operation.</p>
<p>The composed function in this snippet is named <code>transformer</code> instead of
<code>transducer</code>. That's because if we call <code>transformer( listCombine )</code> (or
<code>transformer( strConcat )</code>), we won't get a straight-up transduce-reducer
function as earlier.</p>
<p><code>transducers.map(..)</code> and <code>transducers.filter(..)</code> are special helpers that
adapt regular predicate or mapper functions into functions that produce a
special transform object (with the transducer function wrapped underneath); the
library uses these transform objects for transducing. The extra capabilities of
this transform object abstraction are beyond what we'll explore, so consult the
library's documentation for more information.</p>
<p>Because calling <code>transformer(..)</code> produces a transform object and not a typical
binary transduce-reducer function, the library also provides <code>toFn(..)</code> to adapt
the transform object to be useable by native array <code>reduce(..)</code>:</p>
<pre><code class="language-js">words.reduce(transducers.toFn(transformer, strConcat), &quot;&quot;);
// WRITTENSOMETHING
</code></pre>
<p><code>into(..)</code> is another provided helper that automatically selects a default
combination function based on the type of empty/initial value specified:</p>
<pre><code class="language-js">transducers.into([], transformer, words);
// [&quot;WRITTEN&quot;,&quot;SOMETHING&quot;]

transducers.into(&quot;&quot;, transformer, words);
// WRITTENSOMETHING
</code></pre>
<p>When specifying an empty <code>[]</code> array, the <code>transduce(..)</code> called under the covers
uses a default implementation of a function like our <code>listCombine(..)</code> helper.
But when specifying an empty <code>&quot;&quot;</code> string, something like our <code>strConcat(..)</code> is
used. Cool!</p>
<p>As you can see, the <code>transducers-js</code> library makes transducing pretty
straightforward. We can very effectively leverage the power of this technique
without getting into the weeds of defining all those intermediate
transducer-producing utilities ourselves.</p>
<h2><a class="header" href="#summary-11" id="summary-11">Summary</a></h2>
<p>To transduce means to transform with a reduce. More specifically, a transducer
is a composable reducer.</p>
<p>We use transducing to compose adjacent <code>map(..)</code>, <code>filter(..)</code>, and <code>reduce(..)</code>
operations together. We accomplish this by first expressing <code>map(..)</code>s and
<code>filter(..)</code>s as <code>reduce(..)</code>s, and then abstracting out the common combination
operation to create unary reducer-producing functions that are easily composed.</p>
<p>Transducing primarily improves performance, which is especially obvious if used
on an observable.</p>
<p>But more broadly, transducing is how we express a more declarative composition
of functions that would otherwise not be directly composable. The result, if
used appropriately as with all other techniques in this book, is clearer, more
readable code! A single <code>reduce(..)</code> call with a transducer is easier to reason
about than tracing through multiple <code>reduce(..)</code> calls.</p>
<h1><a class="header" href="#functional-light-javascript-14" id="functional-light-javascript-14">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#appendix-b-the-humble-monad" id="appendix-b-the-humble-monad">Appendix B: The Humble Monad</a></h1>
<p>Let me just start off this appendix by admitting: I did not know much about what
a monad was before starting to write this appendix. And it took a lot of
mistakes to get something sensible. If you don't believe me, go look at the
commit history of this appendix in the
<a href="https://github.com/getify/Functional-Light-JS">Github repository for this book</a>!</p>
<p>I am including the topic of monads in the book because it's part of the journey
that every developer will encounter while learning FP, just as I have in this
book writing.</p>
<p>We're basically ending this book with a brief glimpse at monads, whereas most
other FP literature kinda almost starts with monads! I do not encounter in my
&quot;Functional-Light&quot; programming much of a need to think explicitly in terms of
monads, so that's why this material is more bonus than main core. But that's not
to say monads aren't useful or prevalent -- they very much are.</p>
<p>There's a bit of a joke around the JavaScript FP world that pretty much
everybody has to write their own tutorial or blog post on what a monad is, like
the writing of it alone is some rite of passage. Over the years, monads have
variously been depicted as burritos, onions, and all sorts of other wacky
conceptual abstractions. I hope there's none of that silly business going on
here!</p>
<blockquote>
<p>A monad is just a monoid in the category of endofunctors.</p>
</blockquote>
<p>We started the preface with this quote, so it seems fitting we come back to it
here. But no, we won't be talking about monoids, endofunctors, or category
theory. That quote is not only condescending, but totally unhelpful.</p>
<p>My only hope for what you get out of this discussion is to not be scared of the
term monad or the concept anymore -- I have been, for years! -- and to be able
to recognize them when you see them. You might, just maybe, even use them on
occasion.</p>
<h2><a class="header" href="#type" id="type">Type</a></h2>
<p>There's a huge area of interest in FP that we've basically stayed entirely away
from throughout this book: type theory. I'm not going to get very deep into type
theory, because quite frankly I'm not qualified to do so. And you wouldn't
appreciate it even if I did.</p>
<p>But what I will say is that a monad is basically a value type.</p>
<p>The number <code>42</code> has a value type (number!) that brings with it certain
characteristics and capabilities that we rely on. The string <code>&quot;42&quot;</code> may look
very similar, but it has a different purpose in our program.</p>
<p>In object-oriented programming, when you have a set of data (even a single
discrete value) and you have some behavior you want to bundle with it, you
create an object/class to represent that &quot;type&quot;. Instances are then members of
that type. This practice generally goes by the name &quot;data structures&quot;.</p>
<p>I'm going to use the notion of data structures very loosely here, and assert
that we may find it useful in a program to define a set of behaviors and
constraints for a certain value, and bundle them together with that value into a
single abstraction. That way, as we work with one or more of those kinds of
values in our program, their behaviors come along for free and will make working
with them more convenient. And by convenient, I mean more declarative and
approachable for the reader of your code!</p>
<p>A monad is a data structure. It's a type. It's a set of behaviors that are
specifically designed to make working with a value predictable.</p>
<p>Recall in
<a href="chapter_9.html">Chapter 9 that we talked about functors</a>: a
value along with a map-like utility to perform an operation on all its
constitute data members. A monad is a functor that includes some additional
behavior.</p>
<h2><a class="header" href="#loose-interface" id="loose-interface">Loose Interface</a></h2>
<p>Actually, a monad isn't a single data type, it's really more like a related
collection of data types. It's kind of an interface that's implemented
differently depending on the needs of different values. Each implementation is a
different type of monad.</p>
<p>For example, you may read about the &quot;Identity Monad&quot;, the &quot;IO Monad&quot;, the &quot;Maybe
Monad&quot;, the &quot;Either Monad&quot;, or a variety of others. Each of these has the basic
monad behavior defined, but it extends or overrides the interactions according
to the use cases for each different type of monad.</p>
<p>It's a little more than an interface though, because it's not just the presence
of certain API methods that makes an object a monad. There's a certain set of
guarantees about the interactions of these methods that is necessary, to be
monadic. These well-known invariants are critical to usage of monads improving
readability by familiarity; otherwise, it's just an ad hoc data structure that
must be fully read to be understood by the reader.</p>
<p>As a matter of fact, there's not even just one single unified agreement on the
names of these monadic methods, the way a true interface would mandate; a monad
is more like a loose interface. Some people call a certain method <code>bind(..)</code>,
some call it <code>chain(..)</code>, some call it <code>flatMap(..)</code>, and so on.</p>
<p>So a monad is an object data structure with sufficient methods (of practically
any name or sort) that at a minimum satisfy the main behavioral requirements of
the monad definition. Each kind of monad has a different kind of extension above
the minimum. But, because they all have an overlap in behavior, using two
different kinds of monads together is still straightforward and predictable.</p>
<p>It's in that sense that monads are sort of like an interface.</p>
<h2><a class="header" href="#just-a-monad" id="just-a-monad">Just a Monad</a></h2>
<p>A basic primitive monad underlying many other monads you will run across is
called Just. It's <em>just</em> a simple monadic wrapper for any regular (aka,
non-empty) value.</p>
<p>Since a monad is a type, you might think we'd define <code>Just</code> as a class to be
instantiated. That's a valid way of doing it, but it introduces <code>this</code>-binding
issues in the methods that I don't want to juggle; instead, I'm going to stick
with just a simple function approach.</p>
<p>Here's a basic implementation:</p>
<pre><code class="language-js">function Just(val) {
  return { map, chain, ap, inspect };

  // *********************

  function map(fn) {
    return Just(fn(val));
  }

  // aka: bind, flatMap
  function chain(fn) {
    return fn(val);
  }

  function ap(anotherMonad) {
    return anotherMonad.map(val);
  }

  function inspect() {
    return `Just(${val})`;
  }
}
</code></pre>
<p><strong>Note:</strong> The <code>inspect(..)</code> method is included here only for our demonstration
purposes. It serves no direct role in the monadic sense.</p>
<p>You'll notice that whatever <code>val</code> value a <code>Just(..)</code> instance holds, it's never
changed. All monad methods create new monad instances instead of mutating the
monad's value itself.</p>
<p>Don't worry if most of this doesn't make sense right now. We're not gonna obsess
too much over the details or the math/theory behind the design of the monad.
Instead, we'll focus more on illustrating what we can do with them.</p>
<h3><a class="header" href="#working-with-monad-methods" id="working-with-monad-methods">Working with Monad Methods</a></h3>
<p>All monad instances will have <code>map(..)</code>, <code>chain(..)</code> (also called <code>bind(..)</code> or
<code>flatMap(..)</code>), and <code>ap(..)</code> methods. The purpose of these methods and their
behavior is to provide a standardized way of multiple monad instances
interacting with each other.</p>
<p>Let's look first at the monadic <code>map(..)</code> function. Like <code>map(..)</code> on an array
(see <a href="chapter_9.html">Chapter 9</a>) that calls a mapper function with its
value(s) and produces a new array, a monad's <code>map(..)</code> calls a mapper function
with the monad's value, and whatever is returned is wrapped in a new Just monad
instance:</p>
<pre><code class="language-js">var A = Just(10);
var B = A.map(v =&gt; v * 2);

B.inspect(); // Just(20)
</code></pre>
<p>Monadic <code>chain(..)</code> kinda does the same thing as <code>map(..)</code>, but then it sort of
unwraps the resulting value from its new monad. However, instead of thinking
informally about &quot;unwrapping&quot; a monad, the more formal explanation would be that
<code>chain(..)</code> flattens the monad. Consider:</p>
<pre><code class="language-js">var A = Just(10);
var eleven = A.chain(v =&gt; v + 1);

eleven; // 11
typeof eleven; // &quot;number&quot;
</code></pre>
<p><code>eleven</code> is the actual primitive number <code>11</code>, not a monad holding that value.</p>
<p>To connect this <code>chain(..)</code> method conceptually to stuff we've already learned,
we'll point out that many monad implementations name this method <code>flatMap(..)</code>.
Now, recall from
<a href="chapter_9.html">Chapter 9 what <code>flatMap(..)</code></a> does (as
compared to <code>map(..)</code>) with an array:</p>
<pre><code class="language-js">var x = [3];

map(v =&gt; [v, v + 1], x); // [[3,4]]
flatMap(v =&gt; [v, v + 1], x); // [3,4]
</code></pre>
<p>See the difference? The mapper function <code>v =&gt; [v,v+1]</code> results in a <code>[3,4]</code>
array, which ends up in the single first position of the outer array, so we get
<code>[[3,4]]</code>. But <code>flatMap(..)</code> flattens out the inner array into the outer array,
so we get just <code>[3,4]</code> instead.</p>
<p>That's the same kind of thing going on with a monad's <code>chain(..)</code> (often
referred to as <code>flatMap(..)</code>). Instead of getting a monad holding the value as
<code>map(..)</code> does, <code>chain(..)</code> additionally flattens the monad into the underlying
value. Actually, instead of creating that intermediate monad only to immediately
flatten it, <code>chain(..)</code> is generally implemented more performantly to just take
a shortcut and not create the monad in the first place. Either way, the end
result is the same.</p>
<p>One way to illustrate <code>chain(..)</code> in this manner is in combination with the
<code>identity(..)</code> utility (see <a href="chapter_3.html">Chapter 3</a>), to
effectively extract a value from a monad:</p>
<pre><code class="language-js">var identity = v =&gt; v;

A.chain(identity); // 10
</code></pre>
<p><code>A.chain(..)</code> calls <code>identity(..)</code> with the value in <code>A</code>, and whatever value
<code>identity(..)</code> returns (<code>10</code> in this case) just comes right out without any
intervening monad. In other words, from that earlier <code>Just(..)</code> code listing, we
wouldn't actually need to include that optional <code>inspect(..)</code> helper, as
<code>chain(identity)</code> accomplishes the same goal; it's purely for ease of debugging
as we learn monads.</p>
<p>At this point, hopefully both <code>map(..)</code> and <code>chain(..)</code> feel fairly reasonable
to you.</p>
<p>By contrast, a monad's <code>ap(..)</code> method will likely be much less intuitive at
first glance. It will seem like a strange contortion of interaction, but there's
deep and important reasoning behind the design. Let's take a moment to break it
down.</p>
<p><code>ap(..)</code> takes the value wrapped in a monad and &quot;applies&quot; it to another monad
using that other monad's <code>map(..)</code>. OK, fine so far.</p>
<p>However, <code>map(..)</code> always expects a function. So that means the monad you call
<code>ap(..)</code> on has to actually contain a function as its value, to pass to that
other monad's <code>map(..)</code>.</p>
<p>Confused? Yeah, not what you might have expected. We'll try to briefly
illuminate, but just expect that these things will be fuzzy for a while until
you've had a lot more exposure and practice with monads.</p>
<p>We'll define <code>A</code> as a monad that contains a value <code>10</code>, and <code>B</code> as a monad that
contains the value <code>3</code>:</p>
<pre><code class="language-js">var A = Just(10);
var B = Just(3);

A.inspect(); // Just(10)
B.inspect(); // Just(3)
</code></pre>
<p>Now, how could we make a new monad where the values <code>10</code> and <code>3</code> had been added
together, say via a <code>sum(..)</code> function? Turns out <code>ap(..)</code> can help.</p>
<p>To use <code>ap(..)</code>, we said we first need to construct a monad that holds a
function. Specifically, we need one that holds a function that itself holds
(remembers via closure) the value in <code>A</code>. Let that sink in for a moment.</p>
<p>To make a monad from <code>A</code> that holds a value-containing function, we call
<code>A.map(..)</code>, giving it a curried function that &quot;remembers&quot; that extracted value
(see <a href="chapter_3.html">Chapter 3</a>) as its first argument. We'll call
this new function-containing monad <code>C</code>:</p>
<pre><code class="language-js">function sum(x, y) {
  return x + y;
}

var C = A.map(curry(sum));

C.inspect();
// Just(function curried...)
</code></pre>
<p>Think about how that works. The curried <code>sum(..)</code> function is expecting two
values to do its work, and we give it the first of those values by having
<code>A.map(..)</code> extract <code>10</code> and pass it in. <code>C</code> now holds the function that
remembers <code>10</code> via closure.</p>
<p>Now, to get the second value (<code>3</code> inside <code>B</code>) passed to the waiting curried
function in <code>C</code>:</p>
<pre><code class="language-js">var D = C.ap(B);

D.inspect(); // Just(13)
</code></pre>
<p>The value <code>10</code> came out of <code>C</code>, and <code>3</code> came out of <code>B</code>, and <code>sum(..)</code> added
them together to <code>13</code> and wrapped that in the monad <code>D</code>. Let's put the two steps
together so you can see their connection more clearly:</p>
<pre><code class="language-js">var D = A.map(curry(sum)).ap(B);

D.inspect(); // Just(13)
</code></pre>
<p>To illustrate what <code>ap(..)</code> is helping us with, we could have achieved the same
result this way:</p>
<pre><code class="language-js">var D = B.map(A.chain(curry(sum)));

D.inspect(); // Just(13);
</code></pre>
<p>And that of course is just a composition (see <a href="chapter_4.html">Chapter 4</a>):</p>
<pre><code class="language-js">var D = compose(B.map, A.chain, curry)(sum);

D.inspect(); // Just(13)
</code></pre>
<p>Cool, huh!?</p>
<p>If the <em>how</em> of this discussion on monad methods is unclear so far, go back and
re-read. If the <em>why</em> is elusive, just hang in there. Monads so easily confound
developers, that's <em>just</em> how it is!</p>
<h2><a class="header" href="#maybe" id="maybe">Maybe</a></h2>
<p>It's very common in FP material to cover well-known monads like Maybe. Actually,
the Maybe monad is a particular pairing of two other simpler monads: Just and
Nothing.</p>
<p>We've already seen Just; Nothing is a monad that holds an empty value. Maybe is
a monad that either holds a Just or a Nothing.</p>
<p>Here's a minimal implementation of Maybe:</p>
<pre><code class="language-js">var Maybe = { Just, Nothing, of /* aka: unit, pure */: Just };

function Just(val) {
  /* .. */
}

function Nothing() {
  return { map: Nothing, chain: Nothing, ap: Nothing, inspect };

  // *********************

  function inspect() {
    return &quot;Nothing&quot;;
  }
}
</code></pre>
<p><strong>Note:</strong> <code>Maybe.of(..)</code> (sometimes referred to as <code>unit(..)</code> or <code>pure(..)</code>) is
a convenience alias for <code>Just(..)</code>.</p>
<p>In contrast to <code>Just()</code> instances, <code>Nothing()</code> instances have no-op definitions
for all monadic methods. So if such a monad instance shows up in any monadic
operations, it has the effect of basically short-circuiting to have no behavior
happen. Notice there's no imposition here of what &quot;empty&quot; means -- your code
gets to decide that. More on that later.</p>
<p>In Maybe, if a value is non-empty, it's represented by an instance of
<code>Just(..)</code>; if it's empty, it's represented by an instance of <code>Nothing()</code>.</p>
<p>But the importance of this kind of monad representation is that whether we have
a <code>Just(..)</code> instance or a <code>Nothing()</code> instance, we'll use the API methods the
same.</p>
<p>The power of the Maybe abstraction is to encapsulate that behavior/no-op duality
implicitly.</p>
<h3><a class="header" href="#different-maybes" id="different-maybes">Different Maybes</a></h3>
<p>Many implementations of a JavaScript Maybe monad include a check (usually in
<code>map(..)</code>) to see if the value is <code>null</code>/<code>undefined</code>, and skipping the behavior
if so. In fact, Maybe is trumpeted as being valuable precisely because it sort
of automatically short-circuits its behavior with the encapsulated empty-value
check.</p>
<p>Here's how Maybe is usually illustrated:</p>
<pre><code class="language-js">// instead of unsafe `console.log( someObj.something.else.entirely )`:

Maybe.of(someObj)
  .map(prop(&quot;something&quot;))
  .map(prop(&quot;else&quot;))
  .map(prop(&quot;entirely&quot;))
  .map(console.log);
</code></pre>
<p>In other words, if at any point in the chain we get a <code>null</code>/<code>undefined</code> value,
the Maybe magically switches into no-op mode -- it's now a <code>Nothing()</code> monad
instance! -- and stops doing anything for the rest of the chain. That makes the
nested-property access safe against throwing JS exceptions if some property is
missing/empty. That's cool, and a nice helpful abstraction for sure!</p>
<p>But... <strong><em>that approach to Maybe is not a pure monad.</em></strong></p>
<p>The core spirit of a Monad says that it must be valid for all values and cannot
do any inspection of the value, at all -- not even a null check. So those other
implementations are cutting corners for the sake of convenience. It's not a huge
deal, but when it comes to learning something, you should probably learn it in
its purest form first before you go bending the rules.</p>
<p>The earlier implementation of the Maybe monad I provided differs from other
Maybes primarily in that it does not have the empty-check in it. Also, we
present <code>Maybe</code> merely as a loose pairing of <code>Just(..)</code>/<code>Nothing()</code>.</p>
<p>So wait. If we don't get the automatic short-circuiting, why is Maybe useful at
all?!? That seems like its whole point.</p>
<p>Never fear! We can simply provide the empty-check externally, and the rest of
the short-circuiting behavior of the Maybe monad will work just fine. Here's how
you could do the nested-property access (<code>someObj.something.else.entirely</code>) from
before, but more &quot;correctly&quot;:</p>
<pre><code class="language-js">function isEmpty(val) {
  return val === null || val === undefined;
}

var safeProp = curry(function safeProp(prop, obj) {
  if (isEmpty(obj[prop])) return Maybe.Nothing();
  return Maybe.of(obj[prop]);
});

Maybe.of(someObj)
  .chain(safeProp(&quot;something&quot;))
  .chain(safeProp(&quot;else&quot;))
  .chain(safeProp(&quot;entirely&quot;))
  .map(console.log);
</code></pre>
<p>We made a <code>safeProp(..)</code> that does the empty-check, and selects either a
<code>Nothing()</code> monad instance if so, or wraps the value in a <code>Just(..)</code> instance
(via <code>Maybe.of(..)</code>). Then instead of <code>map(..)</code>, we use <code>chain(..)</code> which knows
how to &quot;unwrap&quot; the monad that <code>safeProp(..)</code> returns.</p>
<p>We get the same chain short-circuiting upon encountering an empty value. We just
don't embed that logic into the Maybe.</p>
<p>The benefit of the monad, and Maybe specifically, is that our <code>map(..)</code> and
<code>chain(..)</code> methods have a consistent and predictable interaction regardless of
which kind of monad comes back. That's pretty cool!</p>
<h2><a class="header" href="#humble" id="humble">Humble</a></h2>
<p>Now that we have a little more understanding of Maybe and what it does, I'm
going to put a little twist on it -- and add some self-deferential humor to our
discussion -- by inventing the Maybe+Humble monad. Technically,
<code>MaybeHumble(..)</code> is not a monad itself, but a factory function that produces a
Maybe monad instance.</p>
<p>Humble is an admittedly contrived data structure wrapper that uses Maybe to
track the status of an <code>egoLevel</code> number. Specifically,
<code>MaybeHumble(..)</code>-produced monad instances only operate affirmatively if their
ego-level value is low enough (less than <code>42</code>!) to be considered humble;
otherwise it's a <code>Nothing()</code> no-op. That should sound a lot like Maybe; it's
pretty similar!</p>
<p>Here's the factory function for our Maybe+Humble monad:</p>
<pre><code class="language-js">function MaybeHumble(egoLevel) {
  // accept anything other than a number that's 42 or higher
  return !(Number(egoLevel) &gt;= 42) ? Maybe.of(egoLevel) : Maybe.Nothing();
}
</code></pre>
<p>You'll notice that this factory function is kinda like <code>safeProp(..)</code>, in that
it uses a condition to decide if it should pick the <code>Just(..)</code> or the
<code>Nothing()</code> part of the Maybe.</p>
<p>Let's illustrate some basic usage:</p>
<pre><code class="language-js">var bob = MaybeHumble(45);
var alice = MaybeHumble(39);

bob.inspect(); // Nothing
alice.inspect(); // Just(39)
</code></pre>
<p>What if Alice wins a big award and is now a bit more proud of herself?</p>
<pre><code class="language-js">function winAward(ego) {
  return MaybeHumble(ego + 3);
}

alice = alice.chain(winAward);
alice.inspect(); // Nothing
</code></pre>
<p>The <code>MaybeHumble( 39 + 3 )</code> call creates a <code>Nothing()</code> monad instance to return
back from the <code>chain(..)</code> call, so now Alice doesn't qualify as humble anymore.</p>
<p>Now, let's use a few monads together:</p>
<pre><code class="language-js">var bob = MaybeHumble(41);
var alice = MaybeHumble(39);

var teamMembers = curry(function teamMembers(ego1, ego2) {
  console.log(`Our humble team's egos: ${ego1} ${ego2}`);
});

bob.map(teamMembers).ap(alice);
// Our humble team's egos: 41 39
</code></pre>
<p>Recalling the usage of <code>ap(..)</code> from earlier, we can now explain how this code
works.</p>
<p>Because <code>teamMembers(..)</code> is curried, the <code>bob.map(..)</code> call passes in the <code>bob</code>
ego level (<code>41</code>), and creates a monad instance with the remaining function
wrapped up. Calling <code>ap(alice)</code> on <em>that</em> monad calls <code>alice.map(..)</code> and passes
to it the function from the monad. The effect is that both the <code>bob</code> and <code>alice</code>
monad's numeric values have been provided to <code>teamMembers(..)</code> function,
printing out the message as shown.</p>
<p>However, if either or both monads are actually <code>Nothing()</code> instances (because
their ego level was too high):</p>
<pre><code class="language-js">var frank = MaybeHumble(45);

bob.map(teamMembers).ap(frank);
// ..no output..

frank.map(teamMembers).ap(bob);
// ..no output..
</code></pre>
<p><code>teamMembers(..)</code> never gets called (and no message is printed), because <code>frank</code>
is a <code>Nothing()</code> instance. That's the power of the Maybe monad, and our
<code>MaybeHumble(..)</code> factory allows us to select based on the ego level. Cool!</p>
<h3><a class="header" href="#humility" id="humility">Humility</a></h3>
<p>One more example to illustrate the behaviors of our Maybe+Humble data structure:</p>
<pre><code class="language-js">function introduction() {
  console.log(&quot;I'm just a learner like you! :)&quot;);
}

var egoChange = curry(function egoChange(amount, concept, egoLevel) {
  console.log(`${amount &gt; 0 ? &quot;Learned&quot; : &quot;Shared&quot;} ${concept}.`);
  return MaybeHumble(egoLevel + amount);
});

var learn = egoChange(3);

var learner = MaybeHumble(35);

learner
  .chain(learn(&quot;closures&quot;))
  .chain(learn(&quot;side effects&quot;))
  .chain(learn(&quot;recursion&quot;))
  .chain(learn(&quot;map/reduce&quot;))
  .map(introduction);
// Learned closures.
// Learned side effects.
// Learned recursion.
// ..nothing else..
</code></pre>
<p>Unfortunately, the learning process seems to have been cut short. You see, I've
found that learning a bunch of stuff without sharing with others inflates your
ego too much and is not good for your skills.</p>
<p>Let's try a better approach to learning:</p>
<pre><code class="language-js">var share = egoChange(-2);

learner
  .chain(learn(&quot;closures&quot;))
  .chain(share(&quot;closures&quot;))
  .chain(learn(&quot;side effects&quot;))
  .chain(share(&quot;side effects&quot;))
  .chain(learn(&quot;recursion&quot;))
  .chain(share(&quot;recursion&quot;))
  .chain(learn(&quot;map/reduce&quot;))
  .chain(share(&quot;map/reduce&quot;))
  .map(introduction);
// Learned closures.
// Shared closures.
// Learned side effects.
// Shared side effects.
// Learned recursion.
// Shared recursion.
// Learned map/reduce.
// Shared map/reduce.
// I'm just a learner like you! :)
</code></pre>
<p>Sharing while you learn. That's the best way to learn more and learn better.</p>
<h2><a class="header" href="#summary-12" id="summary-12">Summary</a></h2>
<p>What is a monad, anyway? A monad is a value type, an interface, an object data
structure with encapsulated behaviors.</p>
<p>But none of those definitions are particularly useful. Here's an attempt at
something better: <strong>a monad is how you organize behavior around a value in a
more declarative way.</strong></p>
<p>As with everything else in this book, use monads where they are helpful but
don't use them just because everyone else talks about them in FP. Monads aren't
a universal silver bullet, but they do offer some utility when used
conservatively.</p>
<h1><a class="header" href="#functional-light-javascript-15" id="functional-light-javascript-15">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#appendix-c-fp-libraries" id="appendix-c-fp-libraries">Appendix C: FP Libraries</a></h1>
<p>If you've been reading this book from start to finish, take a minute to stop and
look back how far you've come since <a href="chapter_1.html">Chapter 1</a>. It's been quite a
journey. I hope you've learned a lot and gained insight into thinking
functionally for your own programs.</p>
<p>I want to close this book leaving you with some quick pointers of working with
common/popular FP libraries. This is not an exhaustive documentation on each,
but a quick glance at the things you should be aware of as you venture beyond
&quot;Functional-Light&quot; into broader FP.</p>
<p>Wherever possible, I recommend you <em>not</em> reinvent any wheels. If you find an FP
library that suits your needs, use it. Only use the ad hoc helper utilities from
this book -- or invent ones of your own! -- if you can't find a suitable library
method for your circumstance.</p>
<h2><a class="header" href="#stuff-to-investigate" id="stuff-to-investigate">Stuff to Investigate</a></h2>
<p>Let's expand the
<a href="chapter_1.html">list of FP libraries to be aware of, from Chapter 1</a>.
We won't cover all of these (as there's a lot of overlap), but here are the ones
that should probably be on your radar screen:</p>
<ul>
<li><a href="http://ramdajs.com">Ramda</a>: General FP Utilities</li>
<li><a href="https://github.com/sanctuary-js/sanctuary">Sanctuary</a>: Ramda Companion for FP
Types</li>
<li><a href="https://github.com/lodash/lodash/wiki/FP-Guide">lodash/fp</a>: General FP
Utilities</li>
<li><a href="http://functionaljs.com/">functional.js</a>: General FP Utilities</li>
<li><a href="https://github.com/facebook/immutable-js">Immutable</a>: Immutable Data
Structures</li>
<li><a href="https://github.com/swannodette/mori">Mori</a>: (ClojureScript Inspired)
Immutable Data Structures</li>
<li><a href="https://github.com/rtfeldman/seamless-immutable">Seamless-Immutable</a>:
Immutable Data Helpers</li>
<li><a href="https://github.com/cognitect-labs/transducers-js">transducers-js</a>:
Transducers</li>
<li><a href="https://github.com/monet/monet.js">monet.js</a>: Monadic Types</li>
</ul>
<p>There are dozens of other fine libraries not on this list. Just because it's not
on my list here doesn't mean it's not good, nor is this list a particular
endorsement. It's just a quick glance at the landscape of FP-in-JavaScript. A
much longer list of FP resources can be
<a href="https://github.com/stoeffel/awesome-fp-js">found here</a>.</p>
<p>One resource that's extremely important to the FP world -- it's not a library
but more an encyclopedia! -- is
<a href="https://github.com/fantasyland/fantasy-land">Fantasy Land</a> (aka FL).</p>
<p>This is definitely not light reading for the faint of heart. It's a complete
detailed roadmap of all of FP as it's interpreted in JavaScript. FL has become a
de facto standard for JavaScript FP libraries to adhere to, to ensure maximum
interoperability.</p>
<p>Fantasy Land is pretty much the exact opposite of &quot;Functional-Light&quot;. It's the
full-on no-holds-barred approach to FP in JavaScript. That said, as you venture
beyond this book, it's likely that FL will be on that road for you. I'd
recommend you bookmark it, and go back to it after you've had at least six
months of real-world practice with this book's concepts.</p>
<h2><a class="header" href="#ramda-0230" id="ramda-0230">Ramda (0.23.0)</a></h2>
<p>From the <a href="http://ramdajs.com/">Ramda documentation</a>:</p>
<blockquote>
<p>Ramda functions are automatically curried.</p>
<p>The parameters to Ramda functions are arranged to make it convenient for
currying. The data to be operated on is generally supplied last.</p>
</blockquote>
<p>I find that design decision to be one of Ramda's strengths. It's also important
to note that Ramda's form of currying (as with most libraries, it seems) is the
<a href="chapter_3.html">&quot;loose currying&quot; we talked about in Chapter 3</a>.</p>
<p>The <a href="chapter_3.html">final example of Chapter 3</a> --
recall defining a point-free <code>printIf(..)</code> utility -- can be done with Ramda
like this:</p>
<pre><code class="language-js">function output(msg) {
  console.log(msg);
}

function isShortEnough(str) {
  return str.length &lt;= 5;
}

var isLongEnough = R.complement(isShortEnough);

var printIf = R.partial(R.flip(R.when), [output]);

var msg1 = &quot;Hello&quot;;
var msg2 = msg1 + &quot; World&quot;;

printIf(isShortEnough, msg1); // Hello
printIf(isShortEnough, msg2);

printIf(isLongEnough, msg1);
printIf(isLongEnough, msg2); // Hello World
</code></pre>
<p>A few differences to point out compared to
<a href="chapter_3.html">Chapter 3's approach</a>:</p>
<ul>
<li>
<p>We use <code>R.complement(..)</code> instead of <code>not(..)</code> to create a negating function
<code>isLongEnough(..)</code> around <code>isShortEnough(..)</code>.</p>
</li>
<li>
<p>We use <code>R.flip(..)</code> instead of <code>reverseArgs(..)</code>. It's important to note that
<code>R.flip(..)</code> only swaps the first two arguments, whereas <code>reverseArgs(..)</code>
reverses all of them. In this case, <code>flip(..)</code> is more convenient for us, so
we don't need to do <code>partialRight(..)</code> or any of that kind of juggling.</p>
</li>
<li>
<p><code>R.partial(..)</code> takes all of its subsequent arguments (beyond the function) as
a single array.</p>
</li>
<li>
<p>Because Ramda is using loose currying, we don't need to use <code>R.uncurryN(..)</code>
to get a <code>printIf(..)</code> that takes both its arguments. If we did, it would look
like <code>R.uncurryN( 2, .. )</code> wrapped around the <code>R.partial(..)</code> call; but that's
not necessary.</p>
</li>
</ul>
<p>Ramda is a very popular and powerful library. It's a really good place to start
if you're practicing adding FP to your code base.</p>
<h2><a class="header" href="#lodashfp-4174" id="lodashfp-4174">Lodash/fp (4.17.4)</a></h2>
<p>Lodash is one of the most popular libraries in the entire JS ecosystem. They
publish an &quot;FP-friendly&quot; version of their API as
<a href="https://github.com/lodash/lodash/wiki/FP-Guide">&quot;lodash/fp&quot;</a>.</p>
<p>In
<a href="chapter_9.html">Chapter 9, we looked at composing standalone list operations</a>
(<code>map(..)</code>, <code>filter(..)</code>, and <code>reduce(..)</code>). Here's how we could do it with
&quot;lodash/fp&quot;:</p>
<pre><code class="language-js">var sum = (x, y) =&gt; x + y;
var double = x =&gt; x * 2;
var isOdd = x =&gt; x % 2 == 1;

fp.compose([fp.reduce(sum)(0), fp.map(double), fp.filter(isOdd)])([
  1,
  2,
  3,
  4,
  5
]); // 18
</code></pre>
<p>Instead of the more familiar <code>_.</code> namespace prefix, &quot;lodash/fp&quot; defines its
methods with <code>fp.</code> as the namespace prefix. I find that a helpful distinguisher,
and also generally more easy on my eyes than <code>_.</code> anyway!</p>
<p>Notice that <code>fp.compose(..)</code> (also known as <code>_.flowRight(..)</code> in lodash proper)
takes an array of functions instead of individual arguments.</p>
<p>You cannot beat the stability, widespread community support, and performance of
lodash. It's a solid bet for your FP explorations.</p>
<h2><a class="header" href="#mori-032" id="mori-032">Mori (0.3.2)</a></h2>
<p>In <a href="chapter_6.html">Chapter 6</a>, we already briefly glanced at the Immutable.js
library, probably the most well-known for immutable data structures.</p>
<p>Let's instead look at another popular library:
<a href="https://github.com/swannodette/mori">Mori</a>. Mori is designed with a different
(ostensibly more FP-like) take on API: it uses standalone functions instead of
methods directly on the values.</p>
<pre><code class="language-js">var state = mori.vector(1, 2, 3, 4);

var newState = mori.assoc(
  mori.into(state, Array.from({ length: 39 })),
  42,
  &quot;meaning of life&quot;
);

state === newState; // false

mori.get(state, 2); // 3
mori.get(state, 42); // undefined

mori.get(newState, 2); // 3
mori.get(newState, 42); // &quot;meaning of life&quot;

mori.toJs(newState).slice(1, 3); // [2,3]
</code></pre>
<p>Some interesting things to point out about Mori for this example:</p>
<ul>
<li>
<p>We're using a <code>vector</code> instead of a <code>list</code> (as one might assume), mostly
because the documentation says it behaves more like we expect JS arrays to be.</p>
</li>
<li>
<p>We cannot just randomly set a position past the end of the vector like we can
with JS arrays; that throws an exception. So we have to first &quot;grow&quot; the
vector using <code>mori.into(..)</code> with an array of the appropriate size of extra
slots we want. Once we have a vector with 43 slots (4 + 39), we can set the
final slot (position <code>42</code>) to the <code>&quot;meaning of life&quot;</code> value using the
<code>mori.assoc(..)</code> method.</p>
</li>
<li>
<p>The intermediate step of creating a larger vector with <code>mori.into(..)</code> and
then creating another from it with <code>mori.assoc(..)</code> might sound inefficient.
But the beauty of immutable data structures is that no cloning is going on
here. Each time a &quot;change&quot; is made, the new data structure is just tracking
the difference from the previous state.</p>
</li>
</ul>
<p>Mori is heavily inspired by ClojureScript. Its API will be very familiar if you
have experience (or currently work in!) that language. Since I don't have that
experience, I find the method names a little strange to get used to.</p>
<p>But I really like the standalone function design instead of methods on values.
Mori also has some functions that automatically return regular JS arrays, which
is a nice convenience.</p>
<h2><a class="header" href="#bonus-fpo" id="bonus-fpo">Bonus: FPO</a></h2>
<p>In <a href="chapter_2.html">Chapter 2, we introduced a pattern</a> for
dealing with arguments called &quot;named arguments&quot;, which in JS means using an
object at the call-site to map properties to destructured function parameters:</p>
<pre><code class="language-js">function foo({ x, y } = {}) {
  console.log(x, y);
}

foo({
  y: 3
}); // undefined 3
</code></pre>
<p>Then in <a href="chapter_3.html">Chapter 3, we talked about extending</a> our
ideas of currying and partial application to work with named arguments, like
this:</p>
<pre><code class="language-js">function foo({ x, y, z } = {}) {
  console.log(`x:${x} y:${y} z:${z}`);
}

var f1 = curryProps(foo, 3);

f1({ y: 2 })({ x: 1 })({ z: 3 });
</code></pre>
<p>One major benefit of this style is being able to pass arguments (even with
currying or partial application!) in any order without needing to do
<code>reverseArgs(..)</code>-style juggling of parameters. Another is being able to omit an
optional argument by simply not specifying it, instead of passing an ugly
placeholder.</p>
<p>In my journey learning FP, I've regularly been frustrated by both of those
irritations of functions with traditional positional arguments; thus I've really
appreciated the named arguments style for addressing those concerns.</p>
<p>One day, I was musing about with this style of FP coding, and wondered what it
would be like if a whole FP library had all its API methods exposed in this
style. I started experimenting, showed those experiments to a few FP folks, and
got some positive feedback.</p>
<p>From those experiments, eventually the <a href="https://github.com/getify/fpo">FPO</a>
(pronounced &quot;eff-poh&quot;) library was born; FPO stands for FP-with-Objects, in case
you were wondering.</p>
<p>From the documentation:</p>
<pre><code class="language-js">// Ramda's `reduce(..)`
R.reduce((acc, v) =&gt; acc + v, 0, [3, 7, 9]); // 19

// FPO named-argument method style
FPO.reduce({
  arr: [3, 7, 9],
  fn: ({ acc, v }) =&gt; acc + v
}); // 19
</code></pre>
<p>With traditional library implementations of <code>reduce(..)</code> (like Ramda), the
initial value parameter is in the middle, and not optional. FPO's <code>reduce(..)</code>
method can take the arguments in any order, and you can omit the optional
initial value if desired.</p>
<p>As with most other FP libraries, FPO's API methods are automatically
loose-curried, so you can not only provide arguments in any order, but
specialize the function by providing its arguments over multiple calls:</p>
<pre><code class="language-js">var f = FPO.reduce({ arr: [3, 7, 9] });

// later

f({ fn: ({ acc, v }) =&gt; acc + v }); // 19
</code></pre>
<p>Lastly, all of FPO's API methods are also exposed using the traditional
positional arguments style -- you'll find they're all very similar to Ramda and
other libraries -- under the <code>FPO.std.*</code> namespace:</p>
<pre><code class="language-js">FPO.std.reduce((acc, v) =&gt; acc + v, undefined, [3, 7, 9]); // 19
</code></pre>
<p>If FPO's named argument form of FP appeals to you, perhaps check out the library
and see what you think. It has a full test suite and most of the major FP
functionality you'd expect, including everything we covered in this text to get
you up and going with Functional-Light JavaScript!</p>
<h2><a class="header" href="#bonus-2-fasy" id="bonus-2-fasy">Bonus #2: fasy</a></h2>
<p>FP iterations (<code>map(..)</code>, <code>filter(..)</code>, etc.) are almost always modeled as
synchronous operations, meaning we eagerly run through all the steps of the
iteration immediately. As a matter of fact, other FP patterns like composition
and even transducing are also iterations, and are also modeled exactly this way.</p>
<p>But what happens if one or more of the steps in an iteration needs to complete
asynchronously? You might jump to thinking that Observables (see
<a href="chapter_10.html">Chapter 10</a>) is the natural answer, but they're not
what we need.</p>
<p>Let me quickly illustrate.</p>
<p>Imagine you have a list of URLs that represent images you want to load into a
web page. The fetching of the images is asynchronous, obviously. So, this isn't
going to work quite like you'd hope:</p>
<pre><code class="language-js">var imageURLs = [
  &quot;https://some.tld/image1.png&quot;,
  &quot;https://other.tld/image2.png&quot;,
  &quot;https://various.tld/image3.png&quot;
];

var images = imageURLs.map(fetchImage);
</code></pre>
<p>The <code>images</code> array won't contain the images. Depending on the behavior of
<code>fetchImage(..)</code>, it probably returns a promise for the image object once it
finishes downloading. So <code>images</code> would now be a list of promises.</p>
<p>Of course, you could then use <code>Promise.all(..)</code> to wait for all those promises
to resolve, and then unwrap an array of the image object results at its
completion:</p>
<pre><code class="language-js">Promise.all(images).then(function allImages(imgObjs) {
  // ..
});
</code></pre>
<p>Unfortunately, this &quot;trick&quot; only works if you're going to do all the
asynchronous steps concurrently (rather than serially, one after the other), and
only if the operation is a <code>map(..)</code> call as shown. If you want serial
asynchrony, or you want to, for example, do a <code>filter(..)</code> concurrently, this
won't quite work; it's possible, but it's messier.</p>
<p>And some operations naturally require serial asynchrony, like for example an
asynchronous <code>reduce(..)</code>, which clearly needs to work left-to-right one at a
time; those steps can't be run concurrently and have that operation make any
sense.</p>
<p>As I said, Observables (see <a href="chapter_10.html">Chapter 10</a>) aren't the
answer to these kinds of tasks. The reason is, an Observable's coordination of
asynchrony is between separate operations, not between steps/iterations at a
single level of operation.</p>
<p>Another way to visualize this distinction is that Observables support &quot;vertical
asynchrony&quot;, whereas what I'm talking about would be &quot;horizontal asynchrony&quot;.</p>
<p>Consider:</p>
<pre><code class="language-js">var obsv = Rx.Observable.from([1, 2, 3, 4, 5]);

obsv
  .map(x =&gt; x * 2)
  .delay(100) // &lt;-- vertical asynchrony
  .map(x =&gt; x + 1)
  .subscribe(v =&gt; console.log);
// {after 100 ms}
// 3
// 5
// 7
// 9
// 11
</code></pre>
<p>If for some reason I wanted to ensure that there was a delay of 100 ms between
when <code>1</code> was processed by the first <code>map(..)</code> and when <code>2</code> was processed, that
would be the &quot;horizontal asynchrony&quot; I'm referring to. There's not really a
clean way to model that.</p>
<p>And of course, I'm using an arbitrary delay in that description, but in practice
that would more likely be serial-asynchrony like an asynchronous reduce, where
each step in that reduction iteration could take some time before it completes
and lets the next step be processed.</p>
<p>So, how do we support both serial and concurrent iteration across asynchronous
operations?</p>
<p><strong>fasy</strong> (pronounced like &quot;Tracy&quot; but with an &quot;f&quot;) is a little utility library I
built for supporting exactly those kinds of tasks. You can find more information
about it <a href="https://github.com/getify/fasy">here</a>.</p>
<p>To illustrate <strong>fasy</strong>, let's consider a concurrent <code>map(..)</code> versus a serial
<code>map(..)</code>:</p>
<pre><code class="language-js">FA.concurrent.map(fetchImage, imageURLs).then(function allImages(imgObjs) {
  // ..
});

FA.serial.map(fetchImage, imageURLs).then(function allImages(imgObjs) {
  // ..
});
</code></pre>
<p>In both cases, the <code>then(..)</code> handler will only be invoked once all the fetches
have fully completed. The difference is whether the fetches will all initiate
concurrently (aka, &quot;in parallel&quot;) or go out one at a time.</p>
<p>Your instinct might be that concurrent would always be preferable, and while
that may be common, it's not always the case.</p>
<p>For example, what if <code>fetchImage(..)</code> maintains a cache of fetched images, and
it checks the cache before making the actual network request? What if, in
addition to that, the list of <code>imageURLs</code> could have duplicates in it? You'd
certainly want the first fetch of an image URL to complete (and populate the
cache) before doing the check on the duplicate image URL later in the list.</p>
<p>Again, there will inevitably be cases where concurrent or serial asynchrony will
be called for. Asynchronous reductions will always be serial, whereas
asynchronous mappings may likely tend to be more concurrent but can also need to
be serial in some cases. That's why <strong>fasy</strong> supports all these options.</p>
<p>Along with Observables, <strong>fasy</strong> will help you extend more FP patterns and
principles to your asynchronous operations.</p>
<h2><a class="header" href="#summary-13" id="summary-13">Summary</a></h2>
<p>JavaScript is not particularly designed as an FP language. However, it does have
enough of the basics (like function values, closures, etc.) for us to make it
FP-friendly. And the libraries we've examined here will help you do that.</p>
<p>Armed with the concepts from this book, you're ready to start tackling
real-world code. Find a good, comfortable FP library and jump in. Practice,
practice, practice!</p>
<p>So... that's it. I've shared what I have for you, for now. I hereby officially
certify you as a &quot;Functional-Light JavaScript&quot; programmer! It's time to close
out this &quot;chapter&quot; of our story of learning FP together. But my learning journey
still continues; I hope yours does, too!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
