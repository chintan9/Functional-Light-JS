<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 4 - Functional-Light JavaScript</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="foreword.html"><strong aria-hidden="true">1.</strong> Foreword</a></li><li class="expanded "><a href="preface.html"><strong aria-hidden="true">2.</strong> Preface</a></li><li class="expanded "><a href="chapter_1.html"><strong aria-hidden="true">3.</strong> Chapter 1</a></li><li class="expanded "><a href="chapter_2.html"><strong aria-hidden="true">4.</strong> Chapter 2</a></li><li class="expanded "><a href="chapter_3.html"><strong aria-hidden="true">5.</strong> Chapter 3</a></li><li class="expanded "><a href="chapter_4.html" class="active"><strong aria-hidden="true">6.</strong> Chapter 4</a></li><li class="expanded "><a href="chapter_5.html"><strong aria-hidden="true">7.</strong> Chapter 5</a></li><li class="expanded "><a href="chapter_6.html"><strong aria-hidden="true">8.</strong> Chapter 6</a></li><li class="expanded "><a href="chapter_7.html"><strong aria-hidden="true">9.</strong> Chapter 7</a></li><li class="expanded "><a href="chapter_8.html"><strong aria-hidden="true">10.</strong> Chapter 8</a></li><li class="expanded "><a href="chapter_9.html"><strong aria-hidden="true">11.</strong> Chapter 9</a></li><li class="expanded "><a href="chapter_10.html"><strong aria-hidden="true">12.</strong> Chapter 10</a></li><li class="expanded "><a href="chapter_11.html"><strong aria-hidden="true">13.</strong> Chapter 11</a></li><li class="expanded "><a href="apA.html"><strong aria-hidden="true">14.</strong> Appendix A: Transducing</a></li><li class="expanded "><a href="apB.html"><strong aria-hidden="true">15.</strong> Appendix B: The Humble Monad</a></li><li class="expanded "><a href="apC.html"><strong aria-hidden="true">16.</strong> Appendix C: FP Libraries</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Functional-Light JavaScript</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#functional-light-javascript" id="functional-light-javascript">Functional-Light JavaScript</a></h1>
<h1><a class="header" href="#chapter-4-composing-functions" id="chapter-4-composing-functions">Chapter 4: Composing Functions</a></h1>
<p>By now, I hope you're feeling much more comfortable with what it means to use
functions for functional programming.</p>
<p>A functional programmer sees every function in their program like a simple
little Lego piece. They recognize the blue 2x2 brick at a glance, and know
exactly how it works and what they can do with it. When they begin building a
bigger, more complex Lego model, as they need each next piece, they already have
an instinct for which of their many spare pieces to grab.</p>
<p>But sometimes you take the blue 2x2 brick and the gray 4x1 brick and put them
together in a certain way, and you realize, &quot;that's a useful piece that I need
often&quot;.</p>
<p>So now you've come up with a new &quot;piece&quot;, a combination of two other pieces, and
you can reach for that kind of piece now anytime you need it. It's more
effective to recognize and use this compound blue-gray L-brick thing where it's
needed than to separately think about assembling the two individual bricks each
time.</p>
<p>Functions come in a variety of shapes and sizes. And we can define a certain
combination of them to make a new compound function that will be handy in
various parts of the program. This process of using functions together is called
composition.</p>
<p>Composition is how an FPer models the flow of data through the program. In some
senses, it's the most foundational concept in all of FP, because without it, you
can't declaratively model data and state changes. In other words, everything
else in FP would collapse without composition.</p>
<h2><a class="header" href="#output-to-input" id="output-to-input">Output to Input</a></h2>
<p>We've already seen a few examples of composition. For example, our discussion of
<a href="chapter_3.html"><code>unary(..)</code> in Chapter 3</a> included this
expression: <a href="chapter_3.html"><code>[..].map(unary(parseInt))</code></a>.
Think about what's happening there.</p>
<p>To compose two functions together, pass the output of the first function call as
the input of the second function call. In <code>map(unary(parseInt))</code>, the
<code>unary(parseInt)</code> call returns a value (a function); that value is directly
passed as an argument to <code>map(..)</code>, which returns an array.</p>
<p>To take a step back and visualize the conceptual flow of data, consider:</p>
<pre><code class="language-txt">arrayValue &lt;-- map &lt;-- unary &lt;-- parseInt
</code></pre>
<p><code>parseInt</code> is the input to <code>unary(..)</code>. The output of <code>unary(..)</code> is the input
to <code>map(..)</code>. The output of <code>map(..)</code> is <code>arrayValue</code>. This is the composition
of <code>map(..)</code> and <code>unary(..)</code>.</p>
<p><strong>Note:</strong> The right-to-left orientation here is on purpose, though it may seem
strange at this point in your learning. We'll come back to explain that more
fully later.</p>
<p>Think of this flow of data like a conveyor belt in a candy factory, where each
operation is a step in the process of cooling, cutting, and wrapping a piece of
candy. We'll use the candy factory metaphor throughout this chapter to explain
what composition is.</p>
<p align="center">
    <img alt="figure" src="images/fig2.png">
</p>
<p>Let's examine composition in action one step at a time. Consider these two
utilities you might have in your program:</p>
<pre><code class="language-js">function words(str) {
  return String(str)
    .toLowerCase()
    .split(/\s|\b/)
    .filter(function alpha(v) {
      return /^[\w]+$/.test(v);
    });
}

function unique(list) {
  var uniqList = [];

  for (let v of list) {
    // value not yet in the new list?
    if (uniqList.indexOf(v) === -1) {
      uniqList.push(v);
    }
  }

  return uniqList;
}
</code></pre>
<p><code>words(..)</code> splits a string into an array of words. <code>unique(..)</code> takes a list of
words and filters it to not have any repeat words in it.</p>
<p>To use these two utilities to analyze a string of text:</p>
<pre><code class="language-js">var text =
  &quot;To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.&quot;;

var wordsFound = words(text);
var wordsUsed = unique(wordsFound);

wordsUsed;
// [&quot;to&quot;,&quot;compose&quot;,&quot;two&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;pass&quot;,
// &quot;the&quot;,&quot;output&quot;,&quot;of&quot;,&quot;first&quot;,&quot;function&quot;,&quot;call&quot;,&quot;as&quot;,
// &quot;input&quot;,&quot;second&quot;]
</code></pre>
<p>We name the array output of <code>words(..)</code> as <code>wordsFound</code>. The input of
<code>unique(..)</code> is also an array, so we can pass the <code>wordsFound</code> into it.</p>
<p>Back to the candy factory assembly line: the first machine takes as &quot;input&quot; the
melted chocolate, and its &quot;output&quot; is a chunk of formed and cooled chocolate.
The next machine a little down the assembly line takes as its &quot;input&quot; the chunk
of chocolate, and its &quot;output&quot; is a cut-up piece of chocolate candy. Next, a
machine on the line takes small pieces of chocolate candy from the conveyor belt
and outputs wrapped candies ready to bag and ship.</p>
<img alt="figure" src="images/fig3.png" align="right" width="9%" hspace="20">
<p>The candy factory is fairly successful with this process, but as with all
businesses, management keeps searching for ways to grow.</p>
<p>To keep up with demand for more candy production, they decide to take out the
conveyor belt contraption and just stack all three machines on top of one
another, so that the output valve of one is connected directly to the input
valve of the one below it. There's no longer sprawling wasted space where a
chunk of chocolate slowly and noisily rumbles down a conveyor belt from the
first machine to the second.</p>
<p>This innovation saves a lot of room on the factory floor, so management is happy
they'll get to make more candy each day!</p>
<p>The code equivalent of this improved candy factory configuration is to skip the
intermediate step (the <code>wordsFound</code> variable in the earlier snippet), and just
use the two function calls together:</p>
<pre><code class="language-js">var wordsUsed = unique(words(text));
</code></pre>
<p><strong>Note:</strong> Though we typically read the function calls left-to-right --
<code>unique(..)</code> and then <code>words(..)</code> -- the order of operations will actually be
more right-to-left, or inner-to-outer. <code>words(..)</code> will run first and then
<code>unique(..)</code>. Later we'll talk about a pattern that matches the order of
execution to our natural left-to-right reading, called <code>pipe(..)</code>.</p>
<p>The stacked machines are working fine, but it's kind of clunky to have the wires
hanging out all over the place. The more of these machine-stacks they create,
the more cluttered the factory floor gets. And the effort to assemble and
maintain all these machine stacks is awfully time intensive.</p>
<img alt="figure" src="images/fig4.png" align="left" width="15%" hspace="20">
<p>One morning, an engineer at the candy factory has a great idea. She figures that
it'd be much more efficient if she made an outer box to hide all the wires; on
the inside, all three of the machines are hooked up together, and on the outside
everything is now neat and tidy. On the top of this fancy new machine is a valve
to pour in melted chocolate and on the bottom is a valve that spits out wrapped
chocolate candies. Brilliant!</p>
<p>This single compound machine is much easier to move around and install wherever
the factory needs it. The workers on the factory floor are even happier because
they don't need to fidget with buttons and dials on three individual machines
anymore; they quickly prefer using the single fancy machine.</p>
<p>Relating back to the code: we now realize that the pairing of <code>words(..)</code> and
<code>unique(..)</code> in that specific order of execution (think: compound Lego) is
something we could use in several other parts of our application. So, let's
define a compound function that combines them:</p>
<pre><code class="language-js">function uniqueWords(str) {
  return unique(words(str));
}
</code></pre>
<p><code>uniqueWords(..)</code> takes a string and returns an array. It's a composition of the
two functions: <code>unique(..)</code> and <code>words(..)</code>; it creates this flow of data:</p>
<pre><code class="language-txt">wordsUsed &lt;-- unique &lt;-- words &lt;-- text
</code></pre>
<p>You probably recognize it by now: the unfolding revolution in candy factory
design is function composition.</p>
<h3><a class="header" href="#machine-making" id="machine-making">Machine Making</a></h3>
<p>The candy factory is humming along nicely, and thanks to all the saved space,
they now have plenty of room to try out making new kinds of candies. Building on
the earlier success, management is keen to keep inventing new fancy compound
machines for their growing candy assortment.</p>
<p>But the factory engineers struggle to keep up, because each time a new kind of
fancy compound machine needs to be made, they spend quite a bit of time making
the new outer box and fitting the individual machines into it.</p>
<p>So the factory engineers contact an industrial machine vendor for help. They're
amazed to find out that this vendor offers a <strong>machine-making</strong> machine! As
incredible as it sounds, they purchase a machine that can take a couple of the
factory's smaller machines -- the chocolate cooling one and the cutting one, for
example -- and wire them together automatically, even wrapping a nice clean
bigger box around them. This is surely going to make the candy factory really
take off!</p>
<p align="center">
    <img alt="figure" src="images/fig5.png" width="50%">
</p>
<p>Back to code land, let's consider a utility called <code>compose2(..)</code> that creates a
composition of two functions automatically, exactly the same way we did
manually:</p>
<pre><code class="language-js">function compose2(fn2, fn1) {
  return function composed(origValue) {
    return fn2(fn1(origValue));
  };
}

// or the ES6 =&gt; form
var compose2 = (fn2, fn1) =&gt; origValue =&gt; fn2(fn1(origValue));
</code></pre>
<p>Did you notice that we defined the parameter order as <code>fn2,fn1</code>, and furthermore
that it's the second function listed (aka <code>fn1</code> parameter name) that runs first,
then the first function listed (<code>fn2</code>)? In other words, the functions compose
from right-to-left.</p>
<p>That may seem like a strange choice, but there are some reasons for it. Most
typical FP libraries define their <code>compose(..)</code> to work right-to-left in terms
of ordering, so we're sticking with that convention.</p>
<p>But why? I think the easiest explanation (but perhaps not the most historically
accurate) is that we're listing them to match the order they are written in code
manually, or rather the order we encounter them when reading from left-to-right.</p>
<p><code>unique(words(str))</code> lists the functions in the left-to-right order
<code>unique, words</code>, so we make our <code>compose2(..)</code> utility accept them in that
order, too. The execution order is right-to-left, but the code order is
left-to-right. Pay close attention to keep those distinct in your mind.</p>
<p>Now, the more efficient definition of the candy making machine is:</p>
<pre><code class="language-js">var uniqueWords = compose2(unique, words);
</code></pre>
<h3><a class="header" href="#composition-variation" id="composition-variation">Composition Variation</a></h3>
<p>It may seem like the <code>&lt;-- unique &lt;-- words</code> combination is the only order these
two functions can be composed. But we could actually compose them in the
opposite order to create a utility with a bit of a different purpose:</p>
<pre><code class="language-js">var letters = compose2(words, unique);

var chars = letters(&quot;How are you Henry?&quot;);
chars;
// [&quot;h&quot;,&quot;o&quot;,&quot;w&quot;,&quot;a&quot;,&quot;r&quot;,&quot;e&quot;,&quot;y&quot;,&quot;u&quot;,&quot;n&quot;]
</code></pre>
<p>This works because the <code>words(..)</code> utility, for value-type safety sake, first
coerces its input to a string using <code>String(..)</code>. So the array that <code>unique(..)</code>
returns -- now the input to <code>words(..)</code> -- becomes the string
<code>&quot;H,o,w, ,a,r,e,y,u,n,?&quot;</code>, and then the rest of the behavior in <code>words(..)</code>
processes that string into the <code>chars</code> array.</p>
<p>Admittedly, this is a contrived example. But the point is that function
compositions are not always unidirectional. Sometimes we put the gray brick on
top of the blue brick, and sometimes we put the blue brick on top.</p>
<p>The candy factory better be careful if they try to feed the wrapped candies into
the machine that mixes and cools the chocolate!</p>
<h2><a class="header" href="#general-composition" id="general-composition">General Composition</a></h2>
<p>If we can define the composition of two functions, we can just keep going to
support composing any number of functions. The general data visualization flow
for any number of functions being composed looks like this:</p>
<pre><code class="language-txt">finalValue &lt;-- func1 &lt;-- func2 &lt;-- ... &lt;-- funcN &lt;-- origValue
</code></pre>
<p align="center">
    <img alt="figure" src="images/fig6.png" width="50%">
</p>
<p>Now the candy factory owns the best machine of all: a machine that can take any
number of separate smaller machines and spit out a big fancy machine that does
every step in order. That's one heck of a candy operation! It's Willy Wonka's
dream!</p>
<p>We can implement a general <code>compose(..)</code> utility like this:</p>
<p><a name="generalcompose"></a></p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    // copy the array of functions
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the last function off the end of the list
      // and execute it
      result = list.pop()(result);
    }

    return result;
  };
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; result =&gt; {
  var list = [...fns];

  while (list.length &gt; 0) {
    // take the last function off the end of the list
    // and execute it
    result = list.pop()(result);
  }

  return result;
};
</code></pre>
<p><strong>Warning:</strong> <code>fns</code> is a collected array of arguments, not a passed-in array, and
as such, it's local to <code>compose(..)</code>. It may be tempting to think the <code>[...fns]</code>
would thus be unnecessary. However, in this particular implementation, <code>.pop()</code>
inside the inner <code>composed(..)</code> function is mutating the list, so if we didn't
make a copy each time, the returned composed function could only be used
reliably once. We'll revisit this hazard in
<a href="chapter_6.html">Chapter 6</a>.</p>
<p>Now let's look at an example of composing more than two functions. Recalling our
<code>uniqueWords(..)</code> composition example, let's add a <code>skipShortWords(..)</code> to the
mix:</p>
<pre><code class="language-js">function skipShortWords(words) {
  var filteredWords = [];

  for (let word of words) {
    if (word.length &gt; 4) {
      filteredWords.push(word);
    }
  }

  return filteredWords;
}
</code></pre>
<p>Let's define <code>biggerWords(..)</code> that includes <code>skipShortWords(..)</code>. The manual
composition equivalent is <code>skipShortWords( unique( words( text ) ) )</code>, so let's
do that with <code>compose(..)</code>:</p>
<pre><code class="language-js">var text =
  &quot;To compose two functions together, pass the \
output of the first function call as the input of the \
second function call.&quot;;

var biggerWords = compose(skipShortWords, unique, words);

var wordsUsed = biggerWords(text);

wordsUsed;
// [&quot;compose&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;output&quot;,&quot;first&quot;,
// &quot;function&quot;,&quot;input&quot;,&quot;second&quot;]
</code></pre>
<p>To do something more interesting with composition, let's use
<a href="chapter_3.html"><code>partialRight(..)</code>, which we first looked at in Chapter 3</a>.
We can build a right-partial application of <code>compose(..)</code> itself, pre-specifying
the second and third arguments (<code>unique(..)</code> and <code>words(..)</code>, respectively);
we'll call it <code>filterWords(..)</code>.</p>
<p>Then, we can complete the composition multiple times by calling
<code>filterWords(..)</code>, but with different first-arguments respectively:</p>
<pre><code class="language-js">// Note: uses a `&lt;= 4` check instead of the `&gt; 4` check
// that `skipShortWords(..)` uses
function skipLongWords(list) {
  /* .. */
}

var filterWords = partialRight(compose, unique, words);

var biggerWords = filterWords(skipShortWords);
var shorterWords = filterWords(skipLongWords);

biggerWords(text);
// [&quot;compose&quot;,&quot;functions&quot;,&quot;together&quot;,&quot;output&quot;,&quot;first&quot;,
// &quot;function&quot;,&quot;input&quot;,&quot;second&quot;]

shorterWords(text);
// [&quot;to&quot;,&quot;two&quot;,&quot;pass&quot;,&quot;the&quot;,&quot;of&quot;,&quot;call&quot;,&quot;as&quot;]
</code></pre>
<p>Take a moment to consider what the right-partial application on <code>compose(..)</code>
gives us. It allows us to specify ahead of time the first step(s) of a
composition, and then create specialized variations of that composition with
different subsequent steps (<code>biggerWords(..)</code> and <code>shorterWords(..)</code>). This is
one of the most powerful tricks of FP!</p>
<p>You can also <code>curry(..)</code> a composition instead of partial application, though
because of right-to-left ordering, you might more often want to
<code>curry( reverseArgs(compose), ..)</code> rather than just <code>curry( compose, ..)</code>
itself.</p>
<p><strong>Note:</strong> Because <code>curry(..)</code> (at least
<a href="chapter_3.html">the way we implemented it in Chapter 3</a>)
relies on either detecting the arity (<code>length</code>) or having it manually specified,
and <code>compose(..)</code> is a variadic function, you'll need to manually specify the
intended arity like <code>curry(.. , 3)</code>.</p>
<h3><a class="header" href="#alternative-implementations" id="alternative-implementations">Alternative Implementations</a></h3>
<p>While you may very well never implement your own <code>compose(..)</code> to use in
production, and rather just use a library's implementation as provided, I've
found that understanding how it works under the covers actually helps solidify
general FP concepts very well.</p>
<p>So let's examine some different implementation options for <code>compose(..)</code>. We'll
also see there are some pros/cons to each implementation, especially
performance.</p>
<p>We'll be looking at the
<a href="chapter_9.html"><code>reduce(..)</code> utility in detail in Chapter 9</a>, but for
now, just know that it reduces a list (array) to a single finite value. It's
like a fancy loop.</p>
<p>For example, if you did an addition-reduction across a list of numbers (such as
<code>[1,2,3,4,5,6]</code>), you'd loop over them adding them together as you go. The
reduction would add <code>1</code> to <code>2</code>, and add that result to <code>3</code>, and then add that
result to <code>4</code>, and so on, resulting in the final summation: <code>21</code>.</p>
<p>The original version of <code>compose(..)</code> uses a loop and eagerly (aka, immediately)
calculates the result of one call to pass into the next call. This is a
reduction of a list of functions, so we can do that same thing with
<code>reduce(..)</code>:</p>
<p><a name="composereduce"></a></p>
<pre><code class="language-js">function compose(...fns) {
  return function composed(result) {
    return [...fns].reverse().reduce(function reducer(result, fn) {
      return fn(result);
    }, result);
  };
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; result =&gt;
  [...fns].reverse().reduce((result, fn) =&gt; fn(result), result);
</code></pre>
<p><strong>Note:</strong> This implementation of <code>compose(..)</code> uses
<code>[...fns].reverse().reduce(..)</code> to reduce from right-to-left. We'll
<a href="chapter_9.html">revisit <code>compose(..)</code> in Chapter 9</a>,
instead using <code>reduceRight(..)</code> for that purpose.</p>
<p>Notice that the <code>reduce(..)</code> looping happens each time the final <code>composed(..)</code>
function is run, and that each intermediate <code>result(..)</code> is passed along to the
next iteration as the input to the next call.</p>
<p>The advantage of this implementation is that the code is more concise and also
that it uses a well-known FP construct: <code>reduce(..)</code>. And the performance of
this implementation is also similar to the original <code>for</code>-loop version.</p>
<p>However, this implementation is limited in that the outer composed function
(aka, the first function in the composition) can only receive a single argument.
Most other implementations pass along all arguments to that first call. If every
function in the composition is unary, this is no big deal. But if you need to
pass multiple arguments to that first call, you'd want a different
implementation.</p>
<p>To fix that first call single-argument limitation, we can still use <code>reduce(..)</code>
but produce a lazy-evaluation function wrapping:</p>
<pre><code class="language-js">function compose(...fns) {
  return fns.reverse().reduce(function reducer(fn1, fn2) {
    return function composed(...args) {
      return fn2(fn1(...args));
    };
  });
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt;
  fns.reverse().reduce((fn1, fn2) =&gt; (...args) =&gt; fn2(fn1(...args)));
</code></pre>
<p>Notice that we return the result of the <code>reduce(..)</code> call directly, which is
itself a function, not a computed result. <em>That</em> function lets us pass in as
many arguments as we want, passing them all down the line to the first function
call in the composition, then bubbling up each result through each subsequent
call.</p>
<p>Instead of calculating the running result and passing it along as the
<code>reduce(..)</code> looping proceeds, this implementation runs the <code>reduce(..)</code> looping
<strong>once</strong> up front at composition time, and defers all the function call
calculations -- referred to as lazy calculation. Each partial result of the
reduction is a successively more wrapped function.</p>
<p>When you call the final composed function and provide one or more arguments, all
the levels of the big nested function, from the inner most call to the outer,
are executed in reverse succession (not via a loop).</p>
<p>The performance characteristics will potentially be different than in the
previous <code>reduce(..)</code>-based implementation. Here, <code>reduce(..)</code> only runs once to
produce a big composed function, and then this composed function call simply
executes all its nested functions each call. In the former version, <code>reduce(..)</code>
would be run for every call.</p>
<p>Your mileage may vary on which implementation is better, but keep in mind that
this latter implementation isn't limited in argument count the way the former
one is.</p>
<p>We could also define <code>compose(..)</code> using recursion. The recursive definition for
<code>compose(fn1,fn2, .. fnN)</code> would look like:</p>
<pre><code class="language-txt">compose( compose(fn1,fn2, .. fnN-1), fnN );
</code></pre>
<p><strong>Note:</strong> We will cover recursion more fully in <a href="chapter_8.html">Chapter 8</a>, so if
this approach seems confusing, don't worry for now. Or, go read that chapter
then come back and re-read this note. :)</p>
<p>Here's how we implement <code>compose(..)</code> with recursion:</p>
<pre><code class="language-js">function compose(...fns) {
  // pull off the last two arguments
  var [fn1, fn2, ...rest] = fns.reverse();

  var composedFn = function composed(...args) {
    return fn2(fn1(...args));
  };

  if (rest.length == 0) return composedFn;

  return compose(...rest.reverse(), composedFn);
}

// or the ES6 =&gt; form
var compose = (...fns) =&gt; {
  // pull off the last two arguments
  var [fn1, fn2, ...rest] = fns.reverse();

  var composedFn = (...args) =&gt; fn2(fn1(...args));

  if (rest.length == 0) return composedFn;

  return compose(...rest.reverse(), composedFn);
};
</code></pre>
<p>I think the benefit of a recursive implementation is mostly conceptual. I
personally find it much easier to think about a repetitive action in recursive
terms instead of in a loop where I have to track the running result, so I prefer
the code to express it that way.</p>
<p>Others will find the recursive approach quite a bit more daunting to mentally
juggle. I invite you to make your own evaluations.</p>
<h2><a class="header" href="#reordered-composition" id="reordered-composition">Reordered Composition</a></h2>
<p>We talked earlier about the right-to-left ordering of standard <code>compose(..)</code>
implementations. The advantage is in listing the arguments (functions) in the
same order they'd appear if doing the composition manually.</p>
<p>The disadvantage is they're listed in the reverse order that they execute, which
could be confusing. It was also more awkward to have to use
<code>partialRight(compose, ..)</code> to pre-specify the <em>first</em> function(s) to execute in
the composition.</p>
<p>The reverse ordering, composing from left-to-right, has a common name:
<code>pipe(..)</code>. This name is said to come from Unix/Linux land, where multiple
programs are strung together by &quot;pipe&quot;ing (<code>|</code> operator) the output of the first
one in as the input of the second, and so on (i.e.,
<code>ls -la | grep &quot;foo&quot; | less</code>).</p>
<p><code>pipe(..)</code> is identical to <code>compose(..)</code> except it processes through the list of
functions in left-to-right order:</p>
<pre><code class="language-js">function pipe(...fns) {
  return function piped(result) {
    var list = [...fns];

    while (list.length &gt; 0) {
      // take the first function from the list
      // and execute it
      result = list.shift()(result);
    }

    return result;
  };
}
</code></pre>
<p>In fact, we could just define <code>pipe(..)</code> as the arguments-reversal of
<code>compose(..)</code>:</p>
<pre><code class="language-js">var pipe = reverseArgs(compose);
</code></pre>
<p>That was easy!</p>
<p>Recall this example from general composition earlier:</p>
<pre><code class="language-js">var biggerWords = compose(skipShortWords, unique, words);
</code></pre>
<p>To express that with <code>pipe(..)</code>, we just reverse the order we list them in:</p>
<pre><code class="language-js">var biggerWords = pipe(words, unique, skipShortWords);
</code></pre>
<p>The advantage of <code>pipe(..)</code> is that it lists the functions in order of
execution, which can sometimes reduce reader confusion. It may be simpler to
read the code: <code>pipe( words, unique, skipShortWords )</code>, and recognize that it's
executing <code>words(..)</code> first, then <code>unique(..)</code>, and finally
<code>skipShortWords(..)</code>.</p>
<p><code>pipe(..)</code> is also handy if you're in a situation where you want to partially
apply the <em>first</em> function(s) that execute. Earlier we did that with
right-partial application of <code>compose(..)</code>.</p>
<p>Compare:</p>
<pre><code class="language-js">var filterWords = partialRight(compose, unique, words);

// vs

var filterWords = partial(pipe, words, unique);
</code></pre>
<p>As you may recall from our first implementation of
<a href="chapter_3.html"><code>partialRight(..)</code> in Chapter 3</a>, it
uses <code>reverseArgs(..)</code> under the covers, just as our <code>pipe(..)</code> now does. So we
get the same result either way.</p>
<p><em>In this specific case</em>, the slight performance advantage to using <code>pipe(..)</code>
is, because we're not trying to preserve the right-to-left argument order of
<code>compose(..)</code>, we don't need to reverse the argument order back, like we do
inside <code>partialRight(..)</code>. So <code>partial(pipe, ..)</code> is a little more efficient
here than <code>partialRight(compose, ..)</code>.</p>
<h2><a class="header" href="#abstraction" id="abstraction">Abstraction</a></h2>
<p>Abstraction plays heavily into our reasoning about composition, so let's examine
it in more detail.</p>
<p>Similar to how partial application and currying (see
<a href="chapter_3.html">Chapter 3</a>) allow a progression from
generalized to specialized functions, we can abstract by pulling out the
generality between two or more tasks. The general part is defined once, so as to
avoid repetition. To perform each task's specialization, the general part is
parameterized.</p>
<p>For example, consider this (obviously contrived) code:</p>
<pre><code class="language-js">function saveComment(txt) {
  if (txt != &quot;&quot;) {
    comments[comments.length] = txt;
  }
}

function trackEvent(evt) {
  if (evt.name !== undefined) {
    events[evt.name] = evt;
  }
}
</code></pre>
<p>Both of these utilities are storing a value in a data source. That's the
generality. The specialty is that one of them sticks the value at the end of an
array, while the other sets the value at a property name of an object.</p>
<p>So let's abstract:</p>
<pre><code class="language-js">function storeData(store, location, value) {
  store[location] = value;
}

function saveComment(txt) {
  if (txt != &quot;&quot;) {
    storeData(comments, comments.length, txt);
  }
}

function trackEvent(evt) {
  if (evt.name !== undefined) {
    storeData(events, evt.name, evt);
  }
}
</code></pre>
<p>The general task of referencing a property on an object (or array, thanks to
JS's convenient operator overloading of <code>[ ]</code>) and setting its value is
abstracted into its own function <code>storeData(..)</code>. While this utility only has a
single line of code right now, one could envision other general behavior that
was common across both tasks, such as generating a unique numeric ID or storing
a timestamp with the value.</p>
<p>If we repeat the common general behavior in multiple places, we run the
maintenance risk of changing some instances but forgetting to change others.
There's a principle at play in this kind of abstraction, often referred to as
&quot;don't repeat yourself&quot; (DRY).</p>
<p>DRY strives to have only one definition in a program for any given task. An
alternative aphorism to motivate DRY coding is that programmers are just
generally lazy and don't want to do unnecessary work.</p>
<p>Abstraction can be taken too far. Consider:</p>
<pre><code class="language-js">function conditionallyStoreData(store, location, value, checkFn) {
  if (checkFn(value, store, location)) {
    store[location] = value;
  }
}

function notEmpty(val) {
  return val != &quot;&quot;;
}

function isUndefined(val) {
  return val === undefined;
}

function isPropUndefined(val, obj, prop) {
  return isUndefined(obj[prop]);
}

function saveComment(txt) {
  conditionallyStoreData(comments, comments.length, txt, notEmpty);
}

function trackEvent(evt) {
  conditionallyStoreData(events, evt.name, evt, isPropUndefined);
}
</code></pre>
<p>In an effort to be DRY and avoid repeating an <code>if</code> statement, we moved the
conditional into the general abstraction. We also assumed that we <em>may</em> have
checks for non-empty strings or non-<code>undefined</code> values elsewhere in the program
in the future, so we might as well DRY those out, too!</p>
<p>This code <em>is</em> more DRY, but to an overkill extent. Programmers must be careful
to apply the appropriate levels of abstraction to each part of their program, no
more, no less.</p>
<p>Regarding our greater discussion of function composition in this chapter, it
might seem like its benefit is this kind of DRY abstraction. But let's not jump
to that conclusion, because I think composition actually serves a more important
purpose in our code.</p>
<p>Moreover, <strong>composition is helpful even if there's only one occurrence of
something</strong> (no repetition to DRY out).</p>
<h3><a class="header" href="#separation-enables-focus" id="separation-enables-focus">Separation Enables Focus</a></h3>
<p>Aside from generalization vs. specialization, I think there's another more
useful definition for abstraction, as revealed by this quote:</p>
<blockquote>
<p>... abstraction is a process by which the programmer associates a name with a
potentially complicated program fragment, which can then be thought of in
terms of its purpose of function, rather than in terms of how that function is
achieved. By hiding irrelevant details, abstraction reduces conceptual
complexity, making it possible for the programmer to focus on a manageable
subset of the program text at any particular time.</p>
<p>Michael L. Scott, Programming Language
Pragmatics<a href="#user-content-footnote-1"><sup>1</sup></a></p>
</blockquote>
<p>The point this quote makes is that abstraction -- generally, pulling out some
piece of code into its own function -- serves the primary purpose of separating
apart two pieces of functionality so that it's possible to focus on each piece
independently of the other.</p>
<p>Note that abstraction in this sense is not really intended to <em>hide</em> details, as
if to treat things as black boxes we <em>never</em> examine.</p>
<p>In this quote, &quot;irrelevant&quot;, in terms of what is hidden, shouldn't be thought of
as an absolute qualitative judgement, but rather relative to what you want to
focus on at any given moment. In other words, when we separate X from Y, if I
want to focus on X, Y is irrelevant at that moment. At another time, if I want
to focus on Y, X is irrelevant at that moment.</p>
<p><strong>We're not abstracting to hide details; we're separating details to improve
focus.</strong></p>
<p>Recall that at the outset of this book I stated that FP's goal is to create code
that is more readable and understandable. One effective way of doing that is
untangling complected (read: tightly braided, as in strands of rope) code into
separate, simpler (read: loosely bound) pieces of code. In that way, the reader
isn't distracted by the details of one part while looking for the details of the
other part.</p>
<p>Our higher goal is not to implement something only once, as it is with the DRY
mindset. As a matter of fact, sometimes we'll actually repeat ourselves in code.</p>
<p>As we
<a href="chapter_3.html">asserted in Chapter 3</a>, the
main goal with abstraction is to implement separate things, separately. We're
trying to improve focus, because that improves readability.</p>
<p>By separating two ideas, we insert a semantic boundary between them, which
affords us the ability to focus on each side independent of the other. In many
cases, that semantic boundary is something like the name of a function. The
function's implementation is focused on <em>how</em> to compute something, and the
call-site using that function by name is focused on <em>what</em> to do with its
output. We abstract the <em>how</em> from the <em>what</em> so they are separate and
separately reason'able.</p>
<p>Another way of describing this goal is with imperative vs. declarative
programming style. Imperative code is primarily concerned with explicitly
stating <em>how</em> to accomplish a task. Declarative code states <em>what</em> the outcome
should be, and leaves the implementation to some other responsibility.</p>
<p>Declarative code abstracts the <em>what</em> from the <em>how</em>. Typically declarative
coding is favored in readability over imperative, though no program (except of
course machine code 1s and 0s) is ever entirely one or the other. The programmer
must seek balance between them.</p>
<p>ES6 added many syntactic affordances that transform old imperative operations
into newer declarative forms. Perhaps one of the clearest is destructuring.
Destructuring is a pattern for assignment that describes how a compound value
(object, array) is taken apart into its constituent values.</p>
<p>Here's an example of array destructuring:</p>
<pre><code class="language-js">function getData() {
  return [1, 2, 3, 4, 5];
}

// imperative
var tmp = getData();
var a = tmp[0];
var b = tmp[3];

// declarative
var [a, , , b] = getData();
</code></pre>
<p>The <em>what</em> is assigning the first value of the array to <code>a</code> and the fourth value
to <code>b</code>. The <em>how</em> is getting a reference to the array (<code>tmp</code>) and manually
referencing indexes <code>0</code> and <code>3</code> in assignments to <code>a</code> and <code>b</code>, respectively.</p>
<p>Does the array destructuring <em>hide</em> the assignment? Depends on your perspective.
I'm asserting that it simply separates the <em>what</em> from the <em>how</em>. The JS engine
still does the assignments, but it prevents you from having to be distracted by
<em>how</em> it's done.</p>
<p>Instead, you read <code>[ a ,,, b ] = ..</code> and can see the assignment pattern merely
telling you <em>what</em> will happen. Array destructuring is an example of declarative
abstraction.</p>
<h3><a class="header" href="#composition-as-abstraction" id="composition-as-abstraction">Composition as Abstraction</a></h3>
<p>What's all this have to do with function composition? Function composition is
also declarative abstraction.</p>
<p>Recall the <code>shorterWords(..)</code> example from earlier. Let's compare an imperative
and declarative definition for it:</p>
<pre><code class="language-js">// imperative
function shorterWords(text) {
  return skipLongWords(unique(words(text)));
}

// declarative
var shorterWords = compose(skipLongWords, unique, words);
</code></pre>
<p>The declarative form focuses on the <em>what</em> -- these three functions pipe data
from a string to a list of shorter words -- and leaves the <em>how</em> to the
internals of <code>compose(..)</code>.</p>
<p>In a bigger sense, the <code>shorterWords = compose(..)</code> line explains the <em>how</em> for
defining a <code>shorterWords(..)</code> utility, leaving this declarative line somewhere
else in the code to focus only on the <em>what</em>:</p>
<pre><code class="language-js">shorterWords(text);
</code></pre>
<p>Composition abstracts getting a list of shorter words from the steps it takes to
do that.</p>
<p>By contrast, what if we hadn't used composition abstraction?</p>
<pre><code class="language-js">var wordsFound = words(text);
var uniqueWordsFound = unique(wordsFound);
skipLongWords(uniqueWordsFound);
</code></pre>
<p>Or even:</p>
<pre><code class="language-js">skipLongWords(unique(words(text)));
</code></pre>
<p>Either of these two versions demonstrates a more imperative style as opposed to
the prior declarative style. The reader's focus in those two snippets is
inextricably tied to the <em>how</em> and less on the <em>what</em>.</p>
<p>Function composition isn't just about saving code with DRY. Even if the usage of
<code>shorterWords(..)</code> only occurs in one place -- so there's no repetition to
avoid! -- separating the <em>how</em> from the <em>what</em> still improves our code.</p>
<p>Composition is a powerful tool for abstraction that transforms imperative code
into more readable declarative code.</p>
<h2><a class="header" href="#revisiting-points" id="revisiting-points">Revisiting Points</a></h2>
<p>Now that we've thoroughly covered composition (a trick that will be immensely
helpful in many areas of FP), let's watch it in action by revisiting point-free
style from <a href="chapter_3.html">Chapter 3, &quot;No Points&quot;</a> with a scenario
that's a fair bit more complex to refactor:</p>
<pre><code class="language-js">// given: ajax( url, data, cb )

var getPerson = partial(ajax, &quot;http://some.api/person&quot;);
var getLastOrder = partial(ajax, &quot;http://some.api/order&quot;, { id: -1 });

getLastOrder(function orderFound(order) {
  getPerson({ id: order.personId }, function personFound(person) {
    output(person.name);
  });
});
</code></pre>
<p>The &quot;points&quot; we'd like to remove are the <code>order</code> and <code>person</code> parameter
references.</p>
<p>Let's start by trying to get the <code>person</code> &quot;point&quot; out of the <code>personFound(..)</code>
function. To do so, let's first define:</p>
<pre><code class="language-js">function extractName(person) {
  return person.name;
}
</code></pre>
<p>Consider that this operation could instead be expressed in generic terms:
extracting any property by name off of any object. Let's call such a utility
<code>prop(..)</code>:</p>
<pre><code class="language-js">function prop(name, obj) {
  return obj[name];
}

// or the ES6 =&gt; form
var prop = (name, obj) =&gt; obj[name];
</code></pre>
<p>While we're dealing with object properties, let's also define the opposite
utility: <code>setProp(..)</code> for setting a property value onto an object.</p>
<p>However, we want to be careful not to just mutate an existing object but rather
create a clone of the object to make the change to, and then return it. The
reasons for such care will be discussed at length in <a href="chapter_5.html">Chapter 5</a>.</p>
<p><a name="setprop"></a></p>
<pre><code class="language-js">function setProp(name, obj, val) {
  var o = Object.assign({}, obj);
  o[name] = val;
  return o;
}
</code></pre>
<p>Now, to define an <code>extractName(..)</code> that pulls a <code>&quot;name&quot;</code> property off an
object, we'll partially apply <code>prop(..)</code>:</p>
<pre><code class="language-js">var extractName = partial(prop, &quot;name&quot;);
</code></pre>
<p><strong>Note:</strong> Don't miss that <code>extractName(..)</code> here hasn't actually extracted
anything yet. We partially applied <code>prop(..)</code> to make a function that's waiting
to extract the <code>&quot;name&quot;</code> property from whatever object we pass into it. We could
also have done it with <code>curry(prop)(&quot;name&quot;)</code>.</p>
<p>Next, let's narrow the focus on our example's nested lookup calls to this:</p>
<pre><code class="language-js">getLastOrder(function orderFound(order) {
  getPerson({ id: order.personId }, outputPersonName);
});
</code></pre>
<p>How can we define <code>outputPersonName(..)</code>? To visualize what we need, think about
the desired flow of data:</p>
<pre><code class="language-txt">output &lt;-- extractName &lt;-- person
</code></pre>
<p><code>outputPersonName(..)</code> needs to be a function that takes an (object) value,
passes it into <code>extractName(..)</code>, then passes that value to <code>output(..)</code>.</p>
<p>Hopefully you recognized that as a <code>compose(..)</code> operation. So we can define
<code>outputPersonName(..)</code> as:</p>
<pre><code class="language-js">var outputPersonName = compose(output, extractName);
</code></pre>
<p>The <code>outputPersonName(..)</code> function we just created is the callback provided to
<code>getPerson(..)</code>. So we can define a function called <code>processPerson(..)</code> that
presets the callback argument, using <code>partialRight(..)</code>:</p>
<pre><code class="language-js">var processPerson = partialRight(getPerson, outputPersonName);
</code></pre>
<p>Let's reconstruct the nested lookups example again with our new function:</p>
<pre><code class="language-js">getLastOrder(function orderFound(order) {
  processPerson({ id: order.personId });
});
</code></pre>
<p>Phew, we're making good progress!</p>
<p>But we need to keep going and remove the <code>order</code> &quot;point&quot;. The next step is to
observe that <code>personId</code> can be extracted from an object (like <code>order</code>) via
<code>prop(..)</code>, just like we did with <code>name</code> on the <code>person</code> object:</p>
<pre><code class="language-js">var extractPersonId = partial(prop, &quot;personId&quot;);
</code></pre>
<p>To construct the object (of the form <code>{ id: .. }</code>) that needs to be passed to
<code>processPerson(..)</code>, let's make another utility for wrapping a value in an
object at a specified property name, called <code>makeObjProp(..)</code>:</p>
<pre><code class="language-js">function makeObjProp(name, value) {
  return setProp(name, {}, value);
}

// or the ES6 =&gt; form
var makeObjProp = (name, value) =&gt; setProp(name, {}, value);
</code></pre>
<p><strong>Tip:</strong> This utility is known as <code>objOf(..)</code> in the Ramda library.</p>
<p>Just as we did with <code>prop(..)</code> to make <code>extractName(..)</code>, we'll partially apply
<code>makeObjProp(..)</code> to build a function <code>personData(..)</code> that makes our data
object:</p>
<pre><code class="language-js">var personData = partial(makeObjProp, &quot;id&quot;);
</code></pre>
<p>To use <code>processPerson(..)</code> to perform the lookup of a person attached to an
<code>order</code> value, the conceptual flow of data through operations we need is:</p>
<pre><code class="language-txt">processPerson &lt;-- personData &lt;-- extractPersonId &lt;-- order
</code></pre>
<p>So we'll just use <code>compose(..)</code> again to define a <code>lookupPerson(..)</code> utility:</p>
<pre><code class="language-js">var lookupPerson = compose(processPerson, personData, extractPersonId);
</code></pre>
<p>And... that's it! Putting the whole example back together without any &quot;points&quot;:</p>
<pre><code class="language-js">var getPerson = partial(ajax, &quot;http://some.api/person&quot;);
var getLastOrder = partial(ajax, &quot;http://some.api/order&quot;, { id: -1 });

var extractName = partial(prop, &quot;name&quot;);
var outputPersonName = compose(output, extractName);
var processPerson = partialRight(getPerson, outputPersonName);
var personData = partial(makeObjProp, &quot;id&quot;);
var extractPersonId = partial(prop, &quot;personId&quot;);
var lookupPerson = compose(processPerson, personData, extractPersonId);

getLastOrder(lookupPerson);
</code></pre>
<p>Wow. Point-free. And <code>compose(..)</code> turned out to be really helpful in two
places!</p>
<p>I think in this case, even though the steps to derive our final answer were a
bit drawn out, the end result is much more readable code, because we've ended up
explicitly calling out each step.</p>
<p>And even if you didn't like seeing/naming all those intermediate steps, you can
preserve point-free but wire the expressions together without individual
variables:</p>
<pre><code class="language-js">partial(ajax, &quot;http://some.api/order&quot;, { id: -1 })(
  compose(
    partialRight(
      partial(ajax, &quot;http://some.api/person&quot;),
      compose(output, partial(prop, &quot;name&quot;))
    ),
    partial(makeObjProp, &quot;id&quot;),
    partial(prop, &quot;personId&quot;)
  )
);
</code></pre>
<p>This snippet is less verbose for sure, but I think it's less readable than the
previous snippet where each operation is its own variable. Either way,
composition helped us with our point-free style.</p>
<h2><a class="header" href="#summary" id="summary">Summary</a></h2>
<p>Function composition is a pattern for defining a function that routes the output
of one function call into another function call, and its output to another, and
so on.</p>
<p>Because JS functions can only return single values, the pattern essentially
dictates that all functions in the composition (except perhaps the first called)
need to be unary, taking only a single input from the output of the previous
function.</p>
<p>Instead of listing out each step as a discrete call in our code, function
composition using a utility like <code>compose(..)</code> or <code>pipe(..)</code> abstracts that
implementation detail so the code is more readable, allowing us to focus on
<em>what</em> the composition will be used to accomplish, not <em>how</em> it will be
performed.</p>
<p>Composition is declarative data flow, meaning our code describes the flow of
data in an explicit, obvious, and readable way.</p>
<p>In many ways, composition is the most important foundational pattern, in large
part because it's the only way to route data through our programs aside from
using side effects; the next chapter explores why such should be avoided
wherever possible.</p>
<hr />
<p><a name="footnote-1"><sup>1</sup></a>Scott, Michael L. Chapter 3: Names,
Scopes, and Bindings. Programming Language Pragmatics, 4th ed., Morgan
Kaufmann, 2015, pp. 115.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="chapter_3.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="chapter_5.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="chapter_3.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="chapter_5.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
